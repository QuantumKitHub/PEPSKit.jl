var documenterSearchIndex = {"docs":
[{"location":"lib/lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/lib/","page":"Library","title":"Library","text":"Modules = [PEPSKit, PEPSKit.Defaults]","category":"page"},{"location":"lib/lib/#PEPSKit.ALSTruncation","page":"Library","title":"PEPSKit.ALSTruncation","text":"ALSTruncation\n\nAlgorithm struct for the alternating least square (ALS) optimization of a bond. \n\ntrscheme::Bool: SVD truncation scheme when initilizing the truncated tensors connected by the bond.\nmaxiter::Int: Maximal number of ALS iterations.\ntol::Float64: ALS converges when fidelity change between two FET iterations is smaller than tol.\ncheck_interval::Int: Set number of iterations to print information. Output is suppressed when check_interval <= 0. \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGAlgorithm","page":"Library","title":"PEPSKit.CTMRGAlgorithm","text":"CTMRGAlgorithm\n\nAbstract super type for the corner transfer matrix renormalization group (CTMRG) algorithm for contracting infinite PEPS.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv","page":"Library","title":"PEPSKit.CTMRGEnv","text":"struct CTMRGEnv{C,T}\n\nCorner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.\n\nGiven arrays of corners c and edges t, they connect to the network tensors P at site (r, c) in the unit cell as:\n\n   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]\n   |              |             |\n   t[4,r,c-1]-----P[r,c]--------t[2,r,c+1]\n   |              |             |\n   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]\n\nHere P represents an effective local constituent tensor. This can either be a single rank-4 tensor, a pair of PEPS tensors, or a stack of PEPS-PEPO-PEPS tensors depending on the network being contracted.\n\nFields\n\ncorners::Array{C,3}: Array of corner tensors.\nedges::Array{T,3}: Array of edge tensors.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfiniteSquareNetwork, A}, Tuple{InfiniteSquareNetwork, A, A}, Tuple{InfiniteSquareNetwork, A, A, A}, Tuple{InfiniteSquareNetwork, Vararg{A, 4}}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], network::InfiniteSquareNetwork, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:AbstractMatrix{<:ElementarySpaceLike}}}\n\nConstruct a CTMRG environment by specifying a corresponding InfiniteSquareNetwork, and the north, east, south and west virtual spaces of the environment as matrices. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{B}, Tuple{A}, Tuple{A, A, B}, Tuple{A, A, B, B}, Tuple{A, A, B, B, B}, Tuple{A, A, Vararg{B, 4}}} where {A<:(AbstractMatrix{<:Union{NTuple{N, Int64}, NTuple{N, var\"#s81\"} where var\"#s81\"<:TensorKit.ElementarySpace, TensorKit.ProductSpace{<:TensorKit.ElementarySpace, N}} where N}), B<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, ComplexF64], Ds_north::A, Ds_east::A, chis_north::B, [chis_east::B], [chis_south::B], [chis_west::B]\n) where {A<:AbstractMatrix{<:SpaceLike}, B<:AbstractMatrix{<:ElementarySpaceLike}}\n\nConstruct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding partition function and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\nEach entry of the Ds_north and Ds_east matrices corresponds to an effective local space of the partition function, represented as a tuple of elementary spaces encoding a product space. This can either contain a single elementary space for the case of a partition function defined in terms of local rank-4 tensors, or a tuple of elementary spaces representing a product space for the case of a partition function representing overlaps of PEPSs and PEPOs.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfiniteSquareNetwork, S}, Tuple{InfiniteSquareNetwork, S, S}, Tuple{InfiniteSquareNetwork, S, S, S}, Tuple{InfiniteSquareNetwork, Vararg{S, 4}}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    peps::InfiniteSquareNetwork, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S],\n) where {S<:ElementarySpaceLike}\n\nConstruct a CTMRG environment by specifying a corresponding InfiniteSquareNetwork, and the north, east, south and west virtual spaces of the environment. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{P}, Tuple{P, P, S}, Tuple{P, P, S, S}, Tuple{P, P, S, S, S}, Tuple{P, P, Vararg{S, 4}}} where {P<:(Union{NTuple{N, Int64}, NTuple{N, var\"#s81\"} where var\"#s81\"<:TensorKit.ElementarySpace, TensorKit.ProductSpace{<:TensorKit.ElementarySpace, N}} where N), S<:Union{Int64, TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, ComplexF64], D_north::P, D_east::P, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S]; unitcell::Tuple{Int,Int}=(1, 1),\n) where {P<:ProductSpaceLike,S<:ElementarySpaceLike}\n\nConstruct a CTMRG environment by specifying the north and east virtual spaces of the corresponding InfiniteSquareNetwork and the north, east, south and west virtual spaces of the environment. The network unit cell can be specified by the unitcell keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.EigSolver","page":"Library","title":"PEPSKit.EigSolver","text":"struct EigSolver <: GradMode{iterscheme}\nEigSolver(; kwargs...)\n\nGradient mode wrapper around KrylovKit.KrylovAlgorithm for solving the gradient linear problem as an eigenvalue problem.\n\nKeyword arguments\n\ntol::Real=1.0e-6 : Convergence tolerance of the eigen solver.\nmaxiter::Int=30 : Maximal number of solver iterations.\nverbosity::Int=-1 : Output information verbosity of the linear solver.\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\nsolver_alg::Union{KrylovKit.KrylovAlgorithm,NamedTuple}=(; alg=:arnoldi : Eigen solver algorithm which, if supplied directly as a KrylovKit.KrylovAlgorithm overrides the above specified tol, maxiter and verbosity. Alternatively, it can be supplied via a NamedTuple where alg can be one of the following:\n:arnoldi : Arnoldi Krylov algorithm, see the KrylovKit docs for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.EnlargedCorner","page":"Library","title":"PEPSKit.EnlargedCorner","text":"struct EnlargedCorner{TC,TE,TA}\n\nEnlarged CTMRG corner tensor storage.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.EnlargedCorner-Tuple{InfiniteSquareNetwork, Any, Any}","page":"Library","title":"PEPSKit.EnlargedCorner","text":"EnlargedCorner(network::InfiniteSquareNetwork, env, coordinates)\n\nConstruct an enlarged corner with the correct row and column indices based on the given coordinates which are of the form (dir, row, col).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.FixedSVD","page":"Library","title":"PEPSKit.FixedSVD","text":"struct FixedSVD\n\nSVD struct containing a pre-computed decomposition or even multiple ones. The call to tsvd just returns the pre-computed U, S and V. In the reverse pass, the SVD adjoint is computed with these exact U, S, and V.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedSpaceTruncation","page":"Library","title":"PEPSKit.FixedSpaceTruncation","text":"struct FixedSpaceTruncation <: TensorKit.TruncationScheme\n\nCTMRG specific truncation scheme for tsvd which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from TruncationSpace.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullEnvTruncation","page":"Library","title":"PEPSKit.FullEnvTruncation","text":"FullEnvTruncation\n\nAlgorithm struct for the full environment truncation (FET).\n\ntrscheme::Bool: SVD truncation scheme when optimizing the new bond matrix.\nmaxiter::Int: Maximal number of FET iterations.\ntol::Float64: FET converges when fidelity change between two FET iterations is smaller than tol.\ntrunc_init::Bool: Controls whether the initialization of the new bond matrix is obtained from truncated SVD of the old bond matrix. \ncheck_interval::Int: Set number of iterations to print information. Output is suppressed when check_interval <= 0. \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullInfiniteEnv","page":"Library","title":"PEPSKit.FullInfiniteEnv","text":"struct FullInfiniteEnv{TC,TE,TA}\n\nFull-infinite CTMRG environment tensor storage.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullInfiniteEnv-Tuple{Any, Val{false}}","page":"Library","title":"PEPSKit.FullInfiniteEnv","text":"(env::FullInfiniteEnv)(x, ::Val{false}) \n(env::FullInfiniteEnv)(x, ::Val{true})\n\nContract full-infinite environment with a vector x, such that the environment acts as a linear map or adjoint linear map on x if Val(true) or Val(false) is passed, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.FullInfiniteProjector","page":"Library","title":"PEPSKit.FullInfiniteProjector","text":"struct FullInfiniteProjector{S,T} <: ProjectorAlgorithm\nFullInfiniteProjector(; kwargs...)\n\nProjector algorithm implementing projectors from SVDing the full 4x4 CTMRG environment.\n\nKeyword arguments\n\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}=SVDAdjoint() : SVD algorithm including the reverse rule. See 'SVDAdjoint'.\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nverbosity::Int=0 : Projector output verbosity which can be:\nSuppress output information\nPrint singular value degeneracy warnings\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GeomSum","page":"Library","title":"PEPSKit.GeomSum","text":"struct GeomSum <: GradMode{iterscheme}\nGeomSum(; kwargs...)\n\nGradient mode for CTMRG using explicit evaluation of the geometric sum.\n\nKeyword arguments\n\ntol::Real=1.0e-6 : Convergence tolerance for the difference of norms of two consecutive summands in the geometric sum.\nmaxiter::Int=30 : Maximal number of gradient iterations.\nverbosity::Int=-1 : Output information verbosity that can be one of the following:\nSuppress output information\nPrint convergence warnings\nInformation at each gradient iteration\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"struct HalfInfiniteEnv{C,E,A,A′}\n\nHalf-infinite CTMRG environment tensor storage.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv-Tuple{Any, Val{false}}","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"(env::HalfInfiniteEnv)(x, ::Val{false}) \n(env::HalfInfiniteEnv)(x, ::Val{true})\n\nContract half-infinite environment with a vector x, such that the environment acts as a linear map or adjoint linear map on x if Val(true) or Val(false) is passed, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.HalfInfiniteProjector","page":"Library","title":"PEPSKit.HalfInfiniteProjector","text":"struct HalfInfiniteProjector{S,T} <: ProjectorAlgorithm\nHalfInfiniteProjector(; kwargs...)\n\nProjector algorithm implementing projectors from SVDing the half-infinite CTMRG environment.\n\nKeyword arguments\n\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}=SVDAdjoint() : SVD algorithm including the reverse rule. See 'SVDAdjoint'.\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nverbosity::Int=0 : Projector output verbosity which can be:\nSuppress output information\nPrint singular value degeneracy warnings\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO","page":"Library","title":"PEPSKit.InfinitePEPO","text":"struct InfinitePEPO{T<:PEPOTensor}\n\nRepresents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A; unitcell=(1, 1, 1))\n\nCreate an InfinitePEPO by specifying a tensor and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::AbstractArray{T, 3})\n\nAllow users to pass in an array of tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A<:(AbstractArray{<:TensorKit.ElementarySpace, 3})","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(f=randn, T=ComplexF64, Pspaces, Nspaces, Espaces)\n\nAllow users to pass in arrays of spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1,1))\n\nCreate an InfinitePEPO by specifying its spaces and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS","page":"Library","title":"PEPSKit.InfinitePEPS","text":"struct InfinitePEPS{T<:PEPSTensor}\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{AbstractMatrix{<:TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::AbstractMatrix{T})\n\nCreate an InfinitePEPS by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{InfiniteWeightPEPS}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(peps::InfiniteWeightPEPS)\n\nCreate InfinitePEPS from InfiniteWeightPEPS by absorbing bond weights into vertex tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A; unitcell=(1, 1))\n\nCreate an InfinitePEPS by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            ||         ||\n---T[r,c-1]=====AA[r,c]====AA[r,c+1]====\n   |            ||         ||\n---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==\n   |            ||         ||\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{A}, Tuple{A, A, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(\n    f=randn, T=ComplexF64, Pspaces::A, Nspaces::A, [Espaces::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfinitePEPS by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1))\n\nCreate an InfinitePEPS by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via Int or via ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"struct InfinitePartitionFunction{T<:PartitionFunctionTensor}\n\nRepresents an infinite partition function on a 2D square lattice.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(A; unitcell=(1, 1))\n\nCreate an InfinitePartitionFunction by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if partition function tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            |          |\n---T[r,c-1]-----AA[r,c]----AA[r,c+1]----\n   |            |          |\n---T[r+1,c-1]---AA[r+1,c]--AA[r+1,c+1]--\n   |            |          |\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(A::AbstractMatrix{T})\n\nCreate an InfinitePartitionFunction by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{A}, Tuple{A, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(\n    f=randn, T=ComplexF64, Pspaces::A, Nspaces::A, [Espaces::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfinitePartitionFunction by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{S}, Tuple{S, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1))\n\nCreate an InfinitePartitionFunction by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via Int or via ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteSquare","page":"Library","title":"PEPSKit.InfiniteSquare","text":"InfiniteSquare(Nrows::Integer=1, Ncols::Integer=1)\n\nInfinite square lattice with a unit cell of size (Nrows, Ncols).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteSquareNetwork","page":"Library","title":"PEPSKit.InfiniteSquareNetwork","text":"InfiniteSquareNetwork{O}\n\nContractible square network. Wraps a matrix of 'rank-4-tensor-like' objects.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO{H,T,O}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS{T}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS(T::InfinitePEPS, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"struct InfiniteWeightPEPS{T<:PEPSTensor,E<:PEPSWeight}\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice consisting of vertex tensors and bond weights.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS-Union{Tuple{E}, Tuple{T}, Tuple{Matrix{T}, Vararg{Matrix{E}}}} where {T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), E<:(TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S})}","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"InfiniteWeightPEPS(\n    vertices::Matrix{T}, weight_mats::Matrix{E}...\n) where {T<:PEPSTensor,E<:PEPSWeight}\n\nCreate an InfiniteWeightPEPS from matrices of vertex tensors, and separate matrices of weights on each type of bond at all locations in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS-Union{Tuple{M}, Tuple{M, M, M}} where M<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"InfiniteWeightPEPS(\n    f=randn, T=ComplexF64, Pspaces::M, Nspaces::M, [Espaces::M]\n) where {M<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfiniteWeightPEPS by specifying the physical, north virtual and east virtual spaces of the PEPS vertex tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace. Bond weights are initialized as identity matrices of element type Float64. \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS-Union{Tuple{S}, Tuple{Any, Any, S, S}, Tuple{Any, Any, S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"InfiniteWeightPEPS(\n    f, T, Pspace::S, Nspace::S, Espace::S=Nspace; unitcell::Tuple{Int,Int}=(1, 1)\n) where {S<:ElementarySpace}\n\nCreate an InfiniteWeightPEPS by specifying its physical, north and east spaces (as ElementarySpaces) and unit cell size. Use T to specify the element type of the vertex tensors.  Bond weights are initialized as identity matrices of element type Float64. \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.IterSVD","page":"Library","title":"PEPSKit.IterSVD","text":"struct IterSVD(; alg=KrylovKit.GKL(), fallback_threshold = Inf, start_vector=random_start_vector)\nIterSVD(; kwargs...)\n\nIterative SVD solver based on KrylovKit's GKL algorithm, adapted to (symmetric) tensors. The number of targeted singular values is set via the TruncationSpace in ProjectorAlg. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn't converge, the algorithm falls back to a dense SVD.\n\nKeyword arguments\n\nalg::KrlovKit.GKL=KrylovKit.GKL(; tol=1e-14, krylovdim=25): GKL algorithm struct for block-wise iterative SVD.\nfallback_threshold::Float64=Inf: Threshold for howmany / minimum(size(block)) above which (if the block is too small) the algorithm falls back to TensorKit's dense SVD.\nstart_vector=random_start_vector: Function providing the initial vector for the iterative SVD algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LinSolver","page":"Library","title":"PEPSKit.LinSolver","text":"struct LinSolver <: GradMode{iterscheme}\nLinSolver(; kwargs...)\n\nGradient mode wrapper around KrylovKit.LinearSolver for solving the gradient linear problem using iterative solvers.\n\nKeyword arguments\n\ntol::Real=1.0e-6 : Convergence tolerance of the linear solver.\nmaxiter::Int=30 : Maximal number of solver iterations.\nverbosity::Int=-1 : Output information verbosity of the linear solver.\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\nsolver_alg::Union{KrylovKit.LinearSolver,NamedTuple}=(; alg::Symbol=:bicgstab : Linear solver algorithm which, if supplied directly as a KrylovKit.LinearSolver overrides the above specified tol, maxiter and verbosity. Alternatively, it can be supplied via a NamedTuple where alg can be one of the following:\n:gmres : GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab : BiCGStab iterative linear solver, see the KrylovKit docs for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LocalOperator","page":"Library","title":"PEPSKit.LocalOperator","text":"struct LocalOperator{T<:Tuple,S}\n\nA sum of local operators acting on a lattice. The lattice is stored as a matrix of vector spaces, and the terms are stored as a tuple of pairs of indices and operators.\n\nFields\n\nlattice::Matrix{S}: The lattice on which the operator acts.\nterms::T: The terms of the operator, stored as a tuple of pairs of indices and operators.\n\nConstructors\n\nLocalOperator(lattice::Matrix{S}, terms::Pair...)\nLocalOperator{T,S}(lattice::Matrix{S}, terms::T) where {T,S} # expert mode\n\nExamples\n\nlattice = fill(ℂ^2, 1, 1) # single-site unitcell\nO1 = LocalOperator(lattice, ((1, 1),) => σx, ((1, 1), (1, 2)) => σx ⊗ σx, ((1, 1), (2, 1)) => σx ⊗ σx)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ManualIter","page":"Library","title":"PEPSKit.ManualIter","text":"struct ManualIter <: GradMode{iterscheme}\nManualIter(; kwargs...)\n\nGradient mode for CTMRG using manual iteration to solve the linear problem.\n\nKeyword arguments\n\ntol::Real=1.0e-6 : Convergence tolerance for the norm difference of two consecutive dx contributions.\nmaxiter::Int=30 : Maximal number of gradient iterations.\nverbosity::Int=-1 : Output information verbosity that can be one of the following:\nSuppress output information\nPrint convergence warnings\nInformation at each gradient iteration\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPO","page":"Library","title":"PEPSKit.MultilineTransferPEPO","text":"const MultilineTransferPEPO = MPSKit.Multiline{<:InfiniteTransferPEPO}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any}","page":"Library","title":"PEPSKit.MultilineTransferPEPO","text":"MultilineTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPS","page":"Library","title":"PEPSKit.MultilineTransferPEPS","text":"const MultilineTransferPEPS = MPSKit.Multiline{<:InfiniteTransferPEPS}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPS-Tuple{InfinitePEPS, Any}","page":"Library","title":"PEPSKit.MultilineTransferPEPS","text":"MultilineTransferPEPS(T::InfinitePEPS, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.PEPOTensor","page":"Library","title":"PEPSKit.PEPOTensor","text":"const PEPOTensor{S}\n\nDefault type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: T  P  P  N  E  S  W. Here, P and P denote the incoming and outgoing physical space respectively, encoding the physical mapping from P to P where P corresponds to a physical PEPS index. N, E, S and W denote the physics, north, east, south and west spaces, respectively.\n\n        P´ N\n        | ╱\n        |╱\n   W---- ----E\n       ╱|\n      ╱ |\n     S  P\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSOptimize","page":"Library","title":"PEPSKit.PEPSOptimize","text":"struct PEPSOptimize{G}\nPEPSOptimize(; kwargs...)\n\nAlgorithm struct for PEPS ground-state optimization using AD. See fixedpoint for details.\n\nKeyword arguments\n\nboundary_alg::Union{NamedTuple,<:CTMRGAlgorithm} : Supply boundary algorithm parameters using either a NamedTuple of keyword arguments or a CTMRGAlgorithm directly. See leading_boundary for a description of all possible keyword arguments.\ngradient_alg::Union{NamedTuple,Nothing,<:GradMode} : Supply gradient algorithm parameters using either a NamedTuple of keyword arguments, nothing, or a GradMode directly. See fixedpoint for a description of all possible keyword arguments.\noptimizer_alg::Union{NamedTuple,<:OptimKit.OptimizationAlgorithm} : Supply optimizer algorithm parameters using either a NamedTuple of keyword arguments, or a OptimKit.OptimizationAlgorithm directly. See fixedpoint for a description of all possible keyword arguments.\nreuse_env::Bool=true : If true, the current optimization step is initialized on the previous environment, otherwise a random environment is used.\nsymmetrization::Union{Nothing,SymmetrizationStyle}=nothing : Accepts nothing or a SymmetrizationStyle, in which case the PEPS and PEPS gradient are symmetrized after each optimization iteration.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor","page":"Library","title":"PEPSKit.PEPSTensor","text":"const PEPSTensor{S}\n\nDefault type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: T  P  N  E  S  W. Here, P denotes the physical space and N, E, S and W denote the north, east, south and west virtual spaces, respectively.\n\n           N\n          ╱\n         ╱\n   W---- ----E\n       ╱|\n      ╱ |\n     S  P\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.PEPSTensor","text":"PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,\n           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S<:ElementarySpace}\nPEPSTensor(f, ::Type{T}, Pspace::Int, Nspace::Int,\n           [Espace::Int], [Sspace::Int], [Wspace::Int]) where {T}\n\nConstruct a PEPS tensor based on the physical, north, east, west and south spaces. Alternatively, only the space dimensions can be provided and ℂ is assumed as the field. The tensor elements are generated based on f and the element type is specified in T.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.PEPSWeight","page":"Library","title":"PEPSKit.PEPSWeight","text":"const PEPSWeight\n\nDefault type for PEPS bond weights with 2 virtual indices, conventionally ordered as: wt  WS  EN.  WS, EN denote the west/south, east/north spaces for x/y-weights on the square lattice, respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PartitionFunctionTensor","page":"Library","title":"PEPSKit.PartitionFunctionTensor","text":"const PartitionFunctionTensor{S}\n\nDefault type for partition function tensors with 4 virtual indices, conventionally ordered as: T  W  S  N  E. Here, N, E, S and W denote the north, east, south and west spaces, respectively.\n\n          N\n         ╱\n        ╱\n  W---- ----E\n      ╱\n     ╱\n    S \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ProjectorAlgorithm","page":"Library","title":"PEPSKit.ProjectorAlgorithm","text":"ProjectorAlgorithm\n\nAbstract super type for all CTMRG projector algorithms.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectDepth","page":"Library","title":"PEPSKit.ReflectDepth","text":"struct ReflectDepth <: SymmetrizationStyle\n\nReflection symmmetrization along the horizontal axis, such that north and south are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectWidth","page":"Library","title":"PEPSKit.ReflectWidth","text":"struct ReflectWidth <: SymmetrizationStyle\n\nReflection symmmetrization along the vertical axis, such that east and west are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.Rotate","page":"Library","title":"PEPSKit.Rotate","text":"struct Rotate <: SymmetrizationStyle\n\nRotation symmmetrization leaving the object invariant under π/2 rotations.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.RotateReflect","page":"Library","title":"PEPSKit.RotateReflect","text":"struct RotateReflect <: SymmetrizationStyle\n\nFull reflection and rotation symmmetrization, such that reflection along the horizontal and vertical axis as well as π/2 rotations leave the object invariant.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SUWeight","page":"Library","title":"PEPSKit.SUWeight","text":"struct SUWeight{E<:PEPSWeight}\n\nSchmidt bond weights used in simple/cluster update. Weight elements are always real.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SVDAdjoint","page":"Library","title":"PEPSKit.SVDAdjoint","text":"struct SVDAdjoint\nSVDAdjoint(; kwargs...)\n\nWrapper for a SVD algorithm fwd_alg with a defined reverse rule rrule_alg. If isnothing(rrule_alg), Zygote differentiates the forward call automatically. In case of degenerate singular values, one might need a broadening scheme which removes the divergences from the adjoint.\n\nKeyword arguments\n\nfwd_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=sdd): SVD algorithm of the forward pass which can either be passed as an Algorithm instance or a NamedTuple where alg is one of the following:\n:sdd: TensorKit's wrapper for LAPACK's _gesdd\n:svd: TensorKit's wrapper for LAPACK's _gesvd\n:iterative: Iterative SVD only computing the specifed number of singular values and vectors, see 'IterSVD'\nrrule_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=arnoldi): Reverse-rule algorithm for differentiating the SVD. Can be supplied by an Algorithm instance directly or as a NamedTuple where alg is one of the following:\n:gmres: GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab: BiCGStab iterative linear solver, see the KrylovKit docs for details\n:arnoldi: Arnoldi Krylov algorithm, see the KrylovKit docs for details\nbroadening=nothing: Broadening of singular value differences to stabilize the SVD gradient. Currently not implemented.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SequentialCTMRG","page":"Library","title":"PEPSKit.SequentialCTMRG","text":"struct SequentialCTMRG <: CTMRGAlgorithm\nSequentialCTMRG(; kwargs...)\n\nCTMRG algorithm where the expansions and renormalization is performed sequentially column-wise. This is implemented as a growing and projecting step to the left, followed by a clockwise rotation (performed four times).\n\nKeyword arguments\n\nFor a full description, see leading_boundary. The supported keywords are:\n\ntol::Real=1.0e-8\nmaxiter::Int=100\nminiter::Int=4\nverbosity::Int=2\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace)\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}\nprojector_alg::Symbol=:halfinfinite\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimpleUpdate","page":"Library","title":"PEPSKit.SimpleUpdate","text":"struct SimpleUpdate\n\nAlgorithm struct for simple update (SU) of infinite PEPS with bond weights. Each SU run is converged when the singular value difference becomes smaller than tol.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimultaneousCTMRG","page":"Library","title":"PEPSKit.SimultaneousCTMRG","text":"struct SimultaneousCTMRG <: CTMRGAlgorithm\nSimultaneousCTMRG(; kwargs...)\n\nCTMRG algorithm where all sides are grown and renormalized at the same time. In particular, the projectors are applied to the corners from two sides simultaneously.\n\nKeyword arguments\n\nFor a full description, see leading_boundary. The supported keywords are:\n\ntol::Real=1.0e-8\nmaxiter::Int=100\nminiter::Int=4\nverbosity::Int=2\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace)\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}\nprojector_alg::Symbol=:halfinfinite\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.EnlargedCorner, Int64}","page":"Library","title":"TensorKit.TensorMap","text":"TensorKit.TensorMap(Q::EnlargedCorner, dir::Int)\n\nInstantiate enlarged corner as TensorMap where dir selects the correct contraction direction, i.e. the way the environment and PEPS tensors connect.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.FullInfiniteEnv}","page":"Library","title":"TensorKit.TensorMap","text":"TensorKit.TensorMap(env::FullInfiniteEnv)\n\nInstantiate full-infinite environment as TensorMap explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.HalfInfiniteEnv}","page":"Library","title":"TensorKit.TensorMap","text":"TensorKit.TensorMap(env::HalfInfiniteEnv)\n\nInstantiate half-infinite environment as TensorMap explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.correlation_length-Tuple{Any, CTMRGEnv}","page":"Library","title":"MPSKit.correlation_length","text":"correlation_length(state, env::CTMRGEnv; num_vals=2, kwargs...)\n\nCompute the correlation length associated to state as contracted using the environment env, based on the spectrum of the horizontal and vertical transfer matrices associated to env. Additionally the (normalized) eigenvalue spectrum is returned. The number of computed eigenvalues can be specified using num_vals, and any remaining keyword arguments are passed through to MPSKit.transfer_spectrum (e.g. allowing to target the correlation length in a specific symmetry sector).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{Any, Any}","page":"Library","title":"MPSKit.expectation_value","text":"MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})\nMPSKit.expectation_value(st::MultilineMPS, op::Union{MultilineTransferPEPS,MultilineTransferPEPO})\n\nCompute expectation value of the transfer operator op for the state st for each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{InfinitePEPS, LocalOperator, CTMRGEnv}","page":"Library","title":"MPSKit.expectation_value","text":"expectation_value(peps::InfinitePEPS, O::LocalOperator, env::CTMRGEnv)\n\nCompute the expectation value ⟨peps|O|peps⟩ / ⟨peps|peps⟩ of a LocalOperator O for a PEPS peps using a given CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Union{Tuple{S}, Tuple{T}, Tuple{InfinitePartitionFunction, Pair{CartesianIndex{2}, <:TensorKit.AbstractTensorMap{T, S, 2, 2}}, CTMRGEnv}} where {T, S}","page":"Library","title":"MPSKit.expectation_value","text":"expectation_value(pf::InfinitePartitionFunction, inds => O, env::CTMRGEnv)\n\nCompute the expectation value corresponding to inserting a local tensor(s) O at position inds in the partition function pf and contracting the chole using a given CTMRG environment env.\n\nHere inds can be specified as either a Tuple{Int,Int} or a CartesianIndex{2}, and O should be a rank-4 tensor conforming to the PartitionFunctionTensor indexing convention.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, Any, Any}","page":"Library","title":"MPSKit.leading_boundary","text":"leading_boundary(\n    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [env]\n)\nleading_boundary(\n    st::MPSMulitline, op::Union{MultilineTransferPEPS,MultilineTransferPEPO}, alg, [env]\n)\n\nApproximate the leading boundary MPS eigenvector for the transfer operator op using st as initial guess.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{CTMRGEnv, InfiniteSquareNetwork}","page":"Library","title":"MPSKit.leading_boundary","text":"leading_boundary(env₀, network; kwargs...)\n# expert version:\nleading_boundary(env₀, network, alg::CTMRGAlgorithm)\n\nContract network using CTMRG and return the CTM environment. The algorithm can be supplied via the keyword arguments or directly as an CTMRGAlgorithm struct.\n\nKeyword arguments\n\nCTMRG iterations\n\ntol::Real=1.0e-8 : Stopping criterium for the CTMRG iterations. This is the norm convergence, as well as the distance in singular values of the corners and edges.\nminiter::Int=4 : Minimal number of CTMRG iterations.\nmaxiter::Int=100 : Maximal number of CTMRG iterations.\nverbosity::Int=2 : Output verbosity level, should be one of the following:\nSuppress all output\nOnly print warnings\nInitialization and convergence info\nIteration info\nDebug info\nalg::Symbol=:simultaneous : Variant of the CTMRG algorithm. See also CTMRGAlgorithm.\n:simultaneous: Simultaneous expansion and renormalization of all sides.\n:sequential: Sequential application of left moves and rotations.\n\nProjector algorithm\n\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nsvd_alg::Union{<:SVDAdjoint,NamedTuple} : SVD algorithm for computing projectors. See also SVDAdjoint. By default, a reverse-rule tolerance of tol=1e1tol where the krylovdim is adapted to the env₀ environment dimension.\nprojector_alg::Symbol=:halfinfinite : Variant of the projector algorithm. See also ProjectorAlgorithm.\nhalfinfinite: Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.\nfullinfinite: Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._apply_gate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S}, TensorKit.AbstractTensorMap{T, S}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.TruncationScheme}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._apply_gate","text":"Apply 2-site gate on the reduced matrices a, b\n\n    -1← a -← 3 -← b ← -4\n        ↓           ↓\n        1           2\n        ↓           ↓\n        |----gate---|\n        ↓           ↓\n        -2         -3\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._combine_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._combine_ab","text":"Contract the axis between a and b tensors\n\n    -- DX - a - D - b - DY --\n            ↓       ↓\n            da      db\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_corners-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_corners","text":"_contract_corners(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract all corners around the south-east at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_horizontal_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv{<:Any, <:TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}}}","page":"Library","title":"PEPSKit._contract_horizontal_edges","text":"_contract_horizontal_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract the horizontal edges and corners around the south edge at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_site-Tuple{Tuple{Int64, Int64}, InfiniteSquareNetwork{<:Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_site","text":"_contract_site(ind::Tuple{Int,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv)\n\nContract around a single site ind of a square network using a given CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_vertical_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv{<:Any, <:TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}}}","page":"Library","title":"PEPSKit._contract_vertical_edges","text":"_contract_vertical_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract the vertical edges and corners around the east edge at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._dag-Union{Tuple{TensorKit.AbstractTensorMap{T, S, N, 1} where T}, Tuple{N}, Tuple{S}} where {S, N}","page":"Library","title":"PEPSKit._dag","text":"Adjoint of an MPS tensor, but permutes the physical spaces back into the codomain. Intuitively, this conjugates a tensor and then reinterprets its 'direction' as an MPS tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._linearmap_twist!-Tuple{TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit._linearmap_twist!","text":"Apply a twist to domain or codomain indices that correspond to dual spaces\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._mirror_antidiag_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._mirror_antidiag_site","text":"_mirror_antidiag_site(\n    site::S, (Nrow, Ncol)::NTuple{2,Int}\n) where {S<:Union{CartesianIndex{2},NTuple{2,Int}}}\n\nGet the position of site after reflection about the anti-diagonal line.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._qr_bond-Tuple{TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._qr_bond","text":"Use QR decomposition on two tensors connected by a bond to get the reduced tensors\n\n        2                   1\n        |                   |\n    5 - A ← 3   ====>   4 - X ← 2   1 ← a ← 3\n        | ↘                 |            ↘\n        4   1               3             2\n\n        2                               1\n        |                               |\n    5 ← B - 3   ====>   1 ← b → 3   4 → Y - 2\n        | ↘                  ↘          |\n        4   1                 2         3\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._qr_bond_undo-Tuple{TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit._qr_bond_undo","text":"Reconstruct the tensors connected by a bond from their QR results obtained from _qr_bond\n\n        -2                             -2\n        |                               |\n    -5- X - 1 - a - -3     -5 - b - 1 - Y - -3\n        |        ↘               ↘      |\n        -4        -1              -1   -4\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rot180_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._rot180_site","text":"_rot180_site(\n    site::S, (Nrow, Ncol)::NTuple{2,Int}\n) where {S<:Union{CartesianIndex{2},NTuple{2,Int}}}\n\nGet the position of site after rotation by 180 degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rotl90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._rotl90_site","text":"_rotl90_site(\n    site::S, (Nrow, Ncol)::NTuple{2,Int}\n) where {S<:Union{CartesianIndex{2},NTuple{2,Int}}}\n\nGet the position of site after counter-clockwise (left) rotation by 90 degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rotr90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._rotr90_site","text":"_rotr90_site(\n    site::S, (Nrow, Ncol)::NTuple{2,Int}\n) where {S<:Union{CartesianIndex{2},NTuple{2,Int}}}\n\nGet the position of site after clockwise (right) rotation by 90 degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}","page":"Library","title":"PEPSKit._rrule","text":"_rrule(alg_rrule, config, f, args...; kwargs...) -> ∂f, ∂args...\n\nCustomize the pullback of a function f. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nwarning: Warning\nNo tangent is expected for the alg_rrule argument\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._solve_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._solve_ab","text":"Solve the equations Rx x = Sx (x = a, b) with initial guess x0\n\n    ┌---------------------------┐\n    |   ┌----┐                  |\n    └---|    |--- 1 -- x -- 2 --┘\n        |    |         ↓\n        | Rx |        -3\n        |    |\n    ┌---|    |--- -1       -2 --┐\n    |   └----┘                  |\n    └---------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._su_bondx!-Union{Tuple{S}, Tuple{T}, Tuple{Int64, Int64, TensorKit.AbstractTensorMap{T, S, 2, 2}, InfiniteWeightPEPS, SimpleUpdate}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._su_bondx!","text":"subondx!(row::Int, col::Int, gate::AbstractTensorMap{T,S,2,2},            peps::InfiniteWeightPEPS, alg::SimpleUpdate) where {S<:ElementarySpace}\n\nSimple update of the x-bond peps.weights[1,r,c].\n\n                [2,r,c]             [2,r,c+1]\n                ↓                   ↓\n    [1,r,c-1] ← T[r,c] ← [1,r,c] ←- T[r,c+1] ← [1,r,c+1]\n                ↓                   ↓\n                [2,r+1,c]           [2,r+1,c+1]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Ra-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Ra","text":"Construct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0     Db0 - b -- DY0 -┘\n        |    |                ↓\n        |benv|                db\n        |    |                ↓\n    ┌---|    |- DX1     Db1 - b† - DY1 -┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Rb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Rb","text":"Construct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 - a -- Da0     DY0 -┘\n        |    |        ↓\n        |benv|        da\n        |    |        ↓\n    ┌---|    |- DX1 - a† - Da1     DY1 -┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Sa-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Sa","text":"Construct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 -- (a2 b2) -- DY0 --┘\n        |    |         ↓     ↓\n        |benv|         da    db\n        |    |               ↓\n    ┌---|    |- DX1   Db1 -- b† - DY1 --┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Sb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Sb","text":"Construct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 -- (a2 b2) -- DY0 --┘\n        |    |         ↓     ↓\n        |benv|         da    db\n        |    |         ↓\n    ┌---|    |- DX1 -- a† - Da1   DY1 --┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_s-Tuple{TensorKit.AbstractTensorMap, TensorKit.DiagonalTensorMap, TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit.absorb_s","text":"absorb_s(u::AbstractTensorMap, s::DiagonalTensorMap, vh::AbstractTensorMap)\n\nGiven tsvd result u, s and vh, absorb singular values s into u and vh by:\n\n    u -> u * sqrt(s), vh -> sqrt(s) * vh\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_weight-Tuple{TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace, Int64, Int64, Int64, SUWeight}","page":"Library","title":"PEPSKit.absorb_weight","text":"absorb_weight(t::PEPSTensor, row::Int, col::Int, ax::Int, weights::SUWeight;\n              sqrtwt::Bool=false, invwt::Bool=false)\n\nAbsorb or remove environment weight on an axis of vertex tensor t  known to be located at position (row, col) in the unit cell.  Weights around the tensor at (row, col) are\n\n                    ↓\n                [2,r,c]\n                    ↓\n    ← [1,r,c-1] ← T[r,c] ← [1,r,c] ←\n                    ↓\n                [1,r+1,c]\n                    ↓\n\nArguments\n\nt::T: The vertex tensor to which the weight will be absorbed. The first axis of t should be the physical axis. \nrow::Int: The row index specifying the position in the tensor network.\ncol::Int: The column index specifying the position in the tensor network.\nax::Int: The axis into which the weight is absorbed, taking values from 1 to 4, standing for north, east, south, west respectively.\nweights::SUWeight: The weight object to absorb into the tensor.\nsqrtwt::Bool=false (optional): If true, the square root of the weight is absorbed.\ninvwt::Bool=false (optional): If true, the inverse of the weight is absorbed.\n\nDetails\n\nThe optional kwargs sqrtwt and invwt allow taking the square root or the inverse of the weight before absorption. \n\nExamples\n\n# Absorb the weight into the north axis of tensor at position (2, 3)\nabsorb_weight(t, 2, 3, 1, weights)\n\n# Absorb the square root of the weight into the south axis\nabsorb_weight(t, 2, 3, 3, weights; sqrtwt=true)\n\n# Absorb the inverse of (i.e. remove) the weight into the east axis\nabsorb_weight(t, 2, 3, 2, weights; invwt=true)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.bond_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, ALSTruncation}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.bond_truncate","text":"bond_truncate(a::AbstractTensorMap{T,S,2,1}, b::AbstractTensorMap{T,S,1,2}, benv::BondEnv{T,S}, alg) where {T<:Number,S<:ElementarySpace}\n\nAfter time-evolving the reduced tensors a and b connected by a bond,  truncate the bond dimension using the bond environment tensor benv.\n\n    ┌-----------------------┐\n    |   ┌----┐              |\n    └---|    |-- a === b ---┘\n        |benv|   ↓     ↓\n    ┌---|    |-- a† == b† --┐\n    |   └----┘              |\n    └-----------------------┘\n\nThe truncation algorithm alg can be either FullEnvTruncation or ALSTruncation.  The index order of a or b is\n\n    1 -a/b- 3\n        ↓       a[1 2; 3]\n        2       b[1; 2 3]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_convergence-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.calc_convergence","text":"calc_convergence(env, CS_old, TS_old)\ncalc_convergence(env_new::CTMRGEnv, env_old::CTMRGEnv)\n\nGiven a new environment env, compute the maximal singular value distance. This determined either from the previous corner and edge singular values CS_old and TS_old, or alternatively, directly from the old environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}","page":"Library","title":"PEPSKit.calc_elementwise_convergence","text":"calc_elementwise_convergence(envfinal, envfix; atol=1e-6)\n\nCheck if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below some tolerance.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.checklattice-Tuple","page":"Library","title":"PEPSKit.checklattice","text":"checklattice(Bool, args...)\nchecklattice(args...)\n\nHelper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.compute_projector-Tuple{Any, Any, HalfInfiniteProjector}","page":"Library","title":"PEPSKit.compute_projector","text":"compute_projector(enlarged_corners, coordinate, alg::ProjectorAlgorithm)\n\nDetermine left and right projectors at the bond given determined by the enlarged corners and the given coordinate using the specified alg.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_norm-Union{Tuple{N}, Tuple{NTuple{N, CartesianIndex{2}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N","page":"Library","title":"PEPSKit.contract_local_norm","text":"contract_local_norm(inds, peps, env)\n\nContract a local norm of the PEPS peps around indices inds.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_operator-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{T, S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {T, S, N}","page":"Library","title":"PEPSKit.contract_local_operator","text":"contract_local_operator(inds, O, peps, env)\n\nContract a local operator O on the PEPS peps at the indices inds using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_tensor-Union{Tuple{C}, Tuple{S}, Tuple{T}, Tuple{Tuple{Int64, Int64}, TensorKit.AbstractTensorMap{T, S, 2, 2}, CTMRGEnv{C, <:TensorKit.AbstractTensorMap{T, S, 2, 1} where {T, S}}}} where {T, S, C}","page":"Library","title":"PEPSKit.contract_local_tensor","text":"contract_local_tensor(inds, O, env)\n\nContract a local tensor O inserted into a partition function pf at position inds, using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_projectors-NTuple{5, Any}","page":"Library","title":"PEPSKit.contract_projectors","text":"contract_projectors(U, S, V, Q, Q_next)\n\nCompute projectors based on a SVD of Q * Q_next, where the inverse square root isqS of the singular values is computed.\n\nLeft projector:\n\n    -- |~~~~~~| -- |~~|\n       |Q_next|    |V'| -- isqS --\n    == |~~~~~~| == |~~|\n\nRight projector:\n\n               |~~| -- |~~~| --\n    -- isqS -- |U'|    | Q |\n               |~~| == |~~~| ==\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.cost_function-Tuple{InfinitePEPS, CTMRGEnv, LocalOperator}","page":"Library","title":"PEPSKit.cost_function","text":"cost_function(peps::InfinitePEPS, env::CTMRGEnv, O::LocalOperator)\n\nReal part of expectation value of O. Prints a warning if the expectation value yields a finite imaginary part (up to a tolerance).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.cost_function_als-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.cost_function_als","text":"Calculate the cost function\n\n    f(a,b)  = ‖ |a1,b1⟩ - |a2,b2⟩ ‖^2\n    = ⟨a1,b1|a1,b1⟩ - 2 Re⟨a1,b1|a2,b2⟩ + ⟨a2,b2|a2,b2⟩\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_iteration-Tuple{Any, Any, PEPSKit.CTMRGAlgorithm}","page":"Library","title":"PEPSKit.ctmrg_iteration","text":"ctmrg_iteration(network, env, alg::CTMRGAlgorithm) -> env′, info\n\nPerform a single CTMRG iteration in which all directions are being grown and renormalized.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_leftmove-Tuple{Int64, Any, CTMRGEnv, SequentialCTMRG}","page":"Library","title":"PEPSKit.ctmrg_leftmove","text":"ctmrg_leftmove(col::Int, network, env::CTMRGEnv, alg::SequentialCTMRG)\n\nPerform sequential CTMRG left move on the col-th column.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.dtmap-Tuple","page":"Library","title":"PEPSKit.dtmap","text":"dtmap(args...; kwargs...)\n\nDifferentiable wrapper around OhMyThreads.tmap.\n\nAll calls of dtmap inside of PEPSKit use the threading scheduler stored inside Defaults.scheduler which can be modified using set_scheduler!.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.eachcoordinate","page":"Library","title":"PEPSKit.eachcoordinate","text":"eachcoordinate(x, dirs=1:4)\n\nEnumerate all (dir, row, col) pairs.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_northeast_corner-Tuple{Any, CTMRGEnv, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.enlarge_northeast_corner","text":"enlarge_northeast_corner((row, col), env, network::InfiniteSquareNetwork{O})\nenlarge_northeast_corner(E_north, C_northeast, E_east, A::O)\n\nContract the enlarged northeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n    -- E_north -- C_northeast\n          |             |\n    --    A    --    E_east\n          |             |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_northwest_corner-Tuple{Any, CTMRGEnv, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.enlarge_northwest_corner","text":"enlarge_northwest_corner((row, col), env, network::InfiniteSquareNetwork{O})\nenlarge_northwest_corner(E_west, C_northwest, E_north, A::O)\n\nContract the enlarged northwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n    C_northwest -- E_north --\n         |            |\n      E_west    --    A    --\n         |            |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_southeast_corner-Tuple{Any, CTMRGEnv, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.enlarge_southeast_corner","text":"enlarge_southeast_corner((row, col), env, network::InfiniteSquareNetwork{O})\nenlarge_southeast_corner(E_east, C_southeast, E_south, A::O)\n\nContract the enlarged southeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n          |             |\n    --    A    --    E_east\n          |             |\n    -- E_south -- C_southeast\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_southwest_corner-Tuple{Any, CTMRGEnv, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.enlarge_southwest_corner","text":"enlarge_southwest_corner((row, col), env, network::InfiniteSquareNetwork{O})\nenlarge_southwest_corner(E_south, C_southwest, E_west, A::O)\n\nContract the enlarged southwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n          |           |       \n       E_west   --    A    --\n          |           |       \n    C_southwest -- E_south -- \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fidelity","text":"Given the bond environment benv, calculate the fidelity between two states specified by the bond matrices b1, b2\n\n    F(b1, b2) = (⟨b1|b2⟩ ⟨b2|b1⟩) / (⟨b1|b1⟩ ⟨b2|b2⟩)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fidelity","text":"Calculate the fidelity between two evolution steps\n\n        |⟨a1,b1|a2,b2⟩|^2\n    --------------------------\n    ⟨a1,b1|a1,b1⟩⟨a2,b2|a2,b2⟩\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}","page":"Library","title":"PEPSKit.fix_gauge_corner","text":"fix_gauge_corner(corner, σ_in, σ_out)\n\nMultiply corner tensor with incoming and outgoing gauge signs.\n\n    corner -- σ_out --\n      |  \n     σ_in\n      |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_edge","text":"fix_gauge_east_edge((row, col), env, signs)\n\nApply fix_gauge_edge to the east edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_left_vecs","text":"fix_gauge_east_left_vecs((row, col), U, signs)\n\nMultiply east left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_right_vecs","text":"fix_gauge_east_right_vecs((row, col), V, signs)\n\nMultiply east right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_edge-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}","page":"Library","title":"PEPSKit.fix_gauge_edge","text":"fix_gauge_edge(edge, σ_in, σ_out)\n\nMultiply edge tensor with incoming and outgoing gauge signs.\n\n    -- σ_in -- edge -- σ_out --\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_edge","text":"fix_gauge_north_edge((row, col), env, signs)\n\nApply fix_gauge_edge to the north edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_left_vecs","text":"fix_gauge_north_left_vecs((row, col), U, signs)\n\nMultiply north left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_right_vecs","text":"fix_gauge_north_right_vecs((row, col), V, signs)\n\nMultiply north right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northeast_corner","text":"fix_gauge_northeast_corner((row, col), env, signs)\n\nApply fix_gauge_corner to the northeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northwest_corner","text":"fix_gauge_northwest_corner((row, col), env, signs)\n\nApply fix_gauge_corner to the northwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_edge","text":"fix_gauge_south_edge((row, col), env, signs)\n\nApply fix_gauge_edge to the south edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_left_vecs","text":"fix_gauge_south_left_vecs((row, col), U, signs)\n\nMultiply south left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_right_vecs","text":"fix_gauge_south_right_vecs((row, col), V, signs)\n\nMultiply south right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southeast_corner","text":"fix_gauge_southeast_corner((row, col), env, signs)\n\nApply fix_gauge_corner to the southeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southwest_corner","text":"fix_gauge_southwest_corner((row, col), env, signs)\n\nApply fix_gauge_corner to the southwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_edge","text":"fix_gauge_south_edge((row, col), env, signs)\n\nApply fix_gauge_edge to the west edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_left_vecs","text":"fix_gauge_west_left_vecs((row, col), U, signs)\n\nMultiply west left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_right_vecs","text":"fix_gauge_west((row, col), V, signs)\n\nMultiply west right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fixedpoint-Tuple{Any, InfinitePEPS, CTMRGEnv}","page":"Library","title":"PEPSKit.fixedpoint","text":"fixedpoint(operator, peps₀::InfinitePEPS, env₀::CTMRGEnv; kwargs...)\n# expert version:\nfixedpoint(operator, peps₀::InfinitePEPS, env₀::CTMRGEnv, alg::PEPSOptimize;\n           finalize!=OptimKit._finalize!)\n\nFind the fixed point of operator (i.e. the ground state) starting from peps₀ according to the supplied optimization parameters. The initial environment env₀ serves as an initial guess for the first CTMRG run. By default, a random initial environment is used.\n\nThe optimization parameters can be supplied via the keyword arguments or directly as a PEPSOptimize struct. The following keyword arguments are supported:\n\nKeyword arguments\n\nGeneral settings\n\ntol::Real=0.0001 : Overall tolerance for gradient norm convergence of the optimizer. Sets related tolerance such as the boundary and boundary-gradient tolerances to sensible defaults unless they are explictly specified.\nverbosity::Int=1 : Overall output information verbosity level, should be one of the following:\nSuppress all output\nOptimizer output and warnings\nAdditionally print boundary information\nAll information including AD debug outputs\nreuse_env::Bool=true : If true, the current optimization step is initialized on the previous environment, otherwise a random environment is used.\nsymmetrization::Union{Nothing,SymmetrizationStyle}=nothing : Accepts nothing or a SymmetrizationStyle, in which case the PEPS and PEPS gradient are symmetrized after each optimization iteration.\n(finalize!)=OptimKit._finalize! : Inserts a finalize! function call after each optimization step by utilizing the finalize! kwarg of OptimKit.optimize. The function maps (peps, env), f, g = finalize!((peps, env), f, g, numiter).\n\nBoundary algorithm\n\nSupply boundary algorithm parameters via boundary_alg::Union{NamedTuple,<:CTMRGAlgorithm} using either a NamedTuple of keyword arguments or a CTMRGAlgorithm directly. See leading_boundary for a description of all possible keyword arguments. By default, a CTMRG tolerance of tol=1e-4tol and is used.\n\nGradient algorithm\n\nSupply gradient algorithm parameters via gradient_alg::Union{NamedTuple,Nothing,<:GradMode} using either a NamedTuple of keyword arguments, nothing, or a GradMode struct directly. Pass nothing to fully differentiate the CTMRG run, meaning that all iterations will be taken into account, instead of differentiating the fixed point. The supported NamedTuple keyword arguments are:\n\ntol::Real=1e-2tol : Convergence tolerance for the fixed-point gradient iteration.\nmaxiter::Int=30 : Maximal number of gradient problem iterations.\nalg::Symbol=:linsolver : Gradient algorithm variant, can be one of the following:\n:geomsum : Compute gradient directly from the geometric sum, see GeomSum\n:manualiter : Iterate gradient geometric sum manually, see 'ManualIter'\n:linsolver : Solve fixed-point gradient linear problem using iterative solver, see 'LinSolver'\n:eigsolver : Determine gradient via eigenvalue formulation of its Sylvester equation, see EigSolver\nverbosity::Int : Gradient output verbosity, ≤0 by default to disable too verbose printing. Should only be >0 for debug purposes.\niterscheme::Symbol=:fixed : CTMRG iteration scheme determining mode of differentiation. This can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\nOptimizer settings\n\nSupply the optimizer algorithm via optimizer_alg::Union{NamedTuple,<:OptimKit.OptimizationAlgorithm} using either a NamedTuple of keyword arguments or a OptimKit.OptimizationAlgorithm directly. By default, OptimKit.LBFGS is used in combination with a HagerZhangLineSearch. The supported keyword arguments are:\n\nalg::Symbol=:lbfgs : Optimizer algorithm, can be one of the following:\n:gradientdescent : Gradient descent algorithm, see the OptimKit README\n:conjugategradient : Conjugate gradient algorithm, see the OptimKit README\n:lbfgs : L-BFGS algorithm, see the OptimKit README\ntol::Real=tol : Gradient norm tolerance of the optimizer.\nmaxiter::Int=100 : Maximal number of optimization steps.\nverbosity::Int=3 : Optimizer output verbosity.\nlbfgs_memory::Int=20 : Size of limited memory representation of BFGS Hessian matrix.\n\nReturn values\n\nThe function returns the final PEPS, CTMRG environment and cost value, as well as an information NamedTuple which contains the following entries:\n\nlast_gradient : Last gradient of the cost function.\nfg_evaluations : Number of evaluations of the cost and gradient function.\ncosts : History of cost values.\ngradnorms : History of gradient norms.\ntruncation_errors : History of maximal truncation errors of the boundary algorithm.\ncondition_numbers : History of maximal condition numbers of the CTMRG environments.\ngradnorms_unitcell : History of gradient norms for each respective unit cell entry.\ntimes : History of optimization step execution times.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fpgrad","page":"Library","title":"PEPSKit.fpgrad","text":"fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)\n\nCompute the gradient of the cost function for CTMRG by solving the following equation:\n\ndx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA\n\nwhere ∂F∂x is the gradient of the cost function with respect to the PEPS tensors, ∂f∂x is the partial gradient of the CTMRG iteration with respect to the environment tensors, ∂f∂A is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and y0 is the initial guess for the fixed-point iteration. The function returns the gradient dx of the fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.full_infinite_environment-Union{Tuple{T}, NTuple{4, T}} where T<:(TensorKit.AbstractTensorMap{<:Number, <:TensorKit.ElementarySpace, 3, 3})","page":"Library","title":"PEPSKit.full_infinite_environment","text":"full_infinite_environment(\n    quadrant1::T, quadrant2::T, quadrant3::T, quadrant4::T\n) where {T<:AbstractTensorMap{<:Number,<:ElementarySpace,N,N}}\nfunction full_infinite_environment(\n    half1::T, half2::T\n) where {T<:AbstractTensorMap{<:Number,<:ElementarySpace,N,N}}\nfull_infinite_environment(C_1, C_2, C_3, C_4, E_1, E_2, E_3, E_4, E_5, E_6, E_7, E_8,\n                          A_1::P, A_2::P, A_3::P, A_4::P)\nfull_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x,\n                          A_1::P, A_2::P, A_3::P, A_4::P)\nfull_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4,\n                          A_1::P, A_2::P, A_3::P, A_4::P)\n\nContract four quadrants (enlarged corners) to form a full-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n      |     |        |     |\n                     |     |\n      |     |        |     |\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant4|    |quadrant3|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n\nIn the same manner two halfs can be used to contract the full-infinite environment.\n\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n    |         half1          |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n      |     |        |     |\n                     |     |\n      |     |        |     |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n    |         half2          |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n\nThe environment can also be contracted directly from all its constituent tensors.\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      | \n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n                   |      |\n     |      |      |      |\n    E_8 -- A_4 -- A_3 -- E_5\n     |      |      |      |\n    C_4 -- E_7 -- E_6 -- C_3\n\nAlternatively, contract the environment with a vector x acting on it\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      | \n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n                   |      |\n    [~~~~x~~~]     |      |\n     |      |      |      |\n    E_8 -- A_4 -- A_3 -- E_5\n     |      |      |      |\n    C_4 -- E_7 -- E_6 -- C_3\n\n\nor contract the adjoint environment with x, e.g. as needed for iterative solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fullenv_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}, FullEnvTruncation}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fullenv_truncate","text":"fullenv_truncate(benv::BondEnv{T,S}, b0::AbstractTensorMap{T,S,1,1}, alg::FullEnvTruncation) where {T<:Number,S<:ElementarySpace}\n\nThe full environment truncation algorithm (Physical Review B 98, 085155 (2018)). \n\nGiven a fixed state |b0⟩ with bond matrix b0 and the corresponding positive-definite bond environment benv,  find the state |b⟩ with truncated bond matrix b = u s v† that maximizes the fidelity (not normalized by ⟨b0|b0⟩)\n\n    F(b) = ⟨b|b0⟩⟨b0|b⟩ / ⟨b|b⟩\n\n            ┌----------------------┐  ┌-----------------------┐\n            |   ┌----┐             |  |   ┌----┐              |\n            └---|    |---- b0 -----┘  └---|    |- u ← s ← v† -┘\n                |benv|                    |benv|\n            ┌---|    |-u† → s → v -┐  ┌---|    |----- b0† ----┐\n            |   └----┘             |  |   └----┘              |\n            └----------------------┘  └-----------------------┘\n        = ───────────────────────────────────────────────────────\n                        ┌-----------------------┐\n                        |   ┌----┐              |\n                        └---|    |- u ← s ← v† -┘\n                            |benv|\n                        ┌---|    |- u† → s → v -┐\n                        |   └----┘              |\n                        └-----------------------┘\n\nThe singular value spectrum s is truncated to desired dimension,  and normalized such that the maximum is 1. Note that benv is contracted to b0 using @tensor,  instead of acting on b0 as a linear map.\n\nThe algorithm iteratively optimizes the vectors l, r\n\n    --- l -←-  =  --- u ← s -←-  ,  -←- r ---  =  -←- s ← v† ---\n\nOptimization of r\n\nDefine the vector p and the positive map B as\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-←   --┘   └---|    |- u ←      ---┘\n            | p†|         =     |benv|\n        ┌---|   |-------┐   ┌---|    |----- b0† ----┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-←   --┘   └---|    |- u ←      ---┘\n            | B |         =     |benv|\n        ┌---|   |-→   --┐   ┌---|    |- u†→      ---┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\nThen (each index corresponds to a pair of fused indices)\n\n    F(r,r†) = |p† r|² / (r† B r)\n            = (r† p) (p† r) / (r† B r)\n\nwhich is maximized when\n\n    ∂F/∂r̄ * (r† B r)²\n    = p (p† r) (r† B r) - |p† r|² (B r) = 0\n\nNote that B is positive (consequently B† = B).  Then the solution for the vector r is\n\n    r = B⁻¹ p\n\nWe can verify that (using B† = B)\n\n    ∂F/∂r̄ * (r† B r)²\n    = p (p† B⁻¹ p) (p† B⁻¹ B B⁻¹ p) - |p† B⁻¹ p|² (B B⁻¹ p) \n    = 0\n\nThen the bond matrix u s v† is updated by truncated SVD:\n\n    - u ← r -    ==>    - u ← s ← v† -\n\nOptimization of l\n\nThe process is entirely similar.  Define the vector p and the positive map B as\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-  ←-o-┘   └---|    |--   ←-o- v† -┘\n            | p†|         =     |benv|\n        ┌---|   |-------┐   ┌---|    |----- b0† ----┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-  ←-o-┘   └---|    |--    ←-o- v†-┘\n            | B |         =     |benv|\n        ┌---|   |-  →-o-┐   ┌---|    |--    →-o- v -┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\nHere o is the parity tensor (twist) necessary for fermions.  Then (each index corresponds to a pair of fused indices)\n\n    F(l,l†) = |p† l|² / (l† B l)\n\nwhich is maximized when\n\n    l = B⁻¹ p\n\nThen the bond matrix u s v† is updated by SVD:\n\n    - l ← v† -   ==>    - u ← s ← v† -\n\nReturns\n\nThe SVD result of the new bond matrix u, s, vh.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(envprev::CTMRGEnv{C,T}, envfinal::CTMRGEnv{C,T}) where {C,T}\n\nFix the gauge of envfinal based on the previous environment envprev. This assumes that the envfinal is the result of one CTMRG iteration on envprev. Given that the CTMRG run is converged, the returned environment will be element-wise converged to envprev.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_gate-Tuple{Float64, LocalOperator}","page":"Library","title":"PEPSKit.get_gate","text":"get_gate(dt::Float64, H::LocalOperator)\n\nCompute exp(-dt * H) from the nearest neighbor Hamiltonian H.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_gateterm-Tuple{LocalOperator, Tuple{CartesianIndex{2}, CartesianIndex{2}}}","page":"Library","title":"PEPSKit.get_gateterm","text":"get_gateterm(gate::LocalOperator, bond::NTuple{2,CartesianIndex{2}})\n\nGet the term of a 2-site gate acting on a certain bond. Input gate should only include one term for each nearest neighbor bond.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.half_infinite_environment-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, TensorKit.AbstractTensorMap{T, S, 3, 3}}} where {T, S}","page":"Library","title":"PEPSKit.half_infinite_environment","text":"half_infinite_environment(quadrant1::AbstractTensorMap{T,S,3,3}, quadrant2::AbstractTensorMap{T,S,N,N})\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4,  A_1::P, A_2::P)\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x, A_1::P, A_2::P)\nhalf_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4, A_1::P, A_2::P)\n\nContract two quadrants (enlarged corners) to form a half-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n      |     |        |     |\n\nThe environment can also be contracted directly from all its constituent tensors.\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      | \n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n\nAlternatively, contract the environment with a vector x acting on it\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      | \n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n                  [~~~x~~~~]\n\nor contract the adjoint environment with x, e.g. as needed for iterative solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}","page":"Library","title":"PEPSKit.hook_pullback","text":"hook_pullback(f, args...; alg_rrule=nothing, kwargs...)\n\nWrapper function to customize the pullback of a function f. This function is equivalent to f(args...; kwargs...), but the pullback can be customized by implementing the following function:\n\n_rrule(alg_rrule, config, f, args...; kwargs...) -> NoTangent(), ∂f, ∂args...\n\nThis function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nSee also _rrule.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.initializeMPS-Union{Tuple{S}, Tuple{MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), O<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}, AbstractVector{S}}} where S","page":"Library","title":"PEPSKit.initializeMPS","text":"initializeMPS(\n    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,1}\n)\ninitializeMPS(\n    O::Union{MultilineTransferPEPS,MultilineTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,2}\n)\n\nInialize a boundary MPS for the transfer operator O by specifying an array of virtual spaces consistent with the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.inner_prod","text":"Given the bond environment benv, calculate the inner product between two states specified by the bond matrices b1, b2\n\n            ┌--------------------┐\n            |   ┌----┐           |\n            └---|    |---- b2 ---┘\n    ⟨b1|b2⟩ =   |benv|\n            ┌---|    |---- b1†---┐\n            |   └----┘           |\n            └--------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.inner_prod","text":"Calculate the inner product <a1,b1|a2,b2>\n\n    ┌--------------------------------┐\n    |   ┌----┐                       |\n    └---|    |- DX0 - (a2 b2) - DY0 -┘\n        |    |        ↓    ↓\n        |benv|        da   db\n        |    |        ↓    ↓\n    ┌---|    |- DX1 - (a1 b1)†- DY1 -┐\n    |   └----┘                       |\n    └--------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.is_equivalent-Tuple{Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{Int64, Int64}}","page":"Library","title":"PEPSKit.is_equivalent","text":"is_equivalent(bond1::NTuple{2,CartesianIndex{2}}, bond2::NTuple{2,CartesianIndex{2}}, (Nrow, Ncol)::NTuple{2,Int})\n\nCheck if two 2-site bonds are related by a (periodic) lattice translation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.j1_j2-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.j1_j2","text":"j1_j2([elt::Type{T}], [symm::Type{S}], [lattice::InfiniteSquare];\n      J1=1.0, J2=1.0, spin=1//2, sublattice=true)\n\nSquare lattice J₁-J₂ model. The sublattice kwarg enables a single site unit cell via a sublattice rotation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.left_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.left_projector","text":"left_projector(E_1, C, E_2, V, isqS, A)\n\nContract the CTMRG left projector with the higher-dimensional subspace facing to the left.\n\n     C  --  E_2    -- |~~|\n     |       |        |V'| -- isqS --\n    E_1 --   A     -- |~~|\n     |       |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.mirror_antidiag-Tuple{AbstractMatrix}","page":"Library","title":"PEPSKit.mirror_antidiag","text":"mirror_antidiag(arr::AbstractMatrix)\n\nMirror a matrix by its anti-diagonal line (the 45 degree line through the lower-left corner).\n\nThe element originally at [r, c] is moved [Nc-c+1, Nr-r+1], i.e. the element now at [r, c] was originally at [Nr-c+1, Nc-r+1]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.mirror_antidiag-Tuple{InfiniteWeightPEPS}","page":"Library","title":"PEPSKit.mirror_antidiag","text":"mirror_antidiag(peps::InfiniteWeightPEPS)\n\nMirror the unit cell of an iPEPS with weights by its anti-diagonal line.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.mirror_antidiag-Tuple{LocalOperator}","page":"Library","title":"PEPSKit.mirror_antidiag","text":"mirror_antidiag(H::LocalOperator)\n\nMirror a LocalOperator across the anti-diagonal axis of its lattice.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.nearest_neighbour_hamiltonian-Union{Tuple{T}, Tuple{S}, Tuple{Matrix{S}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {S, T}","page":"Library","title":"PEPSKit.nearest_neighbour_hamiltonian","text":"nearest_neighbour_hamiltonian(\n    lattice::Matrix{S}, h::AbstractTensorMap{T,S,2,2}\n) where {S,T}\n\nCreate a nearest neighbor LocalOperator by specifying the 2-site interaction term h which acts both in horizontal and vertical direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.network_value-Tuple{InfiniteSquareNetwork, CTMRGEnv}","page":"Library","title":"PEPSKit.network_value","text":"network_value(network::InfiniteSquareNetwork, env::CTMRGEnv)\n\nReturn the value (per unit cell) of a given contractible network contracted using a given CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.product_peps-Tuple","page":"Library","title":"PEPSKit.product_peps","text":"product_peps(peps_args...; unitcell=(1, 1), noise_amp=1e-2, state_vector=nothing)\n\nInitialize a normalized random product PEPS with noise. The given arguments are passed on to the InfinitePEPS constructor.\n\nThe noise intensity can be tuned with noise_amp. The product state coefficients can be specified using the state_vector kwarg in the form of a matrix of size unitcell containing vectors that match the PEPS physical dimensions. If nothing is provided, random Gaussian coefficients are used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.pwave_superconductor-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.pwave_superconductor","text":"pwave_superconductor(::Type{T}=ComplexF64; t=1, μ=2, Δ=1, unitcell=(1, 1))\n\nSquare lattice p-wave superconductor model.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_bottom_corner-Union{Tuple{C}, Tuple{Any, CTMRGEnv{C, <:TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}}, Any}} where C","page":"Library","title":"PEPSKit.renormalize_bottom_corner","text":"renormalize_bottom_corner((r, c), env, projectors)\n\nApply bottom projector to southwest corner and south edge.\n\n        | \n    [P_bottom]\n     |     |\n     C --  E -- in\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_corner-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, Any, Any}} where {T, S}","page":"Library","title":"PEPSKit.renormalize_corner","text":"renormalize_corner(quadrant::AbstractTensorMap{T,S,3,3}, P_left, P_right)\nrenormalize_corner(quadrant::AbstractTensorMap{T,S,2,2}, P_left, P_right)\n\nApply projectors to each side of a quadrant.\n\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --\n    |~~~~~~~~| -- |~~~~~~|\n     |     |\n    [P_right]\n        |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_east_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_east_edge","text":"renormalize_east_edge((row, col), env, P_top, P_bottom, network::InfiniteSquareNetwork{P})\nrenormalize_east_edge(E_east, P_top, P_bottom, A::P)\n\nAbsorb a blocal effective tensor into the east edge using the given projectors and environment tensors.\n\n           |\n     [~P_bottom~]\n      |        |\n    E_east --  A -- \n      |        |\n     [~~P_top~~~]\n           |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_north_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_north_edge","text":"renormalize_north_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_north_edge(E_north, P_left, P_right, A::P)\n\nAbsorb a local effective tensor A into the north edge using the given projectors and environment tensors.\n\n       |~~~~~~| -- E_north -- |~~~~~~~| \n    -- |P_left|       |       |P_right| --\n       |~~~~~~| --    A    -- |~~~~~~~| \n                      |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northeast_corner","text":"renormalize_northeast_corner((row, col), enlarged_env::CTMRGEnv, P_left, P_right)\nrenormalize_northwest_corner(quadrant::AbstractTensorMap{T,S,N,N}, P_left, P_right) where {T,S,N}\nrenormalize_northeast_corner(E_north, C_northeast, E_east, P_left, P_right, A::O)\n\nApply renormalize_corner to the enlarged northeast corner. Alternatively, provide the constituent tensors and perform the complete contraction.\n\n       |~~~~~~~| -- E_north -- C_northeast\n    -- |P_right|       |            |  \n       |~~~~~~~| --    A    --    E_east\n                       |            |\n                     [~~~~~P_left~~~~~]\n                              |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northwest_corner","text":"renormalize_northwest_corner((row, col), enlarged_env::CTMRGEnv, P_left, P_right)\nrenormalize_northwest_corner(quadrant::AbstractTensorMap{T,S,N,N}, P_left, P_right) where {T,S,N}\nrenormalize_northwest_corner(E_west, C_northwest, E_north, P_left, P_right, A::O)\n\nApply renormalize_corner to the enlarged northwest corner. Alternatively, provide the constituent tensors and perform the complete contraction.\n\n    C_northwest -- E_north -- |~~~~~~|\n         |           |        |P_left| --\n      E_west    --   A     -- |~~~~~~|\n         |           |\n      [~~~~~P_right~~~~]\n               |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_sequentially-Tuple{Int64, Any, Any, Any}","page":"Library","title":"PEPSKit.renormalize_sequentially","text":"renormalize_sequentially(col::Int, projectors, network, env)\n\nRenormalize one column of the CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_simultaneously-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_simultaneously","text":"renormalize_simultaneously(enlarged_corners, projectors, network, env)\n\nRenormalize all enlarged corners and edges simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_south_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_south_edge","text":"renormalize_south_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_south_edge(E_south, P_left, P_right, A::P)\n\nAbsorb a local effective tensor into the south edge using the given projectors and environment tensors.\n\n                       |\n       |~~~~~~~| --    A    -- |~~~~~~| \n    -- |P_right|       |       |P_left| --\n       |~~~~~~~| -- E_south -- |~~~~~~| \n                       |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southeast_corner","text":"renormalize_southeast_corner((row, col), enlarged_env::CTMRGEnv, P_left, P_right)\nrenormalize_southeast_corner(quadrant::AbstractTensorMap{T,S,N,N}, P_left, P_right) where {T,S,N}\nrenormalize_southeast_corner(E_east, C_southeast, E_south, P_left, P_right, A::O)\n\nApply renormalize_corner to the enlarged southeast corner. Alternatively, provide the constituent tensors and perform the complete contraction.\n\n                            |\n                    [~~~~P_right~~~~]\n                      |           |\n       |~~~~~~| --    A    --   E_east\n    -- |P_left|       |           |\n       |~~~~~~| -- E_south -- C_southeast\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southwest_corner","text":"renormalize_southwest_corner((row, col), enlarged_env::CTMRGEnv, P_left, P_right)\nrenormalize_southwest_corner(quadrant::AbstractTensorMap{T,S,N,N}, P_left, P_right) where {T,S,N}\nrenormalize_southwest_corner(E_south, C_southwest, E_west, P_left, P_right, A::O)\n\nApply renormalize_corner to the enlarged southwest corner. Alternatively, provide the constituent tensors and perform the complete contraction.\n\n               |\n       [~~~~P_right~~~~~]\n         |            |\n       E_west   --    A    -- |~~~~~~|\n         |            |       |P_left| --\n    C_southwest -- E_south -- |~~~~~~|\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_top_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_top_corner","text":"renormalize_top_corner((row, col), env::CTMRGEnv, projectors)\n\nApply top projector to northwest corner and north edge.\n\n     C -- E -- \n     |    |\n    [~P_top~]\n        | \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_west_edge-Union{Tuple{Pb}, Tuple{Pt}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfiniteSquareNetwork}} where {Pt, Pb}","page":"Library","title":"PEPSKit.renormalize_west_edge","text":"renormalize_west_edge((row, col), env, P_top, P_bottom, network::InfiniteSquareNetwork{P})\nrenormalize_west_edge(E_west, P_top, P_bottom, A::P)\n\nAbsorb a local effective tensor into the west edge using the given projectors and environment tensors.\n\n           |\n     [~P_bottom~]\n      |        |\n   -- A  --  E_west\n      |        |\n     [~~P_top~~~]\n           |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.right_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.right_projector","text":"right_projector(E_1, C, E_2, U, isqS, A)\n\nContract the CTMRG right projector with the higher-dimensional subspace facing to the right.\n\n               |~~| --   E_2   --  C\n    -- isqS -- |U'|      |         |\n               |~~| --   A     -- E_1\n                         |         |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.rotate_north-Tuple{Any, Any}","page":"Library","title":"PEPSKit.rotate_north","text":"rotate_north(t, dir)\n\nRotate the dir direction of t to face north by successive applications of rotl90.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.sdiag_pow-Tuple{TensorKit.DiagonalTensorMap, Real}","page":"Library","title":"PEPSKit.sdiag_pow","text":"sdiag_pow(s, pow::Real; tol::Real=eps(scalartype(s))^(3 / 4))\n\nCompute s^pow for a diagonal matrix s.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.select_algorithm","page":"Library","title":"PEPSKit.select_algorithm","text":"select_algorithm(func_or_alg, args...; kwargs...) -> Algorithm\n\nParse arguments and keyword arguments to the algorithm struct corresponding to func_or_alg and return an algorithm instance. To that end, we use a general interface where all keyword arguments that can be algorithm themselves can be specified using\n\nalg::Algorithm : an instance of the algorithm struct or\n(; alg::Symbol, alg_kwargs...) : a NamedTuple where the algorithm is specified by a Symbol and the algorithm keyword arguments \n\nA full description of the keyword argument can be found in the respective function or algorithm struct docstrings.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.sequential_projectors-Tuple{Int64, Any, CTMRGEnv, PEPSKit.ProjectorAlgorithm}","page":"Library","title":"PEPSKit.sequential_projectors","text":"sequential_projectors(col::Int, network, env::CTMRGEnv, alg::ProjectorAlgorithm)\nsequential_projectors(coordinate::NTuple{3,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :sequential scheme either for an entire column col or for a specific coordinate (where dir=WEST is already implied in the :sequential scheme).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.simpleupdate-Tuple{InfiniteWeightPEPS, LocalOperator, SimpleUpdate}","page":"Library","title":"PEPSKit.simpleupdate","text":"simpleupdate(peps::InfiniteWeightPEPS, ham::LocalOperator, alg::SimpleUpdate;\n             bipartite::Bool=false, check_interval::Int=500)\n\nPerform simple update with nearest neighbor Hamiltonian ham, where the evolution information is printed every check_interval steps. \n\nIf bipartite == true (for square lattice), a unit cell size of (2, 2) is assumed,  as well as tensors and x/y weights which are the same across the diagonals, i.e. at (row, col) and (row+1, col+1).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.simultaneous_projectors-Union{Tuple{E}, Tuple{Array{E, 3}, CTMRGEnv, PEPSKit.ProjectorAlgorithm}} where E","page":"Library","title":"PEPSKit.simultaneous_projectors","text":"simultaneous_projectors(enlarged_corners::Array{E,3}, env::CTMRGEnv, alg::ProjectorAlgorithm)\nsimultaneous_projectors(coordinate, enlarged_corners::Array{E,3}, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :simultaneous scheme either for all provided enlarged corners or on a specific coordinate.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.su_iter-Tuple{LocalOperator, InfiniteWeightPEPS, SimpleUpdate}","page":"Library","title":"PEPSKit.su_iter","text":"su_iter(gate::LocalOperator, peps::InfiniteWeightPEPS, alg::SimpleUpdate; bipartite::Bool=false)\n\nOne round of simple update on peps applying the nearest neighbor gate.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}","page":"Library","title":"PEPSKit.symmetrize!","text":"symmetrize!(peps::InfinitePEPS, ::SymmetrizationStyle)\n\nSymmetrize a PEPS using the given SymmetrizationStyle in-place.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize_retract_and_finalize!-Tuple{PEPSKit.SymmetrizationStyle}","page":"Library","title":"PEPSKit.symmetrize_retract_and_finalize!","text":"symmetrize_retract_and_finalize!(symm::SymmetrizationStyle)\n\nReturn the retract and finalize! function for symmetrizing the peps and grad tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.tsvd-Tuple{Any, Any}","page":"Library","title":"TensorKit.tsvd","text":"PEPSKit.tsvd(t, alg; trunc=notrunc(), p=2)\n\nWrapper around TensorKit.tsvd which dispatches on the alg argument. This is needed since a custom adjoint for PEPSKit.tsvd may be defined, depending on the algorithm. E.g., for IterSVD the adjoint for a truncated SVD from KrylovKit.svdsolve is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.@autoopt-Tuple{Any}","page":"Library","title":"PEPSKit.@autoopt","text":"autoopt(ex)\n\nPreprocessor macro for @tensor which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with d, D, or χ are automatically inserted with the corresponding costs.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@diffset-Tuple{Any}","page":"Library","title":"PEPSKit.@diffset","text":"@diffset assign\n\nHelper macro which allows in-place operations in the forward-pass of Zygote, but resorts to non-mutating operations in the backwards-pass. The expression assign should assign an object to an pre-existing AbstractArray and the use of updating operators is also possible. This is especially needed when in-place assigning tensors to unit-cell arrays of environments.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@fwdthreads-Tuple{Any}","page":"Library","title":"PEPSKit.@fwdthreads","text":"@fwdthreads(ex)\n\nApply Threads.@threads only in the forward pass of the program.\n\nIt works by wrapping the for-loop expression in an if statement where in the forward pass the loop in computed in parallel using Threads.@threads, whereas in the backwards pass the Threads.@threads is omitted in order to make the expression differentiable.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@showtypeofgrad-Tuple{Any}","page":"Library","title":"PEPSKit.@showtypeofgrad","text":"@showtypeofgrad(x)\n\nMacro utility to show to type of the gradient that is about to accumulate for x.\n\nSee also Zygote.@showgrad.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.Defaults","page":"Library","title":"PEPSKit.Defaults","text":"module Defaults\n\nModule containing default algorithm parameter values and arguments.\n\nCTMRG\n\nctmrg_tol=1.0e-8 : Tolerance checking singular value and norm convergence.\nctmrg_maxiter=100 : Maximal number of CTMRG iterations per run.\nctmrg_miniter=4 : Minimal number of CTMRG carried out.\nctmrg_alg=:simultaneous : Default CTMRG algorithm variant.\n:simultaneous: Simultaneous expansion and renormalization of all sides.\n:sequential: Sequential application of left moves and rotations.\nctmrg_verbosity=2 : CTMRG output information verbosity\n\nSVD forward & reverse\n\ntrscheme=:fixedspace : Truncation scheme for SVDs and other decompositions.\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nsvd_fwd_alg=:sdd : SVD algorithm that is used in the forward pass.\n:sdd: TensorKit's wrapper for LAPACK's _gesdd\n:svd: TensorKit's wrapper for LAPACK's _gesvd\n:iterative: Iterative SVD only computing the specifed number of singular values and vectors, see 'IterSVD'\nsvd_rrule_tol=1.0e-8 : Accuracy of SVD reverse-rule.\nsvd_rrule_min_krylovdim=48 : Minimal Krylov dimension of the reverse-rule algorithm (if it is a Krylov algorithm).\nsvd_rrule_verbosity=-1 : SVD gradient output verbosity.\nsvd_rrule_alg=:arnoldi : Reverse-rule algorithm for the SVD gradient.\n:gmres: GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab: BiCGStab iterative linear solver, see the KrylovKit docs for details\n:arnoldi: Arnoldi Krylov algorithm, see the KrylovKit docs for details\n\nProjectors\n\nprojector_alg=:halfinfinite : Default variant of the CTMRG projector algorithm.\nhalfinfinite: Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.\nfullinfinite: Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.\nprojector_verbosity=0 : Projector output information verbosity.\n\nFixed-point gradient\n\ngradient_tol=1.0e-6 : Convergence tolerance for the fixed-point gradient iteration.\ngradient_maxiter=30 : Maximal number of iterations for computing the CTMRG fixed-point gradient.\ngradient_verbosity=-1 : Gradient output information verbosity.\ngradient_linsolver=:bicgstab : Default linear solver for the LinSolver gradient algorithm.\n:gmres : GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab : BiCGStab iterative linear solver, see the KrylovKit docs for details\ngradient_eigsolver=:arnoldi : Default eigensolver for the EigSolver gradient algorithm.\n:arnoldi : Arnoldi Krylov algorithm, see the KrylovKit docs for details\ngradient_eigsolver_eager=true : Enables EigSolver algorithm to finish before the full Krylov dimension is reached.\ngradient_iterscheme=:fixed : Scheme for differentiating one CTMRG iteration.\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\ngradient_alg=:linsolver : Algorithm variant for computing the gradient fixed-point.\n\nOptimization\n\nreuse_env=true : If true, the current optimization step is initialized on the previous environment, otherwise a random environment is used.\noptimizer_tol=0.0001 : Gradient norm tolerance of the optimizer.\noptimizer_maxiter=100 : Maximal number of optimization steps.\noptimizer_verbosity=3 : Optimizer output information verbosity.\noptimizer_alg=:lbfgs : Default OptimKit.OptimizerAlgorithm for PEPS optimization.\n:gradientdescent : Gradient descent algorithm, see the OptimKit README\n:conjugategradient : Conjugate gradient algorithm, see the OptimKit README\n:lbfgs : L-BFGS algorithm, see the OptimKit README\nlbfgs_memory=20 : Size of limited memory representation of BFGS Hessian matrix.\n\nOhMyThreads scheduler\n\nscheduler=Ref{Scheduler}(...) : Multi-threading scheduler which can be accessed via set_scheduler!.\n\n\n\n\n\n","category":"module"},{"location":"lib/lib/#PEPSKit.Defaults.set_scheduler!","page":"Library","title":"PEPSKit.Defaults.set_scheduler!","text":"set_scheduler!([scheduler]; kwargs...)\n\nSet OhMyThreads multi-threading scheduler parameters.\n\nThe function either accepts a scheduler as an OhMyThreads.Scheduler or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via\n\nset_scheduler!(StaticScheduler(; ntasks=4, chunking=true))\n\nor equivalently with \n\nset_scheduler!(:static; ntasks=4, chunking=true)\n\nFor a detailed description of all schedulers and their keyword arguments consult the OhMyThreads documentation.\n\nIf no scheduler is passed and only kwargs are provided, the DynamicScheduler constructor is used with the provided kwargs.\n\nTo reset the scheduler to its default value, one calls set_scheduler! without passing arguments which then uses the default DynamicScheduler(). If the number of used threads is just one it falls back to SerialScheduler().\n\n\n\n\n\n","category":"function"},{"location":"man/intro/","page":"Manual","title":"Manual","text":"Coming soon.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For now, refer to the examples folder on GitHub.","category":"page"},{"location":"#PEPSKit.jl","page":"Home","title":"PEPSKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for working with projected entangled-pair states","category":"page"},{"location":"","page":"Home","title":"Home","text":"It contracts, it optimizes, it may break.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed through the Julia general registry, via the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PEPSKit","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After following the installation process, it should now be possible to load the packages and start simulating. For example, in order to obtain the groundstate of the 2D Heisenberg model, we can use the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorKit, PEPSKit, KrylovKit, OptimKit\n\n# constructing the Hamiltonian:\nH = heisenberg_XYZ(InfiniteSquare(); Jx=-1, Jy=1, Jz=-1) # sublattice rotation to obtain single-site unit cell\n\n# configuring the parameters\nD = 2\nchi = 20\nctm_alg = SimultaneousCTMRG(; tol=1e-10, trscheme=truncdim(chi))\nopt_alg = PEPSOptimize(;\n    boundary_alg=ctm_alg,\n    optimizer_alg=LBFGS(4; maxiter=100, gradtol=1e-4, verbosity=3),\n    gradient_alg=LinSolver(),\n    reuse_env=true,\n)\n\n# ground state search\nstate = InfinitePEPS(2, D)\nctm, = leading_boundary(CTMRGEnv(state, ComplexSpace(chi)), state, ctm_alg)\npeps, env, E, = fixedpoint(H, state, ctm, opt_alg)\n\n@show E # -0.6625...","category":"page"}]
}
