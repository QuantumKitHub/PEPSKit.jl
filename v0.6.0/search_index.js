var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Corboz, P. (2016). Variational optimization with infinite projected entangled-pair states. Phys. Rev. B 94, 035133.\n\n\n\nEvenbly, G. (2018). Gauge fixing, canonical forms, and optimal truncations in tensor networks with closed loops. Phys. Rev. B 98, 085155.\n\n\n\nFrancuz, A.; Schuch, N. and Vanhecke, B. (2025). Stable and Efficient Differentiation of Tensor Network Algorithms. Physical Review Research 7, 013237.\n\n\n\nHaegeman, J. and Verstraete, F. (2017). Diagonalizing Transfer Matrices and Matrix Product Operators: A Medley of Exact and Computational Methods. Annual Review of Condensed Matter Physics 8, 355–406.\n\n\n\nHasenbusch, M. (2001). Monte Carlo Studies of the Three-Dimensional Ising Model in Equilibrium. International Journal of Modern Physics C 12, 911–1009.\n\n\n\nQin, M.; Shi, H. and Zhang, S. (2016). Benchmark study of the two-dimensional Hubbard model with auxiliary-field quantum Monte Carlo method. Phys. Rev. B 94, 085103.\n\n\n\nSandvik, A. W. (2010). Computational Studies of Quantum Spin Systems. AIP Conference Proceedings 1297, 135–338.\n\n\n\nVanderstraeten, L.; Burgelman, L.; Ponsioen, B.; Van Damme, M.; Vanhecke, B.; Corboz, P.; Haegeman, J. and Verstraete, F. (2022). Variational Methods for Contracting Projected Entangled-Pair States. Physical Review B 105, 195140.\n\n\n\nVanderstraeten, L.; Haegeman, J. and Verstraete, F. (2019). Tangent-Space Methods for Uniform Matrix Product States. SciPost Physics Lecture Notes, 007.\n\n\n\nVanderstraeten, L.; Vanhecke, B. and Verstraete, F. (2018). Residual entropies for three-dimensional frustrated spin systems with tensor networks. Phys. Rev. E 98, 042145.\n\n\n\n","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/xxz/#Néel-order-in-the-U(1)-symmetric-XXZ-model","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"","category":"section"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Here, we want to look at a special case of the Heisenberg model, where the x and y couplings are equal, called the XXZ model","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"H_0 = J big(sum_langle i j rangle S_i^x S_j^x + S_i^y S_j^y + Delta S_i^z S_j^z big) ","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"For appropriate Delta, the model enters an antiferromagnetic phase (Néel order) which we will force by adding staggered magnetic charges to H_0. Furthermore, since the XXZ Hamiltonian obeys a U(1) symmetry, we will make use of that and work with U(1)-symmetric PEPS and CTMRG environments. For simplicity, we will consider spin-12 operators.","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"But first, let's make this example deterministic and import the required packages:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"using Random\nusing TensorKit, PEPSKit\nusing MPSKit: add_physical_charge\nRandom.seed!(2928528935);","category":"page"},{"location":"examples/xxz/#Constructing-the-model","page":"Néel order in the U(1)-symmetric XXZ model","title":"Constructing the model","text":"","category":"section"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Let us define the U(1)-symmetric XXZ Hamiltonian on a 2 times 2 unit cell with the parameters:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"J = 1.0\nDelta = 1.0\nspin = 1//2\nsymmetry = U1Irrep\nlattice = InfiniteSquare(2, 2)\nH₀ = heisenberg_XXZ(ComplexF64, symmetry, lattice; J, Delta, spin);","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"This ensures that our PEPS ansatz can support the bipartite Néel order. As discussed above, we encode the Néel order directly in the ansatz by adding staggered auxiliary physical charges:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"S_aux = [\n    U1Irrep(-1//2) U1Irrep(1//2)\n    U1Irrep(1//2) U1Irrep(-1//2)\n]\nH = add_physical_charge(H₀, S_aux);","category":"page"},{"location":"examples/xxz/#Specifying-the-symmetric-virtual-spaces","page":"Néel order in the U(1)-symmetric XXZ model","title":"Specifying the symmetric virtual spaces","text":"","category":"section"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Before we create an initial PEPS and CTM environment, we need to think about which symmetric spaces we need to construct. Since we want to exploit the global U(1) symmetry of the model, we will use TensorKit's U1Spaces where we specify dimensions for each symmetry sector. From the virtual spaces, we will need to construct a unit cell (a matrix) of spaces which will be supplied to the PEPS constructor. The same is true for the physical spaces, which can be extracted directly from the Hamiltonian LocalOperator:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"V_peps = U1Space(0 => 2, 1 => 1, -1 => 1)\nV_env = U1Space(0 => 6, 1 => 4, -1 => 4, 2 => 2, -2 => 2)\nvirtual_spaces = fill(V_peps, size(lattice)...)\nphysical_spaces = physicalspace(H)","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"2×2 Matrix{TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}}:\n Rep[TensorKitSectors.U₁](0=>1, -1=>1)  Rep[TensorKitSectors.U₁](0=>1, 1=>1)\n Rep[TensorKitSectors.U₁](0=>1, 1=>1)   Rep[TensorKitSectors.U₁](0=>1, -1=>1)","category":"page"},{"location":"examples/xxz/#Ground-state-search","page":"Néel order in the U(1)-symmetric XXZ model","title":"Ground state search","text":"","category":"section"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"From this point onwards it's business as usual: Create an initial PEPS and environment (using the symmetric spaces), specify the algorithmic parameters and optimize:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"boundary_alg = (; tol=1e-8, alg=:simultaneous, trscheme=(; alg=:fixedspace))\ngradient_alg = (; tol=1e-6, alg=:eigsolver, maxiter=10, iterscheme=:diffgauge)\noptimizer_alg = (; tol=1e-4, alg=:lbfgs, maxiter=85, ls_maxiter=3, ls_maxfg=3)\n\npeps₀ = InfinitePEPS(randn, ComplexF64, physical_spaces, virtual_spaces)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, V_env), peps₀; boundary_alg...);","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"[ Info: CTMRG init:\tobj = -1.121020187593e+04 -6.991066478499e+03im\terr = 1.0000e+00\n[ Info: CTMRG conv 26:\tobj = +6.369731502336e+03 -8.500546755386e-08im\terr = 7.5599921139e-09\ttime = 2.05 sec\n","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Finally, we can optimize the PEPS with respect to the XXZ Hamiltonian. Note that the optimization might take a while since precompilation of symmetric AD code takes longer and because symmetric tensors do create a bit of overhead (which does pay off at larger bond and environment dimensions):","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"peps, env, E, info = fixedpoint(\n    H, peps₀, env₀; boundary_alg, gradient_alg, optimizer_alg, verbosity=3\n)\n@show E;","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"[ Info: LBFGS: initializing with f = -0.033045967451, ‖∇f‖ = 3.2952e-01\n┌ Warning: The function `scale!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}, 1, 4, Vector{ComplexF64}}}, Float64}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:91\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -9.90e-03, ϕ - ϕ₀ = -1.53e-01\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    1, time  151.05 s: f = -0.185750019542, ‖∇f‖ = 1.8647e+00, α = 2.50e+01, m = 0, nfg = 4\n┌ Warning: The function `add!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}, 1, 4, Vector{ComplexF64}}}, InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}, 1, 4, Vector{ComplexF64}}}, Int64, VectorInterface.One}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:163\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -1.84e-03, ϕ - ϕ₀ = -3.93e-01\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    2, time  198.17 s: f = -0.579230108476, ‖∇f‖ = 5.7732e-01, α = 2.50e+01, m = 0, nfg = 4\n[ Info: LBFGS: iter    3, time  209.90 s: f = -0.613445426304, ‖∇f‖ = 3.3947e-01, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    4, time  220.81 s: f = -0.638685295144, ‖∇f‖ = 2.2104e-01, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    5, time  232.32 s: f = -0.650336962208, ‖∇f‖ = 1.9524e-01, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    6, time  243.27 s: f = -0.654880752783, ‖∇f‖ = 7.1842e-02, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    7, time  253.29 s: f = -0.656075650331, ‖∇f‖ = 5.2129e-02, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    8, time  264.02 s: f = -0.659041890147, ‖∇f‖ = 5.3917e-02, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    9, time  274.83 s: f = -0.660552875456, ‖∇f‖ = 9.6848e-02, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter   10, time  284.84 s: f = -0.662163341463, ‖∇f‖ = 2.9524e-02, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   11, time  295.73 s: f = -0.662506513828, ‖∇f‖ = 2.1440e-02, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   12, time  305.73 s: f = -0.662847746095, ‖∇f‖ = 2.0917e-02, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   13, time  316.59 s: f = -0.663230218002, ‖∇f‖ = 2.5387e-02, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   14, time  323.15 s: f = -0.663678142653, ‖∇f‖ = 2.2924e-02, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   15, time  328.96 s: f = -0.664034475269, ‖∇f‖ = 2.1574e-02, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   16, time  340.52 s: f = -0.664687988771, ‖∇f‖ = 2.7632e-02, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   17, time  363.13 s: f = -0.664947633065, ‖∇f‖ = 3.2552e-02, α = 4.47e-01, m = 15, nfg = 2\n[ Info: LBFGS: iter   18, time  374.71 s: f = -0.665379251393, ‖∇f‖ = 2.5817e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   19, time  386.41 s: f = -0.665603907305, ‖∇f‖ = 2.4951e-02, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   20, time  397.29 s: f = -0.665762559605, ‖∇f‖ = 1.5130e-02, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   21, time  408.95 s: f = -0.666003995146, ‖∇f‖ = 1.6565e-02, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   22, time  420.69 s: f = -0.666347181648, ‖∇f‖ = 2.3025e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, time  432.27 s: f = -0.666599630335, ‖∇f‖ = 2.3462e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, time  444.52 s: f = -0.666793651525, ‖∇f‖ = 2.1908e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, time  456.87 s: f = -0.666949601577, ‖∇f‖ = 1.0867e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, time  469.23 s: f = -0.667058133735, ‖∇f‖ = 1.2475e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, time  480.73 s: f = -0.667165497296, ‖∇f‖ = 1.4340e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, time  492.42 s: f = -0.667263554939, ‖∇f‖ = 1.5667e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, time  504.11 s: f = -0.667357062063, ‖∇f‖ = 8.8494e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, time  515.48 s: f = -0.667450569240, ‖∇f‖ = 1.1496e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, time  527.47 s: f = -0.667569394671, ‖∇f‖ = 1.3976e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, time  539.89 s: f = -0.667657944766, ‖∇f‖ = 2.2321e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, time  551.52 s: f = -0.667799360459, ‖∇f‖ = 8.7543e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, time  563.83 s: f = -0.667852887856, ‖∇f‖ = 6.6668e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, time  576.15 s: f = -0.667926685233, ‖∇f‖ = 1.1902e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, time  588.14 s: f = -0.667979135052, ‖∇f‖ = 1.6349e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, time  595.62 s: f = -0.668039789983, ‖∇f‖ = 9.3108e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, time  608.27 s: f = -0.668087921855, ‖∇f‖ = 5.4669e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, time  619.58 s: f = -0.668109250700, ‖∇f‖ = 6.6628e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, time  627.01 s: f = -0.668159589044, ‖∇f‖ = 9.3986e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, time  634.57 s: f = -0.668230776691, ‖∇f‖ = 1.1534e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, time  646.27 s: f = -0.668277979949, ‖∇f‖ = 1.0707e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, time  658.67 s: f = -0.668314491012, ‖∇f‖ = 4.4476e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, time  670.98 s: f = -0.668333048195, ‖∇f‖ = 5.0062e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, time  682.77 s: f = -0.668357479998, ‖∇f‖ = 7.1015e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   46, time  695.32 s: f = -0.668412792965, ‖∇f‖ = 9.9323e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, time  719.56 s: f = -0.668439289699, ‖∇f‖ = 1.1349e-02, α = 4.53e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   48, time  732.05 s: f = -0.668482319738, ‖∇f‖ = 6.5163e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, time  744.54 s: f = -0.668507687742, ‖∇f‖ = 3.4077e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, time  756.98 s: f = -0.668523331148, ‖∇f‖ = 4.4119e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   51, time  768.78 s: f = -0.668544159952, ‖∇f‖ = 6.8178e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, time  781.25 s: f = -0.668572411228, ‖∇f‖ = 8.9225e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, time  794.44 s: f = -0.668603530102, ‖∇f‖ = 5.4599e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, time  807.70 s: f = -0.668626672236, ‖∇f‖ = 3.2841e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, time  819.27 s: f = -0.668639698673, ‖∇f‖ = 4.2163e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   56, time  831.79 s: f = -0.668655954756, ‖∇f‖ = 5.4299e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, time  844.32 s: f = -0.668673395222, ‖∇f‖ = 5.4970e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, time  856.85 s: f = -0.668687854178, ‖∇f‖ = 3.7476e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, time  868.59 s: f = -0.668698487673, ‖∇f‖ = 3.3854e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, time  881.11 s: f = -0.668705111514, ‖∇f‖ = 3.8959e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, time  894.30 s: f = -0.668720251413, ‖∇f‖ = 4.7426e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   62, time  906.61 s: f = -0.668726232684, ‖∇f‖ = 7.2528e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, time  919.67 s: f = -0.668739847818, ‖∇f‖ = 2.5815e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, time  932.86 s: f = -0.668746591101, ‖∇f‖ = 2.1675e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   65, time  944.63 s: f = -0.668754620918, ‖∇f‖ = 3.0368e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, time  957.21 s: f = -0.668767041464, ‖∇f‖ = 3.2464e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, time  982.43 s: f = -0.668775239596, ‖∇f‖ = 4.1610e-03, α = 4.24e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   68, time  995.66 s: f = -0.668784522482, ‖∇f‖ = 2.0585e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, time 1008.92 s: f = -0.668792875861, ‖∇f‖ = 2.5737e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, time 1020.82 s: f = -0.668799555353, ‖∇f‖ = 3.0991e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, time 1034.03 s: f = -0.668807510786, ‖∇f‖ = 3.9740e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, time 1047.37 s: f = -0.668815529198, ‖∇f‖ = 2.8312e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, time 1059.65 s: f = -0.668820072176, ‖∇f‖ = 1.8277e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, time 1072.71 s: f = -0.668823045663, ‖∇f‖ = 2.1189e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, time 1086.03 s: f = -0.668829224417, ‖∇f‖ = 3.3000e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, time 1098.65 s: f = -0.668834661996, ‖∇f‖ = 3.3841e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, time 1112.36 s: f = -0.668839125190, ‖∇f‖ = 1.5494e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, time 1126.16 s: f = -0.668842178047, ‖∇f‖ = 1.8074e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, time 1140.07 s: f = -0.668846182434, ‖∇f‖ = 2.1704e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   80, time 1152.70 s: f = -0.668849851199, ‖∇f‖ = 4.3895e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   81, time 1165.98 s: f = -0.668854730352, ‖∇f‖ = 1.9014e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   82, time 1179.77 s: f = -0.668857445978, ‖∇f‖ = 1.6213e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   83, time 1192.89 s: f = -0.668861083091, ‖∇f‖ = 2.1544e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   84, time 1205.95 s: f = -0.668865914837, ‖∇f‖ = 2.4867e-03, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 85 iterations and time 1219.27 s: f = -0.668869945971, ‖∇f‖ = 4.5125e-03\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/lbfgs.jl:197\nE = -0.6688699459708735\n","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Note that for the specified parameters J = Delta = 1, we simulated the same Hamiltonian as in the Heisenberg example. In that example, with a non-symmetric D=2 PEPS simulation, we reached a ground-state energy of around E_textD=2 = -06625dots. Again comparing against Sandvik's accurate QMC estimate E_textref=06694421, we see that we already got closer to the reference energy.","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/lib/#PEPSKit.ALSTruncation","page":"Library","title":"PEPSKit.ALSTruncation","text":"struct ALSTruncation\n\nAlgorithm struct for the alternating least square (ALS) optimization of a bond. \n\nFields\n\ntrscheme::TensorKit.TruncationScheme\nmaxiter::Int64\ntol::Float64\ncheck_interval::Int64\n\nConstructors\n\nALSTruncation(; kwargs...)\n\nThe truncation algorithm can be constructed from the following keyword arguments:\n\ntrscheme::TensorKit.TruncationScheme: SVD truncation scheme when initilizing the truncated tensors connected by the bond.\nmaxiter::Int=50 : Maximal number of ALS iterations.\ntol::Float64=1e-15 : ALS converges when fidelity change between two FET iterations is smaller than tol.\ncheck_interval::Int=0 : Set number of iterations to print information. Output is suppressed when check_interval <= 0. \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGAlgorithm","page":"Library","title":"PEPSKit.CTMRGAlgorithm","text":"abstract type CTMRGAlgorithm\n\nAbstract super type for the corner transfer matrix renormalization group (CTMRG) algorithm for contracting infinite PEPS.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGAlgorithm-Tuple{}","page":"Library","title":"PEPSKit.CTMRGAlgorithm","text":"CTMRGAlgorithm(; kwargs...)\n\nKeyword argument parser returning the appropriate CTMRGAlgorithm algorithm struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv","page":"Library","title":"PEPSKit.CTMRGEnv","text":"struct CTMRGEnv{C, T}\n\nCorner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.\n\nGiven arrays of corners c and edges t, they connect to the network tensors P at site (r, c) in the unit cell as:\n\n   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]\n   |              |             |\n   t[4,r,c-1]-----P[r,c]--------t[2,r,c+1]\n   |              |             |\n   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]\n\nHere P represents an effective local constituent tensor. This can either be a single rank-4 tensor, a pair of PEPS tensors, or a stack of PEPS-PEPO-PEPS tensors depending on the network being contracted.\n\nFields\n\ncorners::Array{C, 3} where C: 4 x rows x cols array of corner tensors, where the first dimension specifies the spatial direction\nedges::Array{T, 3} where T: 4 x rows x cols array of edge tensors, where the first dimension specifies the spatial direction\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfiniteSquareNetwork, A}, Tuple{InfiniteSquareNetwork, A, A}, Tuple{InfiniteSquareNetwork, A, A, A}, Tuple{InfiniteSquareNetwork, Vararg{A, 4}}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], network::InfiniteSquareNetwork, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:AbstractMatrix{<:ElementarySpaceLike}}}\n\nConstruct a CTMRG environment by specifying a corresponding InfiniteSquareNetwork, and the north, east, south and west virtual spaces of the environment as matrices. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{B}, Tuple{A}, Tuple{A, A, B}, Tuple{A, A, B, B}, Tuple{A, A, B, B, B}, Tuple{A, A, Vararg{B, 4}}} where {A<:(AbstractMatrix{<:Union{NTuple{N, Int64}, NTuple{N, var\"#s139\"} where var\"#s139\"<:TensorKit.ElementarySpace, TensorKit.ProductSpace{<:TensorKit.ElementarySpace, N}} where N}), B<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], Ds_north::A, Ds_east::A, chis_north::B, [chis_east::B], [chis_south::B], [chis_west::B]\n) where {A<:AbstractMatrix{<:SpaceLike}, B<:AbstractMatrix{<:ElementarySpaceLike}}\n\nConstruct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding partition function and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\nEach entry of the Ds_north and Ds_east matrices corresponds to an effective local space of the partition function, represented as a tuple of elementary spaces encoding a product space. This can either contain a single elementary space for the case of a partition function defined in terms of local rank-4 tensors, or a tuple of elementary spaces representing a product space for the case of a partition function representing overlaps of PEPSs and PEPOs.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfiniteSquareNetwork, S}, Tuple{InfiniteSquareNetwork, S, S}, Tuple{InfiniteSquareNetwork, S, S, S}, Tuple{InfiniteSquareNetwork, Vararg{S, 4}}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64,] network::InfiniteSquareNetwork, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S],\n) where {S<:ElementarySpaceLike}\n\nConstruct a CTMRG environment by specifying a corresponding InfiniteSquareNetwork, and the north, east, south and west virtual spaces of the environment. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{P}, Tuple{P, P, S}, Tuple{P, P, S, S}, Tuple{P, P, S, S, S}, Tuple{P, P, Vararg{S, 4}}} where {P<:(Union{NTuple{N, Int64}, NTuple{N, var\"#s139\"} where var\"#s139\"<:TensorKit.ElementarySpace, TensorKit.ProductSpace{<:TensorKit.ElementarySpace, N}} where N), S<:Union{Int64, TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], D_north::P, D_east::P, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S];\n    unitcell::Tuple{Int,Int}=(1, 1),\n) where {P<:ProductSpaceLike,S<:ElementarySpaceLike}\n\nConstruct a CTMRG environment by specifying the north and east virtual spaces of the corresponding InfiniteSquareNetwork and the north, east, south and west virtual spaces of the environment. The network unit cell can be specified by the unitcell keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.EigSolver","page":"Library","title":"PEPSKit.EigSolver","text":"struct EigSolver{F} <: PEPSKit.GradMode{F}\n\nGradient mode wrapper around KrylovKit.KrylovAlgorithm for solving the gradient linear problem as an eigenvalue problem.\n\nFields\n\nsolver_alg::KrylovKit.KrylovAlgorithm\n\nConstructors\n\nEigSolver(; kwargs...)\n\nConstruct the EigSolver algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance of the eigen solver.\nmaxiter::Int=30 : Maximal number of solver iterations.\nverbosity::Int=-1 : Output information verbosity of the linear solver.\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\nsolver_alg::Union{KrylovKit.KrylovAlgorithm,NamedTuple}=(; alg=:arnoldi : Eigen solver algorithm which, if supplied directly as a KrylovKit.KrylovAlgorithm overrides the above specified tol, maxiter and verbosity. Alternatively, it can be supplied via a NamedTuple where alg can be one of the following:\n:arnoldi : Arnoldi Krylov algorithm, see KrylovKit.Arnoldi for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.EnlargedCorner","page":"Library","title":"PEPSKit.EnlargedCorner","text":"struct EnlargedCorner{TC, TE, TA}\n\nEnlarged CTMRG corner tensor storage.\n\nConstructors\n\nEnlargedCorner(network::InfiniteSquareNetwork, env, coordinates)\n\nConstruct an enlarged corner with the correct row and column indices based on the given coordinates which are of the form (dir, row, col).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedSVD","page":"Library","title":"PEPSKit.FixedSVD","text":"struct FixedSVD{Ut, St, Vt, Utf, Stf, Vtf}\n\nSVD struct containing a pre-computed decomposition or even multiple ones. Additionally, it can contain the untruncated full decomposition as well. The call to tsvd just returns the pre-computed U, S and V. In the reverse pass, the SVD adjoint is computed with these exact U, S, and V and, potentially, the full decompositions if the adjoints needs access to them.\n\nFields\n\nU::Any\nS::Any\nV::Any\nU_full::Any\nS_full::Any\nV_full::Any\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedSpaceTruncation","page":"Library","title":"PEPSKit.FixedSpaceTruncation","text":"struct FixedSpaceTruncation <: TensorKit.TruncationScheme\n\nCTMRG specific truncation scheme for tsvd which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from TruncationSpace.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullEnvTruncation","page":"Library","title":"PEPSKit.FullEnvTruncation","text":"struct FullEnvTruncation\n\nAlgorithm struct for the full environment truncation (FET).\n\nFields\n\ntrscheme::TensorKit.TruncationScheme\nmaxiter::Int64\ntol::Float64\ntrunc_init::Bool\ncheck_interval::Int64\n\nConstructors\n\nFullEnvTruncation(; kwargs...)\n\nThe truncation algorithm can be constructed from the following keyword arguments:\n\ntrscheme::TensorKit.TruncationScheme : SVD truncation scheme when optimizing the new bond matrix.\nmaxiter::Int=50 : Maximal number of FET iterations.\ntol::Float64=1e-15 : FET converges when fidelity change between two FET iterations is smaller than tol.\ntrunc_init::Bool=true : Controls whether the initialization of the new bond matrix is obtained from truncated SVD of the old bond matrix. \ncheck_interval::Int=0 : Set number of iterations to print information. Output is suppressed when check_interval <= 0. \n\nReferences\n\nGlen Evenbly, Phys. Rev. B 98, 085155 (2018). \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullInfiniteEnv","page":"Library","title":"PEPSKit.FullInfiniteEnv","text":"struct FullInfiniteEnv{TC, TE, TA}\n\nFull-infinite CTMRG environment tensor storage.\n\nFields\n\nC_1\nC_2\nC_3\nC_4\nE_1\nE_2\nE_3\nE_4\nE_5\nE_6\nE_7\nE_8\nA_1\nA_2\nA_3\nA_4\n\nConstructors\n\nFullInfiniteEnv(\n    quadrant1::E, quadrant2::E, quadrant3::E, quadrant4::E\n) where {E<:EnlargedCorner}\n\nConstruct sparse full-infinite environment based on four sparse enlarged corners (quadrants).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullInfiniteEnv-Tuple{Any, Val{false}}","page":"Library","title":"PEPSKit.FullInfiniteEnv","text":"(env::FullInfiniteEnv)(x, ::Val{false}) \n(env::FullInfiniteEnv)(x, ::Val{true})\n\nContract full-infinite environment with a vector x, such that the environment acts as a linear map or adjoint linear map on x if Val(true) or Val(false) is passed, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.FullInfiniteProjector","page":"Library","title":"PEPSKit.FullInfiniteProjector","text":"struct FullInfiniteProjector{S<:SVDAdjoint, T} <: PEPSKit.ProjectorAlgorithm\n\nProjector algorithm implementing projectors from SVDing the full 4x4 CTMRG environment.\n\nFields\n\nsvd_alg::SVDAdjoint\ntrscheme::Any\nverbosity::Int64\n\nConstructors\n\nFullInfiniteProjector(; kwargs...)\n\nConstruct the full-infinite projector algorithm based on the following keyword arguments:\n\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}=SVDAdjoint() : SVD algorithm including the reverse rule. See SVDAdjoint.\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nverbosity::Int=0 : Projector output verbosity which can be:\nSuppress output information\nPrint singular value degeneracy warnings\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullSVDReverseRule","page":"Library","title":"PEPSKit.FullSVDReverseRule","text":"struct FullSVDReverseRule\n\nSVD reverse-rule algorithm which uses a modified version of TensorKit's tsvd! reverse-rule allowing for Lorentzian broadening and output verbosity control.\n\nFields\n\nbroadening::Float64\nverbosity::Int64\n\nConstructors\n\nFullSVDReverseRule(; kwargs...)\n\nConstruct a FullSVDReverseRule algorithm struct from the following keyword arguments:\n\nbroadening::Float64=1.0e-13 : Lorentzian broadening amplitude for smoothing divergent term in SVD derivative in case of (pseudo) degenerate singular values.\nverbosity::Int=0 : Suppresses all output if ≤0, prints gauge dependency warnings if 1, and always prints gauge dependency if ≥2.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GeomSum","page":"Library","title":"PEPSKit.GeomSum","text":"struct GeomSum{F} <: PEPSKit.GradMode{F}\n\nGradient mode for CTMRG using explicit evaluation of the geometric sum.\n\nFields\n\ntol::Real\nmaxiter::Int64\nverbosity::Int64\n\nConstructors\n\nGeomSum(; kwargs...)\n\nConstruct the GeomSum algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance for the difference of norms of two consecutive summands in the geometric sum.\nmaxiter::Int=30 : Maximal number of gradient iterations.\nverbosity::Int=-1 : Output information verbosity that can be one of the following:\nSuppress output information\nPrint convergence warnings\nInformation at each gradient iteration\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GradMode-Tuple{}","page":"Library","title":"PEPSKit.GradMode","text":"GradMode(; kwargs...)\n\nKeyword argument parser returning the appropriate GradMode algorithm struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"struct HalfInfiniteEnv{TC, TE, TA}\n\nHalf-infinite CTMRG environment tensor storage.\n\nFields\n\nC_1\nC_2\nE_1\nE_2\nE_3\nE_4\nA_1\nA_2\n\nConstructors\n\nHalfInfiniteEnv(quadrant1::EnlargedCorner, quadrant2::EnlargedCorner)\n\nConstruct sparse half-infinite environment based on two sparse enlarged corners (quadrants).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv-Tuple{Any, Val{false}}","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"(env::HalfInfiniteEnv)(x, ::Val{false}) \n(env::HalfInfiniteEnv)(x, ::Val{true})\n\nContract half-infinite environment with a vector x, such that the environment acts as a linear map or adjoint linear map on x if Val(true) or Val(false) is passed, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.HalfInfiniteProjector","page":"Library","title":"PEPSKit.HalfInfiniteProjector","text":"struct HalfInfiniteProjector{S<:SVDAdjoint, T} <: PEPSKit.ProjectorAlgorithm\n\nProjector algorithm implementing projectors from SVDing the half-infinite CTMRG environment.\n\nFields\n\nsvd_alg::SVDAdjoint\ntrscheme::Any\nverbosity::Int64\n\nConstructors\n\nHalfInfiniteProjector(; kwargs...)\n\nConstruct the half-infinite projector algorithm based on the following keyword arguments:\n\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}=SVDAdjoint() : SVD algorithm including the reverse rule. See SVDAdjoint.\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nverbosity::Int=0 : Projector output verbosity which can be:\nSuppress output information\nPrint singular value degeneracy warnings\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO","page":"Library","title":"PEPSKit.InfinitePEPO","text":"struct InfinitePEPO{T<:PEPOTensor}\n\nRepresents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.\n\nFields\n\nA::Array{T, 3} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::PEPOTensor; unitcell=(1, 1, 1))\n\nCreate an InfinitePEPO by specifying a tensor which is repeated across the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::AbstractArray{T, 3})\n\nAllow users to pass in an array of tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A<:(AbstractArray{<:TensorKit.ElementarySpace, 3})","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO([f=randn, T=ComplexF64,] Pspaces, Nspaces, Espaces)\n\nAllow users to pass in arrays of spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO([f=randn, T=ComplexF64,] Pspace::S, Nspace::S, [Espace::S]; unitcell=(1,1,1)) where {S<:ElementarySpace}\n\nCreate an InfinitePEPO by specifying its spaces and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS","page":"Library","title":"PEPSKit.InfinitePEPS","text":"struct InfinitePEPS{T<:PEPSTensor}\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice.\n\nFields\n\nA::Matrix{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{AbstractMatrix{<:TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::AbstractMatrix{T})\n\nCreate an InfinitePEPS by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{InfiniteWeightPEPS}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(peps::InfiniteWeightPEPS)\n\nCreate InfinitePEPS from InfiniteWeightPEPS by absorbing bond weights into vertex tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::PEPSTensor; unitcell=(1, 1))\n\nCreate an InfinitePEPS by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            ||         ||\n---T[r,c-1]=====AA[r,c]====AA[r,c+1]====\n   |            ||         ||\n---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==\n   |            ||         ||\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{A}, Tuple{A, A, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS([f=randn, T=ComplexF64,] Pspaces::A, Nspaces::A, [Espaces::A]) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfinitePEPS by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS([f=randn, T=ComplexF64,] Pspace, Nspace, [Espace]; unitcell=(1,1))\n\nCreate an InfinitePEPS by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via Int or via ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"struct InfinitePartitionFunction{T<:PartitionFunctionTensor}\n\nRepresents an infinite partition function on a 2D square lattice.\n\nFields\n\nA::Matrix{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(A; unitcell=(1, 1))\n\nCreate an InfinitePartitionFunction by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if partition function tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            |          |\n---T[r,c-1]-----AA[r,c]----AA[r,c+1]----\n   |            |          |\n---T[r+1,c-1]---AA[r+1,c]--AA[r+1,c+1]--\n   |            |          |\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(A::AbstractMatrix{T})\n\nCreate an InfinitePartitionFunction by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{A}, Tuple{A, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(\n    [f=randn, T=ComplexF64,] Pspaces::A, Nspaces::A, [Espaces::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfinitePartitionFunction by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{S}, Tuple{S, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(\n    [f=randn, T=ComplexF64,] Pspace::S, Nspace::S, [Espace::S]; unitcell=(1,1)\n) where {S<:ElementarySpaceLike}\n\nCreate an InfinitePartitionFunction by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via Int or via ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteSquare","page":"Library","title":"PEPSKit.InfiniteSquare","text":"struct InfiniteSquare <: MPSKitModels.AbstractLattice{2}\n\nInfinite square lattice with a unit cell of size (Nrows, Ncols).\n\nFields\n\nNrows::Int64\nNcols::Int64\n\nConstructor\n\nInfiniteSquare([Nrows=1, Ncols=1])\n\nBy default, an infinite square with a (1, 1)-unitcell is constructed.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteSquareNetwork","page":"Library","title":"PEPSKit.InfiniteSquareNetwork","text":"struct InfiniteSquareNetwork{O}\n\nContractible square network. Wraps a matrix of 'rank-4-tensor-like' objects.\n\nFields\n\nA::Matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO{H,T,O}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS{T}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS(T::InfinitePEPS, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"struct InfiniteWeightPEPS{T<:PEPSTensor,E<:PEPSWeight}\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice consisting of vertex tensors and bond weights.\n\nFields\n\nvertices::Matrix{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)\nweights::SUWeight\n\nConstructors\n\nInfiniteWeightPEPS(vertices::Matrix{T}, weight_mats::Matrix{E}...) where {T<:PEPSTensor,E<:PEPSWeight}\nInfiniteWeightPEPS([f=randn, T=ComplexF64,] Pspaces::M, Nspaces::M, [Espaces::M]) where {M<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\nInfiniteWeightPEPS([f=randn, T=ComplexF64,] Pspace::S, Nspace::S, Espace::S=Nspace; unitcell::Tuple{Int,Int}=(1, 1)) where {S<:ElementarySpace}\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS-Tuple{InfinitePEPS}","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"InfiniteWeightPEPS(peps::InfinitePEPS)\n\nCreate InfiniteWeightPEPS from InfinitePEPS by initializing the bond weights as identity matrices of element type Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS-Union{Tuple{E}, Tuple{T}, Tuple{Matrix{T}, Vararg{Matrix{E}}}} where {T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), E<:(TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S})}","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"InfiniteWeightPEPS(vertices::Matrix{T}, weight_mats::Matrix{E}...) where {T<:PEPSTensor,E<:PEPSWeight}\n\nCreate an InfiniteWeightPEPS from matrices of vertex tensors, and separate matrices of weights on each type of bond at all locations in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS-Union{Tuple{M}, Tuple{M, M, M}} where M<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"InfiniteWeightPEPS([f=randn, T=ComplexF64,] Pspaces::M, Nspaces::M, [Espaces::M]) where {M<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfiniteWeightPEPS by specifying the physical, north virtual and east virtual spaces of the PEPS vertex tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace. Bond weights are initialized as identity matrices of element type Float64. \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS-Union{Tuple{S}, Tuple{S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"InfiniteWeightPEPS([f=randn, T=ComplexF64,] Pspace::S, Nspace::S, Espace::S=Nspace; unitcell::Tuple{Int,Int}=(1, 1)) where {S<:ElementarySpace}\n\nCreate an InfiniteWeightPEPS by specifying its physical, north and east spaces (as ElementarySpaces) and unit cell size. Use T to specify the element type of the vertex tensors.  Bond weights are initialized as identity matrices of element type Float64. \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.IterSVD","page":"Library","title":"PEPSKit.IterSVD","text":"struct IterSVD\n\nIterative SVD solver based on KrylovKit's GKL algorithm, adapted to (symmetric) tensors. The number of targeted singular values is set via the TruncationSpace in ProjectorAlg. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn't converge, the algorithm falls back to a dense SVD.\n\nFields\n\nalg::KrylovKit.GKL\nfallback_threshold::Float64\nstart_vector::Any\n\nConstructors\n\nIterSVD(; kwargs...)\n\nConstruct an IterSVD algorithm struct based on the following keyword arguments:\n\nalg::KrylovKit.GKL=KrylovKit.GKL(; tol=1e-14, krylovdim=25) : GKL algorithm struct for block-wise iterative SVD.\nfallback_threshold::Float64=Inf : Threshold for howmany / minimum(size(block)) above which (if the block is too small) the algorithm falls back to TensorKit's dense SVD.\nstart_vector=random_start_vector : Function providing the initial vector for the iterative SVD algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LinSolver","page":"Library","title":"PEPSKit.LinSolver","text":"struct LinSolver{F} <: PEPSKit.GradMode{F}\n\nGradient mode wrapper around KrylovKit.LinearSolver for solving the gradient linear problem using iterative solvers.\n\nFields\n\nsolver_alg::KrylovKit.LinearSolver\n\nConstructors\n\nLinSolver(; kwargs...)\n\nConstruct the LinSolver algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance of the linear solver.\nmaxiter::Int=30 : Maximal number of solver iterations.\nverbosity::Int=-1 : Output information verbosity of the linear solver.\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\nsolver_alg::Union{KrylovKit.LinearSolver,NamedTuple}=(; alg::Symbol=:bicgstab : Linear solver algorithm which, if supplied directly as a KrylovKit.LinearSolver overrides the above specified tol, maxiter and verbosity. Alternatively, it can be supplied via a NamedTuple where alg can be one of the following:\n:gmres : GMRES iterative linear solver, see KrylovKit.GMRES for details\n:bicgstab : BiCGStab iterative linear solver, see KrylovKit.BiCGStab for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LocalOperator","page":"Library","title":"PEPSKit.LocalOperator","text":"struct LocalOperator{T<:Tuple, S}\n\nA sum of local operators acting on a lattice. The lattice is stored as a matrix of vector spaces, and the terms are stored as a tuple of pairs of indices and operators.\n\nFields\n\nlattice::Matrix{S}: The lattice on which the operator acts.\nterms::T: The terms of the operator, stored as a tuple of pairs of indices and operators.\n\nConstructors\n\nLocalOperator(lattice::Matrix{S}, terms::Pair...)\nLocalOperator{T,S}(lattice::Matrix{S}, terms::T) where {T,S}\n\nExamples\n\nlattice = fill(ℂ^2, 1, 1) # single-site unitcell\nO1 = LocalOperator(lattice, ((1, 1),) => σx, ((1, 1), (1, 2)) => σx ⊗ σx, ((1, 1), (2, 1)) => σx ⊗ σx)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ManualIter","page":"Library","title":"PEPSKit.ManualIter","text":"struct ManualIter{F} <: PEPSKit.GradMode{F}\n\nGradient mode for CTMRG using manual iteration to solve the linear problem.\n\nFields\n\ntol::Real\nmaxiter::Int64\nverbosity::Int64\n\nConstructors\n\nManualIter(; kwargs...)\n\nConstruct the ManualIter algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance for the norm difference of two consecutive dx contributions.\nmaxiter::Int=30 : Maximal number of gradient iterations.\nverbosity::Int=-1 : Output information verbosity that can be one of the following:\nSuppress output information\nPrint convergence warnings\nInformation at each gradient iteration\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPO","page":"Library","title":"PEPSKit.MultilineTransferPEPO","text":"const MultilineTransferPEPO = MPSKit.Multiline{<:InfiniteTransferPEPO}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any}","page":"Library","title":"PEPSKit.MultilineTransferPEPO","text":"MultilineTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPS","page":"Library","title":"PEPSKit.MultilineTransferPEPS","text":"const MultilineTransferPEPS = MPSKit.Multiline{<:InfiniteTransferPEPS}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPS-Tuple{InfinitePEPS, Any}","page":"Library","title":"PEPSKit.MultilineTransferPEPS","text":"MultilineTransferPEPS(T::InfinitePEPS, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.PEPOTensor","page":"Library","title":"PEPSKit.PEPOTensor","text":"const PEPOTensor{S}\n\nDefault type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: T  P  P  N  E  S  W. Here, P and P denote the incoming and outgoing physical space respectively, encoding the physical mapping from P to P where P corresponds to a physical PEPS index. N, E, S and W denote the physics, north, east, south and west spaces, respectively.\n\n        P´ N\n        | ╱\n        |╱\n   W---- ----E\n       ╱|\n      ╱ |\n     S  P\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSOptimize","page":"Library","title":"PEPSKit.PEPSOptimize","text":"struct PEPSOptimize{G}\n\nAlgorithm struct for PEPS ground-state optimization using AD. See fixedpoint for details.\n\nFields\n\nboundary_alg::PEPSKit.CTMRGAlgorithm\ngradient_alg::Any\noptimizer_alg::OptimKit.OptimizationAlgorithm\nreuse_env::Bool\nsymmetrization::Union{Nothing, PEPSKit.SymmetrizationStyle}\n\nConstructors\n\nPEPSOptimize(; kwargs...)\n\nConstruct a PEPS optimization algorithm struct based on keyword arguments. For a full description, see fixedpoint. The supported keywords are:\n\nboundary_alg::Union{NamedTuple,<:CTMRGAlgorithm}\ngradient_alg::Union{NamedTuple,Nothing,<:GradMode}\noptimizer_alg::Union{NamedTuple,<:OptimKit.OptimizationAlgorithm}\nreuse_env::Bool=true\nsymmetrization::Union{Nothing,SymmetrizationStyle}=nothing\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor","page":"Library","title":"PEPSKit.PEPSTensor","text":"const PEPSTensor{S}\n\nDefault type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: T  P  N  E  S  W. Here, P denotes the physical space and N, E, S and W denote the north, east, south and west virtual spaces, respectively.\n\n           N\n          ╱\n         ╱\n   W---- ----E\n       ╱|\n      ╱ |\n     S  P\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.PEPSTensor","text":"PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,\n           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S<:Union{Int,ElementarySpace}}\n\nConstruct a PEPS tensor based on the physical, north, east, west and south spaces. Alternatively, only the space dimensions can be provided and ℂ is assumed as the field. The tensor elements are generated based on f and the element type is specified in T.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.PEPSWeight","page":"Library","title":"PEPSKit.PEPSWeight","text":"const PEPSWeight\n\nDefault type for PEPS bond weights with 2 virtual indices, conventionally ordered as: wt  WS  EN.  WS, EN denote the west/south, east/north spaces for x/y-weights on the square lattice, respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PartitionFunctionTensor","page":"Library","title":"PEPSKit.PartitionFunctionTensor","text":"const PartitionFunctionTensor{S}\n\nDefault type for partition function tensors with 4 virtual indices, conventionally ordered as: T  W  S  N  E. Here, N, E, S and W denote the north, east, south and west spaces, respectively.\n\n          N\n         ╱\n        ╱\n  W---- ----E\n      ╱\n     ╱\n    S \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ProjectorAlgorithm","page":"Library","title":"PEPSKit.ProjectorAlgorithm","text":"abstract type ProjectorAlgorithm\n\nAbstract super type for all CTMRG projector algorithms.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ProjectorAlgorithm-Tuple{}","page":"Library","title":"PEPSKit.ProjectorAlgorithm","text":"ProjectorAlgorithm(; kwargs...)\n\nKeyword argument parser returning the appropriate ProjectorAlgorithm algorithm struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ReflectDepth","page":"Library","title":"PEPSKit.ReflectDepth","text":"struct ReflectDepth <: PEPSKit.SymmetrizationStyle\n\nReflection symmmetrization along the horizontal axis, such that north and south are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectWidth","page":"Library","title":"PEPSKit.ReflectWidth","text":"struct ReflectWidth <: PEPSKit.SymmetrizationStyle\n\nReflection symmmetrization along the vertical axis, such that east and west are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.Rotate","page":"Library","title":"PEPSKit.Rotate","text":"struct Rotate <: PEPSKit.SymmetrizationStyle\n\nRotation symmmetrization leaving the object invariant under π/2 rotations.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.RotateReflect","page":"Library","title":"PEPSKit.RotateReflect","text":"struct RotateReflect <: PEPSKit.SymmetrizationStyle\n\nFull reflection and rotation symmmetrization, such that reflection along the horizontal and vertical axis as well as π/2 rotations leave the object invariant.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SUWeight","page":"Library","title":"PEPSKit.SUWeight","text":"struct SUWeight{E<:PEPSWeight}\n\nSchmidt bond weights used in simple/cluster update. Weight elements are always real.\n\nFields\n\ndata::Array{E, 3} where E<:(TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S})\n\nConstructors\n\nSUWeight(wts_mats::AbstractMatrix{E}...) where {E<:PEPSWeight}\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SVDAdjoint","page":"Library","title":"PEPSKit.SVDAdjoint","text":"struct SVDAdjoint{F, R}\n\nWrapper for a SVD algorithm fwd_alg with a defined reverse rule rrule_alg. If isnothing(rrule_alg), Zygote differentiates the forward call automatically.\n\nFields\n\nfwd_alg::Any\nrrule_alg::Any\n\nConstructors\n\nSVDAdjoint(; kwargs...)\n\nConstruct a SVDAdjoint algorithm struct based on the following keyword arguments:\n\nfwd_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=sdd): SVD algorithm of the forward pass which can either be passed as an Algorithm instance or a NamedTuple where alg is one of the following:\n:sdd : TensorKit's wrapper for LAPACK's _gesdd\n:svd : TensorKit's wrapper for LAPACK's _gesvd\n:iterative : Iterative SVD only computing the specifed number of singular values and vectors, see IterSVD\nrrule_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=full): Reverse-rule algorithm for differentiating the SVD. Can be supplied by an Algorithm instance directly or as a NamedTuple where alg is one of the following:\n:full: Uses a modified version of TensorKit's reverse-rule for tsvd which doesn't solve any linear problem and instead requires access to the full SVD, see FullSVDReverseRule.\n:gmres: GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab: BiCGStab iterative linear solver, see the KrylovKit docs for details\n:arnoldi: Arnoldi Krylov algorithm, see the KrylovKit docs for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SequentialCTMRG","page":"Library","title":"PEPSKit.SequentialCTMRG","text":"struct SequentialCTMRG <: CTMRGAlgorithm\n\nCTMRG algorithm where the expansions and renormalization is performed sequentially column-wise. This is implemented as a growing and projecting step to the left, followed by a clockwise rotation (performed four times).\n\nFields\n\ntol::Float64\nmaxiter::Int64\nminiter::Int64\nverbosity::Int64\nprojector_alg::PEPSKit.ProjectorAlgorithm\n\nConstructors\n\nSequentialCTMRG(; kwargs...)\n\nConstruct a sequential CTMRG algorithm struct based on keyword arguments. For a full description, see leading_boundary. The supported keywords are:\n\ntol::Real=1.0e-8\nmaxiter::Int=100\nminiter::Int=4\nverbosity::Int=2\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace)\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}\nprojector_alg::Symbol=:halfinfinite\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimpleUpdate","page":"Library","title":"PEPSKit.SimpleUpdate","text":"struct SimpleUpdate\n\nAlgorithm struct for simple update (SU) of infinite PEPS with bond weights. Each SU run is converged when the singular value difference becomes smaller than tol.\n\nFields\n\ndt::Float64\ntol::Float64\nmaxiter::Int64\ntrscheme::TensorKit.TruncationScheme\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimultaneousCTMRG","page":"Library","title":"PEPSKit.SimultaneousCTMRG","text":"struct SimultaneousCTMRG <: PEPSKit.CTMRGAlgorithm\n\nCTMRG algorithm where all sides are grown and renormalized at the same time. In particular, the projectors are applied to the corners from two sides simultaneously.\n\nFields\n\ntol::Float64\nmaxiter::Int64\nminiter::Int64\nverbosity::Int64\nprojector_alg::PEPSKit.ProjectorAlgorithm\n\nConstructors\n\nSimultaneousCTMRG(; kwargs...)\n\nConstruct a simultaneous CTMRG algorithm struct based on keyword arguments. For a full description, see leading_boundary. The supported keywords are:\n\ntol::Real=1.0e-8\nmaxiter::Int=100\nminiter::Int=4\nverbosity::Int=2\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace)\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}\nprojector_alg::Symbol=:halfinfinite\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.EnlargedCorner, Int64}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(Q::EnlargedCorner, dir::Int)\n\nInstantiate enlarged corner as TensorMap where dir selects the correct contraction direction, i.e. the way the environment and PEPS tensors connect.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.FullInfiniteEnv}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(env::FullInfiniteEnv)\n\nInstantiate full-infinite environment as TensorMap explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.HalfInfiniteEnv}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(env::HalfInfiniteEnv)\n\nInstantiate half-infinite environment as TensorMap explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#FiniteDifferences.to_vec-Tuple{InfinitePEPS}","page":"Library","title":"FiniteDifferences.to_vec","text":"to_vec(A::InfinitePEPS) -> vec, state_from_vec\n\nVectorize an InfinitePEPS into a vector of real numbers. A vectorized infinite PEPS can retrieved again as an InfinitePEPS by application of the state_from_vec map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.add_physical_charge-Tuple{LocalOperator, AbstractMatrix{<:TensorKitSectors.Sector}}","page":"Library","title":"MPSKit.add_physical_charge","text":"add_physical_charge(H::LocalOperator, charges::AbstractMatrix{<:Sector})\n\nChange the spaces of a LocalOperator by fusing in an auxiliary charge into the domain of the operator on every site, according to a given matrix of 'auxiliary' physical charges.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.correlation_length-Tuple{Any, CTMRGEnv}","page":"Library","title":"MPSKit.correlation_length","text":"correlation_length(state, env::CTMRGEnv; num_vals=2, kwargs...)\n\nCompute the correlation length associated to state as contracted using the environment env, based on the spectrum of the horizontal and vertical transfer matrices associated to env. Additionally the (normalized) eigenvalue spectrum is returned. The number of computed eigenvalues can be specified using num_vals, and any remaining keyword arguments are passed through to MPSKit.transfer_spectrum (e.g. allowing to target the correlation length in a specific symmetry sector).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{Any, Any}","page":"Library","title":"MPSKit.expectation_value","text":"MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})\nMPSKit.expectation_value(st::MultilineMPS, op::Union{MultilineTransferPEPS,MultilineTransferPEPO})\n\nCompute expectation value of the transfer operator op for the state st for each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{InfinitePEPS, LocalOperator, CTMRGEnv}","page":"Library","title":"MPSKit.expectation_value","text":"expectation_value(peps::InfinitePEPS, O::LocalOperator, env::CTMRGEnv)\n\nCompute the expectation value ⟨peps|O|peps⟩ / ⟨peps|peps⟩ of a LocalOperator O for a PEPS peps using a given CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Union{Tuple{S}, Tuple{T}, Tuple{InfinitePartitionFunction, Pair{CartesianIndex{2}, <:TensorKit.AbstractTensorMap{T, S, 2, 2}}, CTMRGEnv}} where {T, S}","page":"Library","title":"MPSKit.expectation_value","text":"expectation_value(pf::InfinitePartitionFunction, inds => O, env::CTMRGEnv)\n\nCompute the expectation value corresponding to inserting a local tensor(s) O at position inds in the partition function pf and contracting the chole using a given CTMRG environment env.\n\nHere inds can be specified as either a Tuple{Int,Int} or a CartesianIndex{2}, and O should be a rank-4 tensor conforming to the PartitionFunctionTensor indexing convention.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, Any, Any}","page":"Library","title":"MPSKit.leading_boundary","text":"leading_boundary(\n    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [env]\n)\nleading_boundary(\n    st::MPSMulitline, op::Union{MultilineTransferPEPS,MultilineTransferPEPO}, alg, [env]\n)\n\nApproximate the leading boundary MPS eigenvector for the transfer operator op using st as initial guess.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{CTMRGEnv, InfiniteSquareNetwork}","page":"Library","title":"MPSKit.leading_boundary","text":"leading_boundary(env₀, network; kwargs...) -> env, info\n# expert version:\nleading_boundary(env₀, network, alg::CTMRGAlgorithm)\n\nContract network using CTMRG and return the CTM environment. The algorithm can be supplied via the keyword arguments or directly as an CTMRGAlgorithm struct.\n\nKeyword arguments\n\nCTMRG iterations\n\ntol::Real=1.0e-8 : Stopping criterium for the CTMRG iterations. This is the norm convergence, as well as the distance in singular values of the corners and edges.\nminiter::Int=4 : Minimal number of CTMRG iterations.\nmaxiter::Int=100 : Maximal number of CTMRG iterations.\nverbosity::Int=2 : Output verbosity level, should be one of the following:\nSuppress all output\nOnly print warnings\nInitialization and convergence info\nIteration info\nDebug info\nalg::Symbol=:simultaneous : Variant of the CTMRG algorithm. See also CTMRGAlgorithm.\n:simultaneous: Simultaneous expansion and renormalization of all sides.\n:sequential: Sequential application of left moves and rotations.\n\nProjector algorithm\n\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nsvd_alg::Union{<:SVDAdjoint,NamedTuple} : SVD algorithm for computing projectors. See also SVDAdjoint. By default, a reverse-rule tolerance of tol=1e1tol where the krylovdim is adapted to the env₀ environment dimension.\nprojector_alg::Symbol=:halfinfinite : Variant of the projector algorithm. See also ProjectorAlgorithm.\n:halfinfinite : Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.\n:fullinfinite : Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.\n\nReturn values\n\nThe CTMRG routine returns the final CTMRG environment as well as an information NamedTuple containing the following fields:\n\ntruncation_error : Last (maximal) SVD truncation error of the CTMRG projectors.\ncondition_number : Last (maximal) condition number of the enlarged CTMRG environment.\n\nIn case the alg is a SimultaneousCTMRG, the last SVD will also be returned:\n\nU : Last unit cell of left singular vectors.\nS : Last unit cell of singular values.\nV : Last unit cell of right singular vectors.\n\nIf, in addition, the specified SVD algorithm computes the full, untruncated SVD, the full set of vectors and values will be returned as well:\n\nU_full : Last unit cell of all left singular vectors.\nS_full : Last unit cell of all singular values.\nV_full : Last unit cell of all right singular vectors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.physicalspace-Tuple{LocalOperator}","page":"Library","title":"MPSKit.physicalspace","text":"physicalspace(O::LocalOperator)\n\nReturn lattice of physical spaces on which the LocalOperator is defined.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._apply_gate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S}, TensorKit.AbstractTensorMap{T, S}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.TruncationScheme}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._apply_gate","text":"_apply_gate(a, b, gate, trscheme)\n\n\nApply 2-site gate on the reduced matrices a, b\n\n    -1← a -← 3 -← b ← -4\n        ↓           ↓\n        1           2\n        ↓           ↓\n        |----gate---|\n        ↓           ↓\n        -2         -3\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._combine_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._combine_ab","text":"_combine_ab(a, b)\n\n\nContract the axis between a and b tensors\n\n    -- DX - a - D - b - DY --\n            ↓       ↓\n            da      db\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_corners-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_corners","text":"_contract_corners(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract all corners around the south-east at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_horizontal_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_horizontal_edges","text":"_contract_horizontal_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract the horizontal edges and corners around the south edge at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_site-Tuple{Tuple{Int64, Int64}, Any, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_site","text":"_contract_site(ind::Tuple{Int,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv)\n\nContract around a single site ind of a square network using a given CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_vertical_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_vertical_edges","text":"_contract_vertical_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract the vertical edges and corners around the east edge at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._dag-Union{Tuple{TensorKit.AbstractTensorMap{T, S, N, 1} where T}, Tuple{N}, Tuple{S}} where {S, N}","page":"Library","title":"PEPSKit._dag","text":"Adjoint of an MPS tensor, but permutes the physical spaces back into the codomain. Intuitively, this conjugates a tensor and then reinterprets its 'direction' as an MPS tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._fuse_ids-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, NTuple{N, S}}} where {T, S, N}","page":"Library","title":"PEPSKit._fuse_ids","text":"_fuse_ids(op, Ps)\n\n\nFuse identities on auxiliary physical spaces into a given operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._linearmap_twist!-Tuple{TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit._linearmap_twist!","text":"_linearmap_twist!(t)\n\n\nApply a twist to domain or codomain indices that correspond to dual spaces\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._mirror_antidiag_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._mirror_antidiag_site","text":"_mirror_antidiag_site(site, )\n\n\nGet the position of site after reflection about the anti-diagonal line.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._qr_bond-Tuple{TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._qr_bond","text":"_qr_bond(A, B)\n\n\nUse QR decomposition on two tensors connected by a bond to get the reduced tensors\n\n        2                   1\n        |                   |\n    5 - A ← 3   ====>   4 - X ← 2   1 ← a ← 3\n        | ↘                 |            ↘\n        4   1               3             2\n\n        2                               1\n        |                               |\n    5 ← B - 3   ====>   1 ← b → 3   4 → Y - 2\n        | ↘                  ↘          |\n        4   1                 2         3\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._qr_bond_undo-Tuple{TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit._qr_bond_undo","text":"_qr_bond_undo(X, a, b, Y)\n\n\nReconstruct the tensors connected by a bond from their QR results obtained from _qr_bond\n\n        -2                             -2\n        |                               |\n    -5- X - 1 - a - -3     -5 - b - 1 - Y - -3\n        |        ↘               ↘      |\n        -4        -1              -1   -4\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rot180_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._rot180_site","text":"_rot180_site(site, )\n\n\nGet the position of site after rotation by 180 degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rotl90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._rotl90_site","text":"_rotl90_site(site, )\n\n\nGet the position of site after counter-clockwise (left) rotation by 90 degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rotr90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._rotr90_site","text":"_rotr90_site(site, )\n\n\nGet the position of site after clockwise (right) rotation by 90 degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}","page":"Library","title":"PEPSKit._rrule","text":"_rrule(alg_rrule, config, f, args...; kwargs...) -> ∂f, ∂args...\n\nCustomize the pullback of a function f. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nwarning: Warning\nNo tangent is expected for the alg_rrule argument\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._singular_value_distance-Tuple{Any}","page":"Library","title":"PEPSKit._singular_value_distance","text":"_singular_value_distance((S₁, S₂))\n\nCompute the singular value distance as an error measure, e.g. for CTMRG iterations. To that end, the singular values of the current iteration S₁ are compared with the previous one S₂. When the virtual spaces change, this comparison is not directly possible such that both tensors are projected into the smaller space and then subtracted.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._solve_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._solve_ab","text":"_solve_ab(Rx, Sx, x0)\n\n\nSolve the equations Rx x = Sx (x = a, b) with initial guess x0\n\n    ┌---------------------------┐\n    |   ┌----┐                  |\n    └---|    |--- 1 -- x -- 2 --┘\n        |    |         ↓\n        | Rx |        -3\n        |    |\n    ┌---|    |--- -1       -2 --┐\n    |   └----┘                  |\n    └---------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._su_bondx!-Union{Tuple{S}, Tuple{T}, Tuple{Int64, Int64, TensorKit.AbstractTensorMap{T, S, 2, 2}, InfiniteWeightPEPS, SimpleUpdate}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._su_bondx!","text":"_su_bondx!(row, col, gate, peps, alg)\n\n\nSimple update of the x-bond peps.weights[1,r,c].\n\n                [2,r,c]             [2,r,c+1]\n                ↓                   ↓\n    [1,r,c-1] ← T[r,c] ← [1,r,c] ←- T[r,c+1] ← [1,r,c+1]\n                ↓                   ↓\n                [2,r+1,c]           [2,r+1,c+1]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Ra-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Ra","text":"_tensor_Ra(benv, b)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0     Db0 - b -- DY0 -┘\n        |    |                ↓\n        |benv|                db\n        |    |                ↓\n    ┌---|    |- DX1     Db1 - b† - DY1 -┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Rb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Rb","text":"_tensor_Rb(benv, a)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 - a -- Da0     DY0 -┘\n        |    |        ↓\n        |benv|        da\n        |    |        ↓\n    ┌---|    |- DX1 - a† - Da1     DY1 -┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Sa-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Sa","text":"_tensor_Sa(benv, b, a2b2)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 -- (a2 b2) -- DY0 --┘\n        |    |         ↓     ↓\n        |benv|         da    db\n        |    |               ↓\n    ┌---|    |- DX1   Db1 -- b† - DY1 --┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Sb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Sb","text":"_tensor_Sb(benv, a, a2b2)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 -- (a2 b2) -- DY0 --┘\n        |    |         ↓     ↓\n        |benv|         da    db\n        |    |         ↓\n    ┌---|    |- DX1 -- a† - Da1   DY1 --┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_s-Tuple{TensorKit.AbstractTensorMap, TensorKit.DiagonalTensorMap, TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit.absorb_s","text":"absorb_s(U::AbstractTensorMap, S::DiagonalTensorMap, V::AbstractTensorMap)\n\nGiven tsvd result U, S and V, absorb singular values S into U and V by:\n\n    U -> U * sqrt(S), V -> sqrt(S) * V\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_weight-Tuple{TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace, Int64, Int64, Int64, SUWeight}","page":"Library","title":"PEPSKit.absorb_weight","text":"absorb_weight(t::PEPSTensor, row::Int, col::Int, ax::Int, weights::SUWeight; sqrtwt::Bool=false, invwt::Bool=false)\n\nAbsorb or remove environment weight on an axis of vertex tensor t  known to be located at position (row, col) in the unit cell. Weights around the tensor at (row, col) are\n\n                    ↓\n                [2,r,c]\n                    ↓\n    ← [1,r,c-1] ← T[r,c] ← [1,r,c] ←\n                    ↓\n                [1,r+1,c]\n                    ↓\n\nArguments\n\nt::T : The vertex tensor to which the weight will be absorbed. The first axis of t should be the physical axis. \nrow::Int : The row index specifying the position in the tensor network.\ncol::Int : The column index specifying the position in the tensor network.\nax::Int : The axis into which the weight is absorbed, taking values from 1 to 4, standing for north, east, south, west respectively.\nweights::SUWeight : The weight object to absorb into the tensor.\n\nKeyword arguments\n\nsqrtwt::Bool=false : If true, the square root of the weight is absorbed.\ninvwt::Bool=false : If true, the inverse of the weight is absorbed.\n\nExamples\n\n# Absorb the weight into the north axis of tensor at position (2, 3)\nabsorb_weight(t, 2, 3, 1, weights)\n\n# Absorb the square root of the weight into the south axis\nabsorb_weight(t, 2, 3, 3, weights; sqrtwt=true)\n\n# Absorb the inverse of (i.e. remove) the weight into the east axis\nabsorb_weight(t, 2, 3, 2, weights; invwt=true)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.bond_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, ALSTruncation}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.bond_truncate","text":"bond_truncate(a::AbstractTensorMap{T,S,2,1}, b::AbstractTensorMap{T,S,1,2}, benv::BondEnv{T,S}, alg) -> U, S, V, info\n\nAfter time-evolving the reduced tensors a and b connected by a bond,  truncate the bond dimension using the bond environment tensor benv.\n\n    ┌-----------------------┐\n    |   ┌----┐              |\n    └---|    |-- a === b ---┘\n        |benv|   ↓     ↓\n    ┌---|    |-- a† == b† --┐\n    |   └----┘              |\n    └-----------------------┘\n\nThe truncation algorithm alg can be either FullEnvTruncation or ALSTruncation.  The index order of a or b is\n\n    1 -a/b- 3\n        ↓       a[1 2; 3]\n        2       b[1; 2 3]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_convergence-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.calc_convergence","text":"calc_convergence(env, CS_old, TS_old)\ncalc_convergence(env_new, env_old)\n\nGiven a new environment env, compute the maximal singular value distance. This determined either from the previous corner and edge singular values CS_old and TS_old, or alternatively, directly from the old environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}","page":"Library","title":"PEPSKit.calc_elementwise_convergence","text":"calc_elementwise_convergence(envfinal, envfix; atol=1e-6)\n\nCheck if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below atol and return the maximal difference.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.checklattice-Tuple","page":"Library","title":"PEPSKit.checklattice","text":"checklattice(Bool, args...)\nchecklattice(args...)\n\nHelper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.compute_projector-Tuple{Any, Any, HalfInfiniteProjector}","page":"Library","title":"PEPSKit.compute_projector","text":"compute_projector(enlarged_corners, coordinate, alg::ProjectorAlgorithm)\n\nDetermine left and right projectors at the bond given determined by the enlarged corners and the given coordinate using the specified alg.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_norm-Union{Tuple{N}, Tuple{NTuple{N, CartesianIndex{2}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N","page":"Library","title":"PEPSKit.contract_local_norm","text":"contract_local_norm(inds, ket, bra, env)\n\n\nContract a local norm of the PEPS peps around indices inds.\n\nThis works analogously to contract_local_operator by generating the contraction on a rectangular patch based on inds but replacing the operator with an identity such that the PEPS norm is computed. (Note that this is not the physical norm of the state.)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_operator-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{T, S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {T, S, N}","page":"Library","title":"PEPSKit.contract_local_operator","text":"contract_local_operator(inds, O, ket, bra, env)\n\n\nContract a local operator O on the PEPS peps at the indices inds using the environment env.\n\nThis works by generating the appropriate contraction on a rectangular patch with its corners specified by inds. The peps is contracted with O from above and below, and the PEPS-operator sandwich is surrounded with the appropriate environment tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_tensor-Tuple{Tuple{Int64, Int64, Int64}, TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace, InfiniteSquareNetwork{<:Tuple{T, T, Vararg{P, N}} where {N, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), P<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}}, CTMRGEnv}","page":"Library","title":"PEPSKit.contract_local_tensor","text":"contract_local_tensor(inds, O::PEPOTensor, network, env)\n\nContract a local tensor O inserted into the PEPO of a given network at position inds, using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_tensor-Union{Tuple{C}, Tuple{Tuple{Int64, Int64}, TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace, CTMRGEnv{C, <:TensorKit.AbstractTensorMap{T, S, 2, 1} where {T, S}}}} where C","page":"Library","title":"PEPSKit.contract_local_tensor","text":"contract_local_tensor(inds, O::PFTensor, env)\n\nContract a local tensor O inserted into a partition function pf at position inds, using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_projectors-NTuple{5, Any}","page":"Library","title":"PEPSKit.contract_projectors","text":"contract_projectors(U, S, V, Q, Q_next)\n\n\nCompute projectors based on a SVD of Q * Q_next, where the inverse square root isqS of the singular values is computed.\n\nLeft projector:\n\n    -- |~~~~~~| -- |~~|\n       |Q_next|    |V'| -- isqS --\n    == |~~~~~~| == |~~|\n\nRight projector:\n\n               |~~| -- |~~~| --\n    -- isqS -- |U'|    | Q |\n               |~~| == |~~~| ==\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.cost_function-Tuple{InfinitePEPS, CTMRGEnv, LocalOperator}","page":"Library","title":"PEPSKit.cost_function","text":"cost_function(peps::InfinitePEPS, env::CTMRGEnv, O::LocalOperator)\n\nReal part of expectation value of O. Prints a warning if the expectation value yields a finite imaginary part (up to a tolerance).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.cost_function_als-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.cost_function_als","text":"cost_function_als(benv, a1b1, a2b2)\n\n\nCalculate the cost function\n\n    f(a,b)  = ‖ |a1,b1⟩ - |a2,b2⟩ ‖^2\n    = ⟨a1,b1|a1,b1⟩ - 2 Re⟨a1,b1|a2,b2⟩ + ⟨a2,b2|a2,b2⟩\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_iteration-Tuple{Any, Any, PEPSKit.CTMRGAlgorithm}","page":"Library","title":"PEPSKit.ctmrg_iteration","text":"ctmrg_iteration(network, env, alg::CTMRGAlgorithm) -> env′, info\n\nPerform a single CTMRG iteration in which all directions are being grown and renormalized.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_leftmove-Tuple{Int64, Any, CTMRGEnv, SequentialCTMRG}","page":"Library","title":"PEPSKit.ctmrg_leftmove","text":"ctmrg_leftmove(col::Int, network, env::CTMRGEnv, alg::SequentialCTMRG)\n\nPerform sequential CTMRG left move on the col-th column.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.dtmap-Tuple","page":"Library","title":"PEPSKit.dtmap","text":"dtmap(args...; kwargs...)\n\nDifferentiable wrapper around [OhMyThreads.tmap].\n\nAll calls of dtmap inside of PEPSKit use the threading scheduler stored inside Defaults.scheduler which can be modified using set_scheduler!.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.eachcoordinate","page":"Library","title":"PEPSKit.eachcoordinate","text":"eachcoordinate(x, [dirs=1:4])\n\nEnumerate all (dir, row, col) pairs.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_northeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_northeast_corner","text":"enlarge_northeast_corner(E_north, C_northeast, E_east, A)\n\n\nContract the enlarged northeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n    -- E_north -- C_northeast\n          |             |\n    --    A    --    E_east\n          |             |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_northwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_northwest_corner","text":"enlarge_northwest_corner(E_west, C_northwest, E_north, A)\n\n\nContract the enlarged northwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n    C_northwest -- E_north --\n         |            |\n      E_west    --    A    --\n         |            |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_southeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_southeast_corner","text":"enlarge_southeast_corner(E_east, C_southeast, E_south, A)\n\n\nContract the enlarged southeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n          |             |\n    --    A    --    E_east\n          |             |\n    -- E_south -- C_southeast\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_southwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_southwest_corner","text":"enlarge_southwest_corner(E_south, C_southwest, E_west, A)\n\n\nContract the enlarged southwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n          |           |       \n       E_west   --    A    --\n          |           |       \n    C_southwest -- E_south -- \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fidelity","text":"fidelity(benv, b1, b2)\n\n\nGiven the bond environment benv, calculate the fidelity between two states specified by the bond matrices b1, b2\n\n    F(b1, b2) = (⟨b1|b2⟩ ⟨b2|b1⟩) / (⟨b1|b1⟩ ⟨b2|b2⟩)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fidelity","text":"fidelity(benv, a1b1, a2b2)\n\n\nCalculate the fidelity between two evolution steps\n\n        |⟨a1,b1|a2,b2⟩|^2\n    --------------------------\n    ⟨a1,b1|a1,b1⟩⟨a2,b2|a2,b2⟩\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}","page":"Library","title":"PEPSKit.fix_gauge_corner","text":"fix_gauge_corner(corner, σ_in, σ_out)\n\n\nMultiply corner tensor with incoming and outgoing gauge signs.\n\n    corner -- σ_out --\n      |  \n     σ_in\n      |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_edge","text":"fix_gauge_east_edge(, env, signs)\n\n\nApply fix_gauge_edge to the east edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_left_vecs","text":"fix_gauge_east_left_vecs(, U, signs)\n\n\nMultiply east left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_right_vecs","text":"fix_gauge_east_right_vecs(, V, signs)\n\n\nMultiply east right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_edge-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}} where {T, S, N}","page":"Library","title":"PEPSKit.fix_gauge_edge","text":"fix_gauge_edge(edge, σ_in, σ_out)\n\n\nMultiply edge tensor with incoming and outgoing gauge signs.\n\n    -- σ_in -- edge -- σ_out --\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_edge","text":"fix_gauge_north_edge(, env, signs)\n\n\nApply fix_gauge_edge to the north edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_left_vecs","text":"fix_gauge_north_left_vecs(, U, signs)\n\n\nMultiply north left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_right_vecs","text":"fix_gauge_north_right_vecs(, V, signs)\n\n\nMultiply north right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northeast_corner","text":"fix_gauge_northeast_corner(, env, signs)\n\n\nApply fix_gauge_corner to the northeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northwest_corner","text":"fix_gauge_northwest_corner(, env, signs)\n\n\nApply fix_gauge_corner to the northwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_edge","text":"fix_gauge_south_edge(, env, signs)\n\n\nApply fix_gauge_edge to the south edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_left_vecs","text":"fix_gauge_south_left_vecs(, U, signs)\n\n\nMultiply south left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_right_vecs","text":"fix_gauge_south_right_vecs(, V, signs)\n\n\nMultiply south right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southeast_corner","text":"fix_gauge_southeast_corner(, env, signs)\n\n\nApply fix_gauge_corner to the southeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southwest_corner","text":"fix_gauge_southwest_corner(, env, signs)\n\n\nApply fix_gauge_corner to the southwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_edge","text":"fix_gauge_west_edge(, env, signs)\n\n\nApply fix_gauge_edge to the west edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_left_vecs","text":"fix_gauge_west_left_vecs(, U, signs)\n\n\nMultiply west left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_right_vecs","text":"fix_gauge_west_right_vecs(, V, signs)\n\n\nMultiply west right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_global_phases-Tuple{CTMRGEnv, CTMRGEnv}","page":"Library","title":"PEPSKit.fix_global_phases","text":"fix_global_phases(envprev, envfix)\n\n\nFix global multiplicative phase of the environment tensors. To that end, the dot products between all corners and all edges are computed to obtain the global phase which is then divided out.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fixedpoint-Tuple{Any, InfinitePEPS, CTMRGEnv}","page":"Library","title":"PEPSKit.fixedpoint","text":"fixedpoint(operator, peps₀::InfinitePEPS, env₀::CTMRGEnv; kwargs...) -> peps_final, env_final, cost_final, info\n# expert version:\nfixedpoint(operator, peps₀::InfinitePEPS, env₀::CTMRGEnv, alg::PEPSOptimize; finalize!=OptimKit._finalize!)\n\nFind the fixed point of operator (i.e. the ground state) starting from peps₀ according to the supplied optimization parameters. The initial environment env₀ serves as an initial guess for the first CTMRG run. By default, a random initial environment is used.\n\nThe optimization parameters can be supplied via the keyword arguments or directly as a PEPSOptimize struct. The following keyword arguments are supported:\n\nKeyword arguments\n\nGeneral settings\n\ntol::Real=0.0001 : Overall tolerance for gradient norm convergence of the optimizer. Sets related tolerance such as the boundary and boundary-gradient tolerances to sensible defaults unless they are explictly specified.\nverbosity::Int=1 : Overall output information verbosity level, should be one of the following:\nSuppress all output\nOnly print warnings\nInitialization and convergence info\nIteration info\nDebug info including AD outputs\nreuse_env::Bool=true : If true, the current optimization step is initialized on the previous environment, otherwise a random environment is used.\nsymmetrization::Union{Nothing,SymmetrizationStyle}=nothing : Accepts nothing or a SymmetrizationStyle, in which case the PEPS and PEPS gradient are symmetrized after each optimization iteration.\n(finalize!)=OptimKit._finalize! : Inserts a finalize! function call after each optimization step by utilizing the finalize! kwarg of OptimKit.optimize. The function maps (peps, env), f, g = finalize!((peps, env), f, g, numiter).\n\nBoundary algorithm\n\nSupply boundary algorithm parameters via boundary_alg::Union{NamedTuple,<:CTMRGAlgorithm} using either a NamedTuple of keyword arguments or a CTMRGAlgorithm directly. See leading_boundary for a description of all possible keyword arguments. By default, a CTMRG tolerance of tol=1e-4tol and is used.\n\nGradient algorithm\n\nSupply gradient algorithm parameters via gradient_alg::Union{NamedTuple,Nothing,<:GradMode} using either a NamedTuple of keyword arguments, nothing, or a GradMode struct directly. Pass nothing to fully differentiate the CTMRG run, meaning that all iterations will be taken into account, instead of differentiating the fixed point. The supported NamedTuple keyword arguments are:\n\ntol::Real=1e-2tol : Convergence tolerance for the fixed-point gradient iteration.\nmaxiter::Int=30 : Maximal number of gradient problem iterations.\nalg::Symbol=:linsolver : Gradient algorithm variant, can be one of the following:\n:geomsum : Compute gradient directly from the geometric sum, see GeomSum\n:manualiter : Iterate gradient geometric sum manually, see ManualIter\n:linsolver : Solve fixed-point gradient linear problem using iterative solver, see LinSolver\n:eigsolver : Determine gradient via eigenvalue formulation of its Sylvester equation, see EigSolver\nverbosity::Int : Gradient output verbosity, ≤0 by default to disable too verbose printing. Should only be >0 for debug purposes.\niterscheme::Symbol=:fixed : CTMRG iteration scheme determining mode of differentiation. This can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\nOptimizer settings\n\nSupply the optimizer algorithm via optimizer_alg::Union{NamedTuple,<:OptimKit.OptimizationAlgorithm} using either a NamedTuple of keyword arguments or a OptimKit.OptimizationAlgorithm directly. By default, OptimKit.LBFGS is used in combination with a HagerZhangLineSearch. The supported keyword arguments are:\n\nalg::Symbol=:lbfgs : Optimizer algorithm, can be one of the following:\n:gradientdescent : Gradient descent algorithm, see the OptimKit README\n:conjugategradient : Conjugate gradient algorithm, see the OptimKit README\n:lbfgs : L-BFGS algorithm, see the OptimKit README\ntol::Real=tol : Gradient norm tolerance of the optimizer.\nmaxiter::Int=100 : Maximal number of optimization steps.\nverbosity::Int=3 : Optimizer output verbosity.\nlbfgs_memory::Int=20 : Size of limited memory representation of BFGS Hessian matrix.\n\nReturn values\n\nThe function returns the final PEPS, CTMRG environment and cost value, as well as an information NamedTuple which contains the following entries:\n\nlast_gradient : Last gradient of the cost function.\nfg_evaluations : Number of evaluations of the cost and gradient function.\ncosts : History of cost values.\ngradnorms : History of gradient norms.\ntruncation_errors : History of maximal truncation errors of the boundary algorithm.\ncondition_numbers : History of maximal condition numbers of the CTMRG environments.\ngradnorms_unitcell : History of gradient norms for each respective unit cell entry.\ntimes : History of optimization step execution times.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fpgrad","page":"Library","title":"PEPSKit.fpgrad","text":"fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)\n\nCompute the gradient of the CTMRG fixed point by solving the following equation:\n\ndx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA\n\nwhere ∂F∂x is the gradient of the cost function with respect to the PEPS tensors, ∂f∂x is the partial gradient of the CTMRG iteration with respect to the environment tensors, ∂f∂A is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and y0 is the initial guess for the fixed-point iteration. The function returns the gradient dx of the fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.full_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, NTuple{4, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}","page":"Library","title":"PEPSKit.full_infinite_environment","text":"full_infinite_environment(quadrant1, quadrant2, quadrant3, quadrant4)\nfull_infinite_environment(half1, half2)\nfull_infinite_environment(C_1, C_2, C_3, C_4, E_1, E_2, E_3, E_4, E_5, E_6, E_7, E_8, A_1, A_2, A_3, A_4)\nfull_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x, A_1, A_2, A_3, A_4)\nfull_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2, A_3, A_4)\n\nContract four quadrants (enlarged corners) to form a full-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n      |     |        |     |\n                     |     |\n      |     |        |     |\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant4|    |quadrant3|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n\nIn the same manner two halfs can be used to contract the full-infinite environment.\n\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n    |         half1          |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n      |     |        |     |\n                     |     |\n      |     |        |     |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n    |         half2          |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n\nThe environment can also be contracted directly from all its constituent tensors.\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      | \n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n                   |      |\n     |      |      |      |\n    E_8 -- A_4 -- A_3 -- E_5\n     |      |      |      |\n    C_4 -- E_7 -- E_6 -- C_3\n\nAlternatively, contract the environment with a vector x acting on it\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      | \n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n                   |      |\n    [~~~~x~~~]     |      |\n     |      |      |      |\n    E_8 -- A_4 -- A_3 -- E_5\n     |      |      |      |\n    C_4 -- E_7 -- E_6 -- C_3\n\n\nor contract the adjoint environment with x, e.g. as needed for iterative solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fullenv_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}, FullEnvTruncation}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fullenv_truncate","text":"fullenv_truncate(benv::BondEnv{T,S}, b0::AbstractTensorMap{T,S,1,1}, alg::FullEnvTruncation) -> U, S, V, info\n\nPerform full environment truncation algorithm from Phys. Rev. B 98, 085155 (2018) on benv.\n\nGiven a fixed state |b0⟩ with bond matrix b0 and the corresponding positive-definite bond environment benv,  find the state |b⟩ with truncated bond matrix b = u s v† that maximizes the fidelity (not normalized by ⟨b0|b0⟩)\n\n    F(b) = ⟨b|b0⟩⟨b0|b⟩ / ⟨b|b⟩\n\n            ┌----------------------┐  ┌-----------------------┐\n            |   ┌----┐             |  |   ┌----┐              |\n            └---|    |---- b0 -----┘  └---|    |- u ← s ← v† -┘\n                |benv|                    |benv|\n            ┌---|    |-u† → s → v -┐  ┌---|    |----- b0† ----┐\n            |   └----┘             |  |   └----┘              |\n            └----------------------┘  └-----------------------┘\n        = ───────────────────────────────────────────────────────\n                        ┌-----------------------┐\n                        |   ┌----┐              |\n                        └---|    |- u ← s ← v† -┘\n                            |benv|\n                        ┌---|    |- u† → s → v -┐\n                        |   └----┘              |\n                        └-----------------------┘\n\nThe singular value spectrum s is truncated to desired dimension,  and normalized such that the maximum is 1. Note that benv is contracted to b0 using @tensor,  instead of acting on b0 as a linear map.\n\nThe algorithm iteratively optimizes the vectors l, r\n\n    --- l -←-  =  --- u ← s -←-  ,  -←- r ---  =  -←- s ← v† ---\n\nOptimization of r\n\nDefine the vector p and the positive map B as\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-←   --┘   └---|    |- u ←      ---┘\n            | p†|         =     |benv|\n        ┌---|   |-------┐   ┌---|    |----- b0† ----┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-←   --┘   └---|    |- u ←      ---┘\n            | B |         =     |benv|\n        ┌---|   |-→   --┐   ┌---|    |- u†→      ---┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\nThen (each index corresponds to a pair of fused indices)\n\n    F(r,r†) = |p† r|² / (r† B r)\n            = (r† p) (p† r) / (r† B r)\n\nwhich is maximized when\n\n    ∂F/∂r̄ * (r† B r)²\n    = p (p† r) (r† B r) - |p† r|² (B r) = 0\n\nNote that B is positive (consequently B† = B).  Then the solution for the vector r is\n\n    r = B⁻¹ p\n\nWe can verify that (using B† = B)\n\n    ∂F/∂r̄ * (r† B r)²\n    = p (p† B⁻¹ p) (p† B⁻¹ B B⁻¹ p) - |p† B⁻¹ p|² (B B⁻¹ p) \n    = 0\n\nThen the bond matrix u s v† is updated by truncated SVD:\n\n    - u ← r -    ==>    - u ← s ← v† -\n\nOptimization of l\n\nThe process is entirely similar.  Define the vector p and the positive map B as\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-  ←-o-┘   └---|    |--   ←-o- v† -┘\n            | p†|         =     |benv|\n        ┌---|   |-------┐   ┌---|    |----- b0† ----┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-  ←-o-┘   └---|    |--    ←-o- v†-┘\n            | B |         =     |benv|\n        ┌---|   |-  →-o-┐   ┌---|    |--    →-o- v -┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\nHere o is the parity tensor (twist) necessary for fermions.  Then (each index corresponds to a pair of fused indices)\n\n    F(l,l†) = |p† l|² / (l† B l)\n\nwhich is maximized when\n\n    l = B⁻¹ p\n\nThen the bond matrix u s v† is updated by SVD:\n\n    - l ← v† -   ==>    - u ← s ← v† -\n\nReturn values\n\nReturns the SVD result of the new bond matrix U, S, V, as well as an information NamedTuple containing the following fields:\n\nfid : Last fidelity.\nΔfid : Last fidelity difference.\nΔs : Last singular value difference.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(envprev, envfinal)\n\n\nFix the gauge of envfinal based on the previous environment envprev. This assumes that the envfinal is the result of one CTMRG iteration on envprev. Given that the CTMRG run is converged, the returned environment will be element-wise converged to envprev.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_gate-Tuple{Float64, LocalOperator}","page":"Library","title":"PEPSKit.get_gate","text":"get_gate(dt::Float64, H::LocalOperator)\n\nCompute exp(-dt * H) from the nearest neighbor Hamiltonian H.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_gateterm-Tuple{LocalOperator, Tuple{CartesianIndex{2}, CartesianIndex{2}}}","page":"Library","title":"PEPSKit.get_gateterm","text":"get_gateterm(gate::LocalOperator, bond::NTuple{2,CartesianIndex{2}})\n\nGet the term of a 2-site gate acting on a certain bond. Input gate should only include one term for each nearest neighbor bond.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.half_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}","page":"Library","title":"PEPSKit.half_infinite_environment","text":"half_infinite_environment(quadrant1, quadrant2)\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2)\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x, A_1, A_2)\nhalf_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2)\n\nContract two quadrants (enlarged corners) to form a half-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n      |     |        |     |\n\nThe environment can also be contracted directly from all its constituent tensors.\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      | \n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n\nAlternatively, contract the environment with a vector x acting on it\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      | \n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n                  [~~~x~~~~]\n\nor contract the adjoint environment with x, e.g. as needed for iterative solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}","page":"Library","title":"PEPSKit.hook_pullback","text":"hook_pullback(f, args...; alg_rrule=nothing, kwargs...)\n\nWrapper function to customize the pullback of a function f. This function is equivalent to f(args...; kwargs...), but the pullback can be customized by implementing the following function:\n\n_rrule(alg_rrule, config, f, args...; kwargs...) -> NoTangent(), ∂f, ∂args...\n\nThis function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nSee also _rrule.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.initialize_mps-Tuple{Union{MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), O<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}, MPSKit.MultilineMPO{<:MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), O<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}}}, Any}","page":"Library","title":"PEPSKit.initialize_mps","text":"initialize_mps(\n    f=randn,\n    T=scalartype(O),\n    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,1}\n)\ninitialize_mps(\n    f=randn,\n    T=scalartype(O),\n    O::Union{MultilineTransferPEPS,MultilineTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,2}\n)\n\nInialize a boundary MPS for the transfer operator O by specifying an array of virtual spaces consistent with the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.inner_prod","text":"inner_prod(benv, b1, b2)\n\n\nGiven the bond environment benv, calculate the inner product between two states specified by the bond matrices b1, b2\n\n            ┌--------------------┐\n            |   ┌----┐           |\n            └---|    |---- b2 ---┘\n    ⟨b1|b2⟩ =   |benv|\n            ┌---|    |---- b1†---┐\n            |   └----┘           |\n            └--------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.inner_prod","text":"inner_prod(benv, a1b1, a2b2)\n\n\nCalculate the inner product <a1,b1|a2,b2>\n\n    ┌--------------------------------┐\n    |   ┌----┐                       |\n    └---|    |- DX0 - (a2 b2) - DY0 -┘\n        |    |        ↓    ↓\n        |benv|        da   db\n        |    |        ↓    ↓\n    ┌---|    |- DX1 - (a1 b1)†- DY1 -┐\n    |   └----┘                       |\n    └--------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.is_equivalent-Tuple{Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{Int64, Int64}}","page":"Library","title":"PEPSKit.is_equivalent","text":"is_equivalent(\n    bond1::NTuple{2,CartesianIndex{2}},\n    bond2::NTuple{2,CartesianIndex{2}},\n    (Nrow, Ncol)::NTuple{2,Int},\n)\n\nCheck if two 2-site bonds are related by a (periodic) lattice translation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.j1_j2_model-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.j1_j2_model","text":"j1_j2_model([elt::Type{T}, symm::Type{S},] lattice::InfiniteSquare;\n            J1=1.0, J2=1.0, spin=1//2, sublattice=true)\n\nSquare lattice J_1text-J_2 model, defined by the Hamiltonian\n\nH = J_1 sum_langle ij rangle vecS_i cdot vecS_j\n+ J_2 sum_langlelangle ij ranglerangle vecS_i cdot vecS_j\n\nwhere vecS_i = (S_i^x S_i^y S_i^z). We denote the nearest and next-nearest neighbor terms using langle ij rangle and langlelangle ij ranglerangle, respectively. The sublattice kwarg enables a single-site unit cell ground state via a unitary sublattice rotation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.left_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.left_projector","text":"left_projector(E_1, C, E_2, V, isqS, A)\n\n\nContract the CTMRG left projector with the higher-dimensional subspace facing to the left.\n\n     C  --  E_2    -- |~~|\n     |       |        |V'| -- isqS --\n    E_1 --   A     -- |~~|\n     |       |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.mirror_antidiag-Tuple{AbstractMatrix}","page":"Library","title":"PEPSKit.mirror_antidiag","text":"mirror_antidiag(arr::AbstractMatrix)\n\nMirror a matrix by its anti-diagonal line (the 45 degree line through the lower-left corner).\n\nThe element originally at [r, c] is moved [Nc-c+1, Nr-r+1], i.e. the element now at [r, c] was originally at [Nr-c+1, Nc-r+1]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.mirror_antidiag-Tuple{InfiniteWeightPEPS}","page":"Library","title":"PEPSKit.mirror_antidiag","text":"mirror_antidiag(peps::InfiniteWeightPEPS)\n\nMirror the unit cell of an iPEPS with weights by its anti-diagonal line.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.mirror_antidiag-Tuple{LocalOperator}","page":"Library","title":"PEPSKit.mirror_antidiag","text":"mirror_antidiag(H::LocalOperator)\n\nMirror a LocalOperator across the anti-diagonal axis of its lattice.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.nearest_neighbour_hamiltonian-Union{Tuple{T}, Tuple{S}, Tuple{Matrix{S}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {S, T}","page":"Library","title":"PEPSKit.nearest_neighbour_hamiltonian","text":"nearest_neighbour_hamiltonian(lattice::Matrix{S}, h::AbstractTensorMap{T,S,2,2}) where {S,T}\n\nCreate a nearest neighbor LocalOperator by specifying the 2-site interaction term h which acts both in horizontal and vertical direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.network_value-Tuple{InfiniteSquareNetwork, CTMRGEnv}","page":"Library","title":"PEPSKit.network_value","text":"network_value(network::InfiniteSquareNetwork, env::CTMRGEnv)\n\nReturn the value (per unit cell) of a given contractible network contracted using a given CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.norm_preserving_retract-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.norm_preserving_retract","text":"norm_preserving_retract(A, η, α)\n\n\nPerforms a norm-preserving retraction of vector A along the direction η with step size α, giving a new vector A´,\n\nA  cos ( α η  A ) A + sin ( α η  A ) A η  η\n\nand corresponding directional derivative ξ,\n\nξ = cos ( α η  A ) η - sin ( α η  A ) η A  A\n\nsuch that  A ξ  = 0 and A = A.\n\nnote: Note\nThe vectors A and η should satisfy the interface specified by VectorInterface.jl\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.norm_preserving_transport!-NTuple{5, Any}","page":"Library","title":"PEPSKit.norm_preserving_transport!","text":"norm_preserving_transport!(ξ, A, η, α, A´)\n\n\nTransports a direction ξ at A to a valid direction at A´ corresponding to the norm-preserving retraction of A along η with step size α. In particular, starting from a direction η of the form\n\nξ =  η  η ξ  η  η + Δξ\n\nwhere  Δξ A  =  Δξ η  = 0, it returns\n\nξ(α) =  η  η ξ  ( cos ( α η  A ) η  η - sin ( α η  A ) A  A ) + Δξ\n\nsuch that ξ(α) = ξ  A ξ(α)  = 0.\n\nnote: Note\nThe vectors A and η should satisfy the interface specified by VectorInterface.jl\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.peps_normalize-Tuple{InfinitePEPS}","page":"Library","title":"PEPSKit.peps_normalize","text":"peps_normalize(A::InfinitePEPS)\n\nNormalize the individual tensors in the unit cell of an InfinitePEPS such that they each have unit Euclidean norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.peps_retract-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.peps_retract","text":"peps_retract(x, η, α)\n\n\nPerforms a norm-preserving retraction of an infinite PEPS A = x[1] along η with step size α, giving a new PEPS A´,\n\nA  cos ( α η  A ) A + sin ( α η  A ) A η  η\n\nand corresponding directional derivative ξ,\n\nξ = cos ( α η  A ) η - sin ( α η  A ) η A  A\n\nsuch that  A ξ  = 0 and A = A.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.peps_transport!-NTuple{5, Any}","page":"Library","title":"PEPSKit.peps_transport!","text":"peps_transport!(ξ, x, η, α, x´)\n\n\nTransports a direction at A = x[1] to a valid direction at A´ = x´[1] corresponding to the norm-preserving retraction of A along η with step size α. In particular, starting from a direction η of the form\n\nξ =  η  η ξ  η  η + Δξ\n\nwhere  Δξ A  =  Δξ η  = 0, it returns\n\nξ(α) =  η  η ξ  ( cos ( α η  A ) η  η - sin( α η  A ) A  A ) + Δξ\n\nsuch that ξ(α) = ξ  A ξ(α)  = 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.product_peps-Tuple","page":"Library","title":"PEPSKit.product_peps","text":"product_peps(peps_args...; unitcell=(1, 1), noise_amp=1e-2, state_vector=nothing)\n\nInitialize a normalized random product PEPS with noise. The given arguments are passed on to the InfinitePEPS constructor.\n\nThe noise intensity can be tuned with noise_amp. The product state coefficients can be specified using the state_vector kwarg in the form of a matrix of size unitcell containing vectors that match the PEPS physical dimensions. If nothing is provided, random Gaussian coefficients are used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.pwave_superconductor-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.pwave_superconductor","text":"pwave_superconductor([T=ComplexF64,] lattice::InfiniteSquare; t=1, μ=2, Δ=1)\n\nSquare lattice p-wave superconductor model, defined by the Hamiltonian\n\n    H = -sum_langle ij rangle left( t c_i^dagger c_j +\n    Delta c_i c_j + texthc right) - mu sum_i n_i\n\nwhere t is the hopping amplitude, Delta specifies the superconducting gap, mu is the chemical potential, and n_i = c_i^dagger c_i is the fermionic number operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_bottom_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_bottom_corner","text":"renormalize_bottom_corner((r, c), env, projectors)\nrenormalize_bottom_corner(C_southwest, E_south, P_bottom)\n\nApply bottom projector to southwest corner and south edge.\n\n        | \n    [P_bottom]\n     |     |\n     C --  E -- in\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_corner-Union{Tuple{N}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, N, N}, TensorKit.AbstractTensorMap{<:Any, S, N, 1}, TensorKit.AbstractTensorMap{<:Any, S, 1, N}}} where {S, N}","page":"Library","title":"PEPSKit.renormalize_corner","text":"renormalize_corner(quadrant, P_left, P_right)\n\n\nApply projectors to each side of a quadrant.\n\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --\n    |~~~~~~~~| -- |~~~~~~|\n     |     |\n    [P_right]\n        |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_east_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_east_edge","text":"renormalize_east_edge((row, col), env, P_top, P_bottom, network::InfiniteSquareNetwork{P})\nrenormalize_east_edge(E_east, P_top, P_bottom, A::P)\n\nAbsorb a blocal effective tensor into the east edge using the given projectors and environment tensors.\n\n           |\n     [~P_bottom~]\n      |        |\n    E_east --  A -- \n      |        |\n     [~~P_top~~~]\n           |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_north_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_north_edge","text":"renormalize_north_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_north_edge(E_north, P_left, P_right, A::P)\n\nAbsorb a local effective tensor A into the north edge using the given projectors and environment tensors.\n\n       |~~~~~~| -- E_north -- |~~~~~~~| \n    -- |P_left|       |       |P_right| --\n       |~~~~~~| --    A    -- |~~~~~~~| \n                      |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northeast_corner","text":"renormalize_northeast_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_northeast_corner(quadrant, P_left, P_right)\nrenormalize_northeast_corner(E_north, C_northeast, E_east, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged northeast corner.\n\n       |~~~~~~~| -- |~~~~~~~~|\n    -- |P_right|    |quadrant|\n       |~~~~~~~| -- |~~~~~~~~|\n                      |    |\n                     [P_left]\n                         |\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n       |~~~~~~~| -- E_north -- C_northeast\n    -- |P_right|       |            |  \n       |~~~~~~~| --    A    --    E_east\n                       |            |\n                     [~~~~~P_left~~~~~]\n                              |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northwest_corner","text":"renormalize_northwest_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_northwest_corner(quadrant, P_left, P_right)\nrenormalize_northwest_corner(E_west, C_northwest, E_north, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged northwest corner.\n\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --\n    |~~~~~~~~| -- |~~~~~~|\n     |     |\n    [P_right]\n        |\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n    C_northwest -- E_north -- |~~~~~~|\n         |           |        |P_left| --\n      E_west    --   A     -- |~~~~~~|\n         |           |\n      [~~~~~P_right~~~~]\n               |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_sequentially-Tuple{Int64, Any, Any, Any}","page":"Library","title":"PEPSKit.renormalize_sequentially","text":"renormalize_sequentially(col::Int, projectors, network, env)\n\nRenormalize one column of the CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_simultaneously-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_simultaneously","text":"renormalize_simultaneously(\n    enlarged_corners,\n    projectors,\n    network,\n    env\n)\n\n\nRenormalize all enlarged corners and edges simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_south_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_south_edge","text":"renormalize_south_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_south_edge(E_south, P_left, P_right, A::P)\n\nAbsorb a local effective tensor into the south edge using the given projectors and environment tensors.\n\n                       |\n       |~~~~~~~| --    A    -- |~~~~~~| \n    -- |P_right|       |       |P_left| --\n       |~~~~~~~| -- E_south -- |~~~~~~| \n                       |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southeast_corner","text":"renormalize_southeast_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_southeast_corner(quadrant, P_left, P_right)\nrenormalize_southeast_corner(E_east, C_southeast, E_south, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged southeast corner.\n\n                        |\n                    [P_right]\n                      |   |\n       |~~~~~~| -- |~~~~~~~~|\n    -- |P_left|    |quadrant|\n       |~~~~~~| -- |~~~~~~~~|\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n                            |\n                    [~~~~P_right~~~~]\n                      |           |\n       |~~~~~~| --    A    --   E_east\n    -- |P_left|       |           |\n       |~~~~~~| -- E_south -- C_southeast\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southwest_corner","text":"renormalize_southwest_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_southwest_corner(quadrant, P_left, P_right)\nrenormalize_southwest_corner(E_south, C_southwest, E_west, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged southwest corner.\n\n         |\n     [P_left]\n      |    |\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --\n    |~~~~~~~~| -- |~~~~~~|\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n               |\n       [~~~~~P_left~~~~~]\n         |            |\n       E_west   --    A    -- |~~~~~~~|\n         |            |       |P_right| --\n    C_southwest -- E_south -- |~~~~~~~|\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_top_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_top_corner","text":"renormalize_top_corner((row, col), env, projectors)\nrenormalize_top_corner(C_northwest, E_north, P_top)\n\nApply top projector to northwest corner and north edge.\n\n     C -- E -- \n     |    |\n    [~P_top~]\n        | \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_west_edge-Union{Tuple{Pb}, Tuple{Pt}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfiniteSquareNetwork}} where {Pt, Pb}","page":"Library","title":"PEPSKit.renormalize_west_edge","text":"renormalize_west_edge((row, col), env, P_top, P_bottom, network::InfiniteSquareNetwork{P})\nrenormalize_west_edge(E_west, P_top, P_bottom, A::P)\n\nAbsorb a local effective tensor into the west edge using the given projectors and environment tensors.\n\n           |\n     [~P_bottom~]\n      |        |\n   -- A  --  E_west\n      |        |\n     [~~P_top~~~]\n           |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.right_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.right_projector","text":"right_projector(E_1, C, E_2, U, isqS, A)\n\n\nContract the CTMRG right projector with the higher-dimensional subspace facing to the right.\n\n               |~~| --   E_2   --  C\n    -- isqS -- |U'|      |         |\n               |~~| --   A     -- E_1\n                         |         |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.rotate_north-Tuple{Any, Any}","page":"Library","title":"PEPSKit.rotate_north","text":"rotate_north(t, dir)\n\n\nRotate the dir direction of t to face north by successive applications of rotl90.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.sdiag_pow-Tuple{TensorKit.DiagonalTensorMap, Real}","page":"Library","title":"PEPSKit.sdiag_pow","text":"sdiag_pow(s, pow::Real; tol::Real=eps(scalartype(s))^(3 / 4))\n\nCompute s^pow for a diagonal matrix s.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.select_algorithm","page":"Library","title":"PEPSKit.select_algorithm","text":"select_algorithm(func_or_alg, args...; kwargs...) -> Algorithm\n\nParse arguments and keyword arguments to the algorithm struct corresponding to func_or_alg and return an algorithm instance. To that end, we use a general interface where all keyword arguments that can be algorithm themselves can be specified using\n\nalg::Algorithm : an instance of the algorithm struct or\n(; alg::Symbol, alg_kwargs...) : a NamedTuple where the algorithm is specified by a Symbol and the algorithm keyword arguments \n\nA full description of the keyword argument can be found in the respective function or algorithm struct docstrings.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.sequential_projectors-Tuple{Int64, Any, CTMRGEnv, PEPSKit.ProjectorAlgorithm}","page":"Library","title":"PEPSKit.sequential_projectors","text":"sequential_projectors(col::Int, network, env::CTMRGEnv, alg::ProjectorAlgorithm)\nsequential_projectors(coordinate::NTuple{3,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :sequential scheme either for an entire column col or for a specific coordinate (where dir=WEST is already implied in the :sequential scheme).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.simpleupdate-Tuple{InfiniteWeightPEPS, LocalOperator, SimpleUpdate}","page":"Library","title":"PEPSKit.simpleupdate","text":"simpleupdate(peps::InfiniteWeightPEPS, H::LocalOperator, alg::SimpleUpdate;\n             bipartite::Bool=false, check_interval::Int=500)\n\nPerform simple update with nearest neighbor Hamiltonian H, where the evolution information is printed every check_interval steps. \n\nIf bipartite == true (for square lattice), a unit cell size of (2, 2) is assumed,  as well as tensors and x/y weights which are the same across the diagonals, i.e. at (row, col) and (row+1, col+1).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.simultaneous_projectors-Union{Tuple{E}, Tuple{Array{E, 3}, CTMRGEnv, PEPSKit.ProjectorAlgorithm}} where E","page":"Library","title":"PEPSKit.simultaneous_projectors","text":"simultaneous_projectors(enlarged_corners::Array{E,3}, env::CTMRGEnv, alg::ProjectorAlgorithm)\nsimultaneous_projectors(coordinate, enlarged_corners::Array{E,3}, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :simultaneous scheme either for all provided enlarged corners or on a specific coordinate.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.su_iter-Tuple{LocalOperator, InfiniteWeightPEPS, SimpleUpdate}","page":"Library","title":"PEPSKit.su_iter","text":"su_iter(gate::LocalOperator, peps::InfiniteWeightPEPS, alg::SimpleUpdate; bipartite::Bool=false)\n\nOne round of simple update on peps applying the nearest neighbor gate.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}","page":"Library","title":"PEPSKit.symmetrize!","text":"symmetrize!(peps::InfinitePEPS, ::SymmetrizationStyle)\n\nSymmetrize a PEPS using the given SymmetrizationStyle in-place.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize_retract_and_finalize!","page":"Library","title":"PEPSKit.symmetrize_retract_and_finalize!","text":"symmetrize_retract_and_finalize!(symm::SymmetrizationStyle, [retract, finalize!])\n\nReturn the retract and finalize! function for symmetrizing the peps and grad tensors.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.twistdual!-Tuple{TensorKit.AbstractTensorMap, Int64}","page":"Library","title":"PEPSKit.twistdual!","text":"twistdual(t::AbstractTensorMap, i)\ntwistdual!(t::AbstractTensorMap, i)\n\nTwist the i-th leg of a tensor t if it represents a dual space.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.tsvd-Tuple{Any, Any}","page":"Library","title":"TensorKit.tsvd","text":"PEPSKit.tsvd(t, alg::SVDAdjoint; trunc=notrunc(), p=2)\n\nWrapper around TensorKit.tsvd which dispatches on the alg argument. This is needed since a custom adjoint for PEPSKit.tsvd may be defined, depending on the algorithm. E.g., for IterSVD the adjoint for a truncated SVD from KrylovKit.svdsolve is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.@autoopt-Tuple{Any}","page":"Library","title":"PEPSKit.@autoopt","text":"autoopt(ex)\n\nPreprocessor macro for @tensor which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with d, D, or χ are automatically inserted with the corresponding costs.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@fwdthreads-Tuple{Any}","page":"Library","title":"PEPSKit.@fwdthreads","text":"@fwdthreads(ex)\n\nApply Threads.@threads only in the forward pass of the program.\n\nIt works by wrapping the for-loop expression in an if statement where in the forward pass the loop in computed in parallel using Threads.@threads, whereas in the backwards pass the Threads.@threads is omitted in order to make the expression differentiable.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@showtypeofgrad-Tuple{Any}","page":"Library","title":"PEPSKit.@showtypeofgrad","text":"@showtypeofgrad(x)\n\nMacro utility to show to type of the gradient that is about to accumulate for x.\n\nSee also Zygote.@showgrad.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.Defaults","page":"Library","title":"PEPSKit.Defaults","text":"module Defaults\n\nModule containing default algorithm parameter values and arguments.\n\nCTMRG\n\nctmrg_tol=1.0e-8 : Tolerance checking singular value and norm convergence.\nctmrg_maxiter=100 : Maximal number of CTMRG iterations per run.\nctmrg_miniter=4 : Minimal number of CTMRG carried out.\nctmrg_alg=:simultaneous : Default CTMRG algorithm variant.\n:simultaneous: Simultaneous expansion and renormalization of all sides.\n:sequential: Sequential application of left moves and rotations.\nctmrg_verbosity=2 : CTMRG output information verbosity\n\nSVD forward & reverse\n\ntrscheme=:fixedspace : Truncation scheme for SVDs and other decompositions.\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nsvd_fwd_alg=:sdd : SVD algorithm that is used in the forward pass.\n:sdd: TensorKit's wrapper for LAPACK's _gesdd\n:svd: TensorKit's wrapper for LAPACK's _gesvd\n:iterative: Iterative SVD only computing the specifed number of singular values and vectors, see IterSVD\nsvd_rrule_tol=1.0e-8 : Accuracy of SVD reverse-rule.\nsvd_rrule_min_krylovdim=48 : Minimal Krylov dimension of the reverse-rule algorithm (if it is a Krylov algorithm).\nsvd_rrule_verbosity=-1 : SVD gradient output verbosity.\nsvd_rrule_alg=:full : Reverse-rule algorithm for the SVD gradient.\n:full: Uses a modified version of TensorKit's reverse-rule for tsvd which doesn't solve any linear problem and instead requires access to the full SVD, see PEPSKit.FullSVDReverseRule.\n:gmres: GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab: BiCGStab iterative linear solver, see the KrylovKit docs for details\n:arnoldi: Arnoldi Krylov algorithm, see the KrylovKit docs for details\nsvd_rrule_broadening=1.0e-13 : Lorentzian broadening amplitude which smoothens the divergent term in the SVD adjoint in case of (pseudo) degenerate singular values\n\nProjectors\n\nprojector_alg=:halfinfinite : Default variant of the CTMRG projector algorithm.\n:halfinfinite: Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.\n:fullinfinite: Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.\nprojector_verbosity=0 : Projector output information verbosity.\n\nFixed-point gradient\n\ngradient_tol=1.0e-6 : Convergence tolerance for the fixed-point gradient iteration.\ngradient_maxiter=30 : Maximal number of iterations for computing the CTMRG fixed-point gradient.\ngradient_verbosity=-1 : Gradient output information verbosity.\ngradient_linsolver=:bicgstab : Default linear solver for the LinSolver gradient algorithm.\n:gmres : GMRES iterative linear solver, see KrylovKit.GMRES for details\n:bicgstab : BiCGStab iterative linear solver, see KrylovKit.BiCGStab for details\ngradient_eigsolver=:arnoldi : Default eigensolver for the EigSolver gradient algorithm.\n:arnoldi : Arnoldi Krylov algorithm, see KrylovKit.Arnoldi for details\ngradient_eigsolver_eager=true : Enables EigSolver algorithm to finish before the full Krylov dimension is reached.\ngradient_iterscheme=:fixed : Scheme for differentiating one CTMRG iteration.\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\ngradient_alg=:linsolver : Algorithm variant for computing the gradient fixed-point.\n\nOptimization\n\nreuse_env=true : If true, the current optimization step is initialized on the previous environment, otherwise a random environment is used.\noptimizer_tol=0.0001 : Gradient norm tolerance of the optimizer.\noptimizer_maxiter=100 : Maximal number of optimization steps.\noptimizer_verbosity=3 : Optimizer output information verbosity.\noptimizer_alg=:lbfgs : Default OptimKit.OptimizerAlgorithm for PEPS optimization.\n:gradientdescent : Gradient descent algorithm, see the OptimKit README\n:conjugategradient : Conjugate gradient algorithm, see the OptimKit README\n:lbfgs : L-BFGS algorithm, see the OptimKit README\nls_maxiter=10 : Maximum number of iterations for the line search in each step of the optimization.\nls_maxfg=20 : Maximum number of function evaluations for the line search in each step of the optimization.\nlbfgs_memory=20 : Size of limited memory representation of BFGS Hessian matrix.\n\nOhMyThreads scheduler\n\nscheduler=Ref{Scheduler}(...) : Multithreading scheduler which can be accessed via set_scheduler!.\n\n\n\n\n\n","category":"module"},{"location":"lib/lib/#PEPSKit.Defaults.set_scheduler!","page":"Library","title":"PEPSKit.Defaults.set_scheduler!","text":"set_scheduler!([scheduler]; kwargs...)\n\nSet OhMyThreads multithreading scheduler parameters.\n\nThe function either accepts a scheduler as an OhMyThreads.Scheduler or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via\n\nset_scheduler!(StaticScheduler(; ntasks=4, chunking=true))\n\nor equivalently with \n\nset_scheduler!(:static; ntasks=4, chunking=true)\n\nFor a detailed description of all schedulers and their keyword arguments consult the OhMyThreads documentation.\n\nIf no scheduler is passed and only kwargs are provided, the DynamicScheduler constructor is used with the provided kwargs.\n\nTo reset the scheduler to its default value, one calls set_scheduler! without passing arguments which then uses the default DynamicScheduler(). If the number of used threads is just one it falls back to SerialScheduler().\n\n\n\n\n\n","category":"function"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/fermi_hubbard/#Fermi-Hubbard-model-with-f\\mathbb{Z}_2-\\boxtimes-U(1)-symmetry,-at-large-U-and-half-filling","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"","category":"section"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"In this example, we will demonstrate how to handle fermionic PEPS tensors and how to optimize them. To that end, we consider the two-dimensional Hubbard model","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"H = -t sum_langle ij rangle sum_sigma left( c_isigma^+ c_jsigma^- -\nc_isigma^- c_jsigma^+ right) + U sum_i n_iuparrown_idownarrow - mu sum_i n_i","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"where sigma in uparrowdownarrow and n_isigma = c_isigma^+ c_isigma^- is the fermionic number operator. As in previous examples, using fermionic degrees of freedom is a matter of creating tensors with the right symmetry sectors - the rest of the simulation workflow remains the same.","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"First though, we make the example deterministic by seeding the RNG, and we make our imports:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"using Random\nusing TensorKit, PEPSKit\nusing MPSKit: add_physical_charge\nRandom.seed!(2928528937);","category":"page"},{"location":"examples/fermi_hubbard/#Defining-the-fermionic-Hamiltonian","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Defining the fermionic Hamiltonian","text":"","category":"section"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"Let us start by fixing the parameters of the Hubbard model. We're going to use a hopping of t=1 and a large U=8 on a 2 times 2 unit cell:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"t = 1.0\nU = 8.0\nlattice = InfiniteSquare(2, 2);","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"In order to create fermionic tensors, one needs to define symmetry sectors using TensorKit's FermionParity. Not only do we want use fermion parity but we also want our particles to exploit the global U(1) symmetry. The combined product sector can be obtained using the Deligne product, called through ⊠ which is obtained by typing \\boxtimes+TAB. We will not impose any extra spin symmetry, so we have:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"fermion = fℤ₂\nparticle_symmetry = U1Irrep\nspin_symmetry = Trivial\nS = fermion ⊠ particle_symmetry","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"TensorKitSectors.ProductSector{Tuple{TensorKitSectors.FermionParity, TensorKitSectors.U1Irrep}}","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"The next step is defining graded virtual PEPS and environment spaces using S. Here we also use the symmetry sector to impose half-filling. That is all we need to define the Hubbard Hamiltonian:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"D, χ = 1, 1\nV_peps = Vect[S]((0, 0) => 2 * D, (1, 1) => D, (1, -1) => D)\nV_env = Vect[S](\n    (0, 0) => 4 * χ, (1, -1) => 2 * χ, (1, 1) => 2 * χ, (0, 2) => χ, (0, -2) => χ\n)\nS_aux = S((1, -1))\nH₀ = hubbard_model(ComplexF64, particle_symmetry, spin_symmetry, lattice; t, U)\nH = add_physical_charge(H₀, fill(S_aux, size(H₀.lattice)...));","category":"page"},{"location":"examples/fermi_hubbard/#Finding-the-ground-state","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Finding the ground state","text":"","category":"section"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"Again, the procedure of ground state optimization is very similar to before. First, we define all algorithmic parameters:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"boundary_alg = (; tol=1e-8, alg=:simultaneous, trscheme=(; alg=:fixedspace))\ngradient_alg = (; tol=1e-6, alg=:eigsolver, maxiter=10, iterscheme=:diffgauge)\noptimizer_alg = (; tol=1e-4, alg=:lbfgs, maxiter=80, ls_maxiter=3, ls_maxfg=3)","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"(tol = 0.0001, alg = :lbfgs, maxiter = 80, ls_maxiter = 3, ls_maxfg = 3)","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"Second, we initialize a PEPS state and environment (which we converge) constructed from symmetric physical and virtual spaces:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"physical_spaces = physicalspace(H)\nvirtual_spaces = fill(V_peps, size(lattice)...)\npeps₀ = InfinitePEPS(randn, ComplexF64, physical_spaces, virtual_spaces)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, V_env), peps₀; boundary_alg...);","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"[ Info: CTMRG init:\tobj = +5.484842275412e+04 +4.469243203539e+04im\terr = 1.0000e+00\n[ Info: CTMRG conv 26:\tobj = +8.371681846538e+04 -3.791428753175e-07im\terr = 7.4963852327e-09\ttime = 8.21 sec\n","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"And third, we start the ground state search (this does take quite long):","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"peps, env, E, info = fixedpoint(\n    H, peps₀, env₀; boundary_alg, gradient_alg, optimizer_alg, verbosity=3\n)\n@show E;","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"[ Info: LBFGS: initializing with f = 6.680719803101, ‖∇f‖ = 9.5842e+00\n┌ Warning: The function `scale!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.GradedSpace{TensorKitSectors.ProductSector{Tuple{TensorKitSectors.FermionParity, TensorKitSectors.U1Irrep}}, TensorKit.SortedVectorDict{TensorKitSectors.ProductSector{Tuple{TensorKitSectors.FermionParity, TensorKitSectors.U1Irrep}}, Int64}}, 1, 4, Vector{ComplexF64}}}, Float64}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:91\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -1.49e-01, ϕ - ϕ₀ = -2.88e+00\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    1, time  835.44 s: f = 3.801394787694, ‖∇f‖ = 2.3457e+01, α = 2.50e+01, m = 0, nfg = 4\n┌ Warning: The function `add!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.GradedSpace{TensorKitSectors.ProductSector{Tuple{TensorKitSectors.FermionParity, TensorKitSectors.U1Irrep}}, TensorKit.SortedVectorDict{TensorKitSectors.ProductSector{Tuple{TensorKitSectors.FermionParity, TensorKitSectors.U1Irrep}}, Int64}}, 1, 4, Vector{ComplexF64}}}, InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.GradedSpace{TensorKitSectors.ProductSector{Tuple{TensorKitSectors.FermionParity, TensorKitSectors.U1Irrep}}, TensorKit.SortedVectorDict{TensorKitSectors.ProductSector{Tuple{TensorKitSectors.FermionParity, TensorKitSectors.U1Irrep}}, Int64}}, 1, 4, Vector{ComplexF64}}}, Int64, VectorInterface.One}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:163\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -5.73e-03, ϕ - ϕ₀ = -3.81e+00\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    2, time  890.92 s: f = -0.009753189324, ‖∇f‖ = 3.2047e+00, α = 2.50e+01, m = 0, nfg = 4\n[ Info: LBFGS: iter    3, time  900.05 s: f = -0.115219717423, ‖∇f‖ = 2.7847e+00, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    4, time  908.73 s: f = -0.616462986123, ‖∇f‖ = 2.3685e+00, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    5, time  916.72 s: f = -0.817865359874, ‖∇f‖ = 1.9095e+00, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    6, time  924.48 s: f = -0.990425015686, ‖∇f‖ = 2.3830e+00, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    7, time  931.58 s: f = -1.142986439459, ‖∇f‖ = 1.5684e+00, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    8, time  938.01 s: f = -1.239591181120, ‖∇f‖ = 3.4861e+00, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    9, time  945.00 s: f = -1.438708542563, ‖∇f‖ = 1.3377e+00, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter   10, time  951.30 s: f = -1.524142766825, ‖∇f‖ = 1.3499e+00, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   11, time  965.03 s: f = -1.620143211649, ‖∇f‖ = 1.1928e+00, α = 1.75e-01, m = 9, nfg = 2\n[ Info: LBFGS: iter   12, time  978.38 s: f = -1.682030774949, ‖∇f‖ = 9.4585e-01, α = 2.41e-01, m = 10, nfg = 2\n[ Info: LBFGS: iter   13, time  984.74 s: f = -1.722173660258, ‖∇f‖ = 1.3961e+00, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   14, time  991.74 s: f = -1.771649839243, ‖∇f‖ = 6.2967e-01, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   15, time  998.01 s: f = -1.809425620292, ‖∇f‖ = 5.1874e-01, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   16, time 1004.35 s: f = -1.860257660187, ‖∇f‖ = 7.0707e-01, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   17, time 1011.32 s: f = -1.894073433816, ‖∇f‖ = 6.7099e-01, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   18, time 1017.63 s: f = -1.923565778264, ‖∇f‖ = 5.6311e-01, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   19, time 1024.66 s: f = -1.948747056517, ‖∇f‖ = 4.7890e-01, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   20, time 1030.99 s: f = -1.969585552903, ‖∇f‖ = 4.1660e-01, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   21, time 1037.41 s: f = -1.982637358938, ‖∇f‖ = 4.3422e-01, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   22, time 1044.48 s: f = -1.993882710416, ‖∇f‖ = 3.1362e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, time 1050.89 s: f = -2.002938619798, ‖∇f‖ = 3.0798e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, time 1057.30 s: f = -2.014146064233, ‖∇f‖ = 3.3262e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, time 1064.50 s: f = -2.022239330954, ‖∇f‖ = 4.2937e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, time 1070.92 s: f = -2.030245493641, ‖∇f‖ = 2.0179e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, time 1078.05 s: f = -2.035169726141, ‖∇f‖ = 1.6346e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, time 1085.19 s: f = -2.038915730445, ‖∇f‖ = 1.6570e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, time 1091.75 s: f = -2.041961016975, ‖∇f‖ = 2.2790e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, time 1098.99 s: f = -2.045467456219, ‖∇f‖ = 1.0966e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, time 1105.48 s: f = -2.047243458561, ‖∇f‖ = 9.2405e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, time 1112.69 s: f = -2.049202803483, ‖∇f‖ = 1.2184e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, time 1119.08 s: f = -2.050191917638, ‖∇f‖ = 1.3044e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, time 1125.47 s: f = -2.050986114708, ‖∇f‖ = 5.9665e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, time 1132.64 s: f = -2.051548091457, ‖∇f‖ = 5.5253e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, time 1139.10 s: f = -2.051993308206, ‖∇f‖ = 6.2588e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, time 1146.24 s: f = -2.052324002624, ‖∇f‖ = 1.1928e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, time 1152.87 s: f = -2.052936230102, ‖∇f‖ = 4.9216e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, time 1159.10 s: f = -2.053164325823, ‖∇f‖ = 3.3410e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, time 1166.05 s: f = -2.053418129203, ‖∇f‖ = 3.7314e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, time 1172.35 s: f = -2.053649981748, ‖∇f‖ = 6.3612e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, time 1178.56 s: f = -2.053879953203, ‖∇f‖ = 3.4038e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, time 1185.49 s: f = -2.054050515673, ‖∇f‖ = 2.9152e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, time 1191.74 s: f = -2.054259903099, ‖∇f‖ = 3.9095e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, time 1198.69 s: f = -2.054388805929, ‖∇f‖ = 6.7475e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   46, time 1204.88 s: f = -2.054563154978, ‖∇f‖ = 3.0486e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, time 1211.31 s: f = -2.054666133101, ‖∇f‖ = 2.3929e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, time 1218.31 s: f = -2.054764670097, ‖∇f‖ = 2.9961e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, time 1224.59 s: f = -2.054936790198, ‖∇f‖ = 3.5407e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, time 1237.87 s: f = -2.055058405443, ‖∇f‖ = 5.1106e-02, α = 5.17e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   51, time 1244.16 s: f = -2.055253894176, ‖∇f‖ = 3.1080e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, time 1251.20 s: f = -2.055461219872, ‖∇f‖ = 2.9077e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, time 1257.57 s: f = -2.055733194309, ‖∇f‖ = 4.5784e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, time 1264.73 s: f = -2.055960164237, ‖∇f‖ = 7.1631e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, time 1271.03 s: f = -2.056334000687, ‖∇f‖ = 5.1447e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   56, time 1277.42 s: f = -2.056801416149, ‖∇f‖ = 4.8803e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, time 1284.42 s: f = -2.057222872354, ‖∇f‖ = 5.7077e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, time 1290.71 s: f = -2.057705132019, ‖∇f‖ = 8.5536e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, time 1297.71 s: f = -2.058233824137, ‖∇f‖ = 6.6099e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, time 1304.05 s: f = -2.058618411767, ‖∇f‖ = 8.2058e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, time 1310.35 s: f = -2.058860905381, ‖∇f‖ = 8.8034e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   62, time 1317.34 s: f = -2.059344181668, ‖∇f‖ = 6.7163e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, time 1323.93 s: f = -2.059884025175, ‖∇f‖ = 1.1005e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, time 1330.95 s: f = -2.060366638147, ‖∇f‖ = 7.3906e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   65, time 1337.42 s: f = -2.060748895891, ‖∇f‖ = 5.7350e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, time 1343.90 s: f = -2.061217694695, ‖∇f‖ = 1.0218e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, time 1351.08 s: f = -2.061747836243, ‖∇f‖ = 6.5473e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, time 1357.59 s: f = -2.061935488163, ‖∇f‖ = 7.7435e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, time 1364.81 s: f = -2.062292588164, ‖∇f‖ = 1.1031e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, time 1371.28 s: f = -2.062776748901, ‖∇f‖ = 8.7133e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, time 1377.76 s: f = -2.063311285039, ‖∇f‖ = 6.3871e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, time 1384.96 s: f = -2.063848732928, ‖∇f‖ = 7.8582e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, time 1391.44 s: f = -2.064428066762, ‖∇f‖ = 8.0994e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, time 1398.73 s: f = -2.064797991263, ‖∇f‖ = 2.1328e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, time 1405.20 s: f = -2.065223995463, ‖∇f‖ = 1.0827e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, time 1411.72 s: f = -2.065622191643, ‖∇f‖ = 7.4192e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, time 1418.93 s: f = -2.066318151347, ‖∇f‖ = 9.4270e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, time 1433.31 s: f = -2.067468309902, ‖∇f‖ = 1.5613e-01, α = 4.14e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   79, time 1448.12 s: f = -2.068248367388, ‖∇f‖ = 1.9031e-01, α = 2.81e-01, m = 20, nfg = 2\n┌ Warning: LBFGS: not converged to requested tol after 80 iterations and time 1461.23 s: f = -2.069293119751, ‖∇f‖ = 3.6413e-01\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/lbfgs.jl:197\nE = -2.0692931197508764\n","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"Finally, let's compare the obtained energy against a reference energy from a QMC study by Qin et al.. With the parameters specified above, they obtain an energy of E_textref approx 4 times -05244140625 = -209765625 (the factor 4 comes from the 2 times 2 unit cell that we use here). Thus, we find:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"E_ref = -2.09765625\n@show (E - E_ref) / E_ref;","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"(E - E_ref) / E_ref = -0.013521343284498413\n","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/symmetries/#Symmetric-and-fermionic-tensors","page":"Symmetric and fermionic tensors","title":"Symmetric and fermionic tensors","text":"","category":"section"},{"location":"man/symmetries/","page":"Symmetric and fermionic tensors","title":"Symmetric and fermionic tensors","text":"note: Note\nThis section is still under construction.","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/heisenberg_su/#Simple-update-for-the-Heisenberg-model","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"","category":"section"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"In this example, we will use SimpleUpdate imaginary time evolution to treat the two-dimensional Heisenberg model once again:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"H = sum_langle ij rangle J_x S^x_i S^x_j + J_y S^y_i S^y_j + J_z S^z_i S^z_j","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"In order to simulate the antiferromagnetic order of the Hamiltonian on a single-site unit cell one typically applies a unitary sublattice rotation. Here, we will instead use a 2 times 2 unit cell and set J_x = J_y = J_z = 1.","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"Let's get started by seeding the RNG and importing all required modules:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"using Random\nimport Statistics: mean\nusing TensorKit, PEPSKit\nimport MPSKitModels: S_x, S_y, S_z, S_exchange\nRandom.seed!(0);","category":"page"},{"location":"examples/heisenberg_su/#Defining-the-Hamiltonian","page":"Simple update for the Heisenberg model","title":"Defining the Hamiltonian","text":"","category":"section"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"To construct the Heisenberg Hamiltonian as just discussed, we'll use heisenberg_XYZ and, in addition, make it real (real and imag works for LocalOperators) since we want to use PEPS and environments with real entries. We can either initialize the Hamiltonian with no internal symmetries (symm = Trivial) or use the global U(1) symmetry (symm = U1Irrep):","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"symm = Trivial ## ∈ {Trivial, U1Irrep}\nNr, Nc = 2, 2\nH = real(heisenberg_XYZ(ComplexF64, symm, InfiniteSquare(Nr, Nc); Jx=1, Jy=1, Jz=1));","category":"page"},{"location":"examples/heisenberg_su/#Simple-updating","page":"Simple update for the Heisenberg model","title":"Simple updating","text":"","category":"section"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"We proceed by initializing a random weighted PEPS that will be evolved. First though, we need to define the appropriate (symmetric) spaces:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"Dbond = 4\nχenv = 16\nif symm == Trivial\n    physical_space = ℂ^2\n    bond_space = ℂ^Dbond\n    env_space = ℂ^χenv\nelseif symm == U1Irrep\n    physical_space = ℂ[U1Irrep](1//2 => 1, -1//2 => 1)\n    bond_space = ℂ[U1Irrep](0 => Dbond ÷ 2, 1//2 => Dbond ÷ 4, -1//2 => Dbond ÷ 4)\n    env_space = ℂ[U1Irrep](0 => χenv ÷ 2, 1//2 => χenv ÷ 4, -1//2 => χenv ÷ 4)\nelse\n    error(\"not implemented\")\nend\n\nwpeps = InfiniteWeightPEPS(rand, Float64, physical_space, bond_space; unitcell=(Nr, Nc));","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"Next, we can start the SimpleUpdate routine, successively decreasing the time intervals and singular value convergence tolerances. Note that TensorKit allows to combine SVD truncation schemes, which we use here to set a maximal bond dimension and at the same time fix a truncation error (if that can be reached by remaining below Dbond):","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"dts = [1e-2, 1e-3, 4e-4]\ntols = [1e-6, 1e-8, 1e-8]\nmaxiter = 10000\ntrscheme_peps = truncerr(1e-10) & truncdim(Dbond)\n\nfor (dt, tol) in zip(dts, tols)\n    alg = SimpleUpdate(dt, tol, maxiter, trscheme_peps)\n    result = simpleupdate(wpeps, H, alg; bipartite=true)\n    global wpeps = result[1]\nend","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 1.683e+00,  time = 10.602 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 500    :  dt = 1e-02,  weight diff = 3.879e-06,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU conv 596    :  dt = 1e-02,  weight diff = 9.933e-07,  time = 12.073 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1      :  dt = 1e-03,  weight diff = 2.135e-03,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 500    :  dt = 1e-03,  weight diff = 9.632e-07,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1000   :  dt = 1e-03,  weight diff = 2.415e-07,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1500   :  dt = 1e-03,  weight diff = 6.291e-08,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 2000   :  dt = 1e-03,  weight diff = 1.683e-08,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU conv 2205   :  dt = 1e-03,  weight diff = 9.978e-09,  time = 4.545 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1      :  dt = 4e-04,  weight diff = 1.418e-04,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 500    :  dt = 4e-04,  weight diff = 6.377e-08,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1000   :  dt = 4e-04,  weight diff = 3.544e-08,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1500   :  dt = 4e-04,  weight diff = 2.013e-08,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 2000   :  dt = 4e-04,  weight diff = 1.157e-08,  time = 0.002 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU conv 2133   :  dt = 4e-04,  weight diff = 9.999e-09,  time = 4.379 sec\n","category":"page"},{"location":"examples/heisenberg_su/#Computing-the-ground-state-energy-and-magnetizations","page":"Simple update for the Heisenberg model","title":"Computing the ground-state energy and magnetizations","text":"","category":"section"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"In order to compute observable expectation values, we need to converge a CTMRG environment on the evolved PEPS. Let's do so:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"peps = InfinitePEPS(wpeps) ## absorb the weights\nenv₀ = CTMRGEnv(rand, Float64, peps, env_space)\ntrscheme_env = truncerr(1e-10) & truncdim(χenv)\nenv, = leading_boundary(\n    env₀,\n    peps;\n    alg=:sequential,\n    projector_alg=:fullinfinite,\n    tol=1e-10,\n    trscheme=trscheme_env,\n);","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"[ Info: CTMRG init:\tobj = +8.705922473439e-05\terr = 1.0000e+00\n[ Info: CTMRG conv 15:\tobj = +9.514115680898e-01\terr = 6.0310868148e-11\ttime = 9.35 sec\n","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"Finally, we'll measure the energy and different magnetizations. For the magnetizations, the plan is to compute the expectation values unit cell entry-wise in different spin directions:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"function compute_mags(peps::InfinitePEPS, env::CTMRGEnv)\n    lattice = collect(space(t, 1) for t in peps.A)\n\n    # detect symmetry on physical axis\n    symm = sectortype(space(peps.A[1, 1]))\n    if symm == Trivial\n        S_ops = real.([S_x(symm), im * S_y(symm), S_z(symm)])\n    elseif symm == U1Irrep\n        S_ops = real.([S_z(symm)]) ## only Sz preserves <Sz>\n    end\n\n    return map(Iterators.product(axes(peps, 1), axes(peps, 2), S_ops)) do (r, c, S)\n        expectation_value(peps, LocalOperator(lattice, (CartesianIndex(r, c),) => S), env)\n    end\nend\n\nE = expectation_value(peps, H, env) / (Nr * Nc)\nMs = compute_mags(peps, env)\nM_norms = map(\n    rc -> norm(Ms[rc[1], rc[2], :]), Iterators.product(axes(peps, 1), axes(peps, 2))\n)\n@show E Ms M_norms;","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"E = -0.6674685583160895\nMs = [0.03199644951247372 -0.02980262049564095; -0.029802620502662757 0.03199644954619281;;; 2.2896091139871975e-12 -1.0506898420176606e-12; -2.118251543953617e-12 8.853279136399547e-13;;; 0.37559610906659674 -0.3757765476186203; -0.3757765476169772 0.37559610906659097]\nM_norms = [0.37695650933147595 0.3769565093330746; 0.3769565093319919 0.3769565093343323]\n","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"To assess the results, we will benchmark against data from Corboz, which use manual gradients to perform a variational optimization of the Heisenberg model. In particular, for the energy and magnetization they find E_textref = -06675 and M_textref = 03767. Looking at the relative errors, we find general agreement, although the accuracy is limited by the methodological limitations of the simple update algorithm as well as finite bond dimension effects and a lacking extrapolation:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"E_ref = -0.6675\nM_ref = 0.3767\n@show (E - E_ref) / E_ref\n@show (mean(M_norms) - M_ref) / E_ref;","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"(E - E_ref) / E_ref = -4.7103646307789086e-5\n(mean(M_norms) - M_ref) / E_ref = -0.0003842836445223997\n","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/heisenberg/#examples_heisenberg","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"In this example we want to provide a basic rundown of PEPSKit's optimization workflow for PEPS. To that end, we will consider the two-dimensional Heisenberg model on a square lattice","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"H = sum_langle ij rangle left ( J_x S^x_i S^x_j + J_y S^y_i S^y_j + J_z S^z_i S^z_j right )","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Here, we want to set J_x = J_y = J_z = 1 where the Heisenberg model is in the antiferromagnetic regime. Due to the bipartite sublattice structure of antiferromagnetic order one needs a PEPS ansatz with a 2 times 2 unit cell. This can be circumvented by performing a unitary sublattice rotation on all B-sites resulting in a change of parameters to (J_x J_y J_z)=(-1 1 -1). This gives us a unitarily equivalent Hamiltonian (with the same spectrum) with a ground state on a single-site unit cell.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Let us get started by fixing the random seed of this example to make it deterministic:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"using Random\nRandom.seed!(123456789);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"We're going to need only two packages: TensorKit, since we use that for all the underlying tensor operations, and PEPSKit itself. So let us import these:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"using TensorKit, PEPSKit","category":"page"},{"location":"examples/heisenberg/#Defining-the-Heisenberg-Hamiltonian","page":"Optimizing the 2D Heisenberg model","title":"Defining the Heisenberg Hamiltonian","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"To create the sublattice rotated Heisenberg Hamiltonian on an infinite square lattice, we use the heisenberg_XYZ method from MPSKitModels which is redefined for the InfiniteSquare and reexported in PEPSKit:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"H = heisenberg_XYZ(InfiniteSquare(); Jx=-1, Jy=1, Jz=-1)","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"LocalOperator{Tuple{Pair{Tuple{CartesianIndex{2}, CartesianIndex{2}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}, Pair{Tuple{CartesianIndex{2}, CartesianIndex{2}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}}, TensorKit.ComplexSpace}(TensorKit.ComplexSpace[ℂ^2;;], ((CartesianIndex(1, 1), CartesianIndex(1, 2)) => TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):\n[:, :, 1, 1] =\n -0.25 + 0.0im   0.0 + 0.0im\n   0.0 + 0.0im  -0.5 + 0.0im\n\n[:, :, 2, 1] =\n  0.0 + 0.0im  0.0 + 0.0im\n 0.25 + 0.0im  0.0 + 0.0im\n\n[:, :, 1, 2] =\n 0.0 + 0.0im  0.25 + 0.0im\n 0.0 + 0.0im   0.0 + 0.0im\n\n[:, :, 2, 2] =\n -0.5 + 0.0im    0.0 + 0.0im\n  0.0 + 0.0im  -0.25 + 0.0im\n, (CartesianIndex(1, 1), CartesianIndex(2, 1)) => TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):\n[:, :, 1, 1] =\n -0.25 + 0.0im   0.0 + 0.0im\n   0.0 + 0.0im  -0.5 + 0.0im\n\n[:, :, 2, 1] =\n  0.0 + 0.0im  0.0 + 0.0im\n 0.25 + 0.0im  0.0 + 0.0im\n\n[:, :, 1, 2] =\n 0.0 + 0.0im  0.25 + 0.0im\n 0.0 + 0.0im   0.0 + 0.0im\n\n[:, :, 2, 2] =\n -0.5 + 0.0im    0.0 + 0.0im\n  0.0 + 0.0im  -0.25 + 0.0im\n))","category":"page"},{"location":"examples/heisenberg/#Setting-up-the-algorithms-and-initial-guesses","page":"Optimizing the 2D Heisenberg model","title":"Setting up the algorithms and initial guesses","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Next, we set the simulation parameters. During optimization, the PEPS will be contracted using CTMRG and the PEPS gradient will be computed by differentiating through the CTMRG routine using AD. Since the algorithmic stack that implements this is rather elaborate, the amount of settings one can configure is also quite large. To reduce this complexity, PEPSKit defaults to (presumably) reasonable settings which also dynamically adapts to the user-specified parameters.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"First, we set the bond dimension Dbond of the virtual PEPS indices and the environment dimension χenv of the virtual corner and transfer matrix indices.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Dbond = 2\nχenv = 16;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"To configure the CTMRG algorithm, we create a NamedTuple containing different keyword arguments. To see a description of all arguments, see the docstring of leading_boundary. Here, we want to converge the CTMRG environments up to a specific tolerance and during the CTMRG run keep all index dimensions fixed:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"boundary_alg = (; tol=1e-10, trscheme=(; alg=:fixedspace));","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Let us also configure the optimizer algorithm. We are going to optimize the PEPS using the L-BFGS optimizer from OptimKit. Again, we specify the convergence tolerance (for the gradient norm) as well as the maximal number of iterations and the BFGS memory size (which is used to approximate the Hessian):","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"optimizer_alg = (; alg=:lbfgs, tol=1e-4, maxiter=100, lbfgs_memory=16);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Additionally, during optimization, we want to reuse the previous CTMRG environment to initialize the CTMRG run of the current optimization step using the reuse_env argument. And to control the output information, we set the verbosity:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"reuse_env = true\nverbosity = 3;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Next, we initialize a random PEPS which will be used as an initial guess for the optimization. To get a PEPS with physical dimension 2 (since we have a spin-1/2 Hamiltonian) with complex-valued random Gaussian entries, we set:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"peps₀ = InfinitePEPS(randn, ComplexF64, 2, Dbond)","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}[TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')):\n[:, :, 1, 1, 1] =\n 0.07382174258286094 + 0.12820373667088403im   0.7897519397510839 + 0.9113654266438473im\n  0.2553716885006697 - 0.4358399804354269im   -1.0272416446076236 - 0.12635062198157215im\n\n[:, :, 2, 1, 1] =\n 0.16833628450178303 - 0.10088950122180829im  -0.9702030532300809 + 0.010730752411986726im\n -1.6804460553576506 + 0.29081053879369084im   0.6844811667615024 + 0.09101537356941222im\n\n[:, :, 1, 2, 1] =\n  0.5085938050744258 + 0.3786892551842583im   1.0020057959636561 - 1.4704891009758718im\n -0.6153328223084331 + 0.10417896606055738im  0.6024931811537675 - 1.0348374874397468im\n\n[:, :, 2, 2, 1] =\n -0.027201695938305456 + 0.5778042099380925im  0.09232089635078945 + 0.6143070126937361im\n    1.0707115218777772 - 0.5747168579241235im  -0.5819741818511422 - 0.9842624134267605im\n\n[:, :, 1, 1, 2] =\n 1.2332543810053822 - 1.7783531996396438im  0.8887723728085348 + 0.7809798723615474im\n 1.2251189302516847 - 0.6853683793073324im  1.5333834584675397 - 0.13856216581406375im\n\n[:, :, 2, 1, 2] =\n 0.1406381347783769 + 0.6630243440357264im   -0.7294596235434386 + 0.40327909254711103im\n 0.7212056487788236 + 0.24320971945037498im   0.9991347929322827 + 0.0017902515981375842im\n\n[:, :, 1, 2, 2] =\n 0.34282910982693904 - 0.4865238029567361im   0.9380949844871762 - 0.6985342237892025im\n -0.7437083517319159 - 0.6895708849529253im  -0.8981092940164176 + 0.9720706252141459im\n\n[:, :, 2, 2, 2] =\n -0.8897079923413616 - 0.7145412189457411im  0.07771261045117502 - 0.6400190994609709im\n -1.6099412157243007 + 0.8855200965611144im   0.7357380595021633 + 0.4626916850143416im\n;;])","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"The last thing we need before we can start the optimization is an initial CTMRG environment. Typically, a random environment which we converge on peps₀ serves as a good starting point. To contract a PEPS starting from an environment using CTMRG, we call leading_boundary:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"env_random = CTMRGEnv(randn, ComplexF64, peps₀, ℂ^χenv);\nenv₀, info_ctmrg = leading_boundary(env_random, peps₀; boundary_alg...);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"[ Info: CTMRG init:\tobj = -2.749614463601e+00 +3.639628057806e+00im\terr = 1.0000e+00\n[ Info: CTMRG conv 27:\tobj = +9.727103564786e+00\terr = 2.6201184615e-11\ttime = 0.17 sec\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Besides the converged environment, leading_boundary also returns a NamedTuple of informational quantities such as the last maximal truncation error - that is, the SVD approximation error incurred in the last CTMRG iteration, maximized over all spatial directions and unit cell entries:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"@show info_ctmrg.truncation_error;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"info_ctmrg.truncation_error = 0.0017032153529848298\n","category":"page"},{"location":"examples/heisenberg/#Ground-state-search","page":"Optimizing the 2D Heisenberg model","title":"Ground state search","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Finally, we can start the optimization by calling fixedpoint on H with our settings for the boundary (CTMRG) algorithm and the optimizer. This might take a while (especially the precompilation of AD code in this case):","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"peps, env, E, info_opt = fixedpoint(\n    H, peps₀, env₀; boundary_alg, optimizer_alg, reuse_env, verbosity\n);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"[ Info: LBFGS: initializing with f = 0.000601645310, ‖∇f‖ = 9.3548e-01\n┌ Warning: The function `scale!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}, Float64}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:91\n[ Info: LBFGS: iter    1, time  643.37 s: f = -0.489783740840, ‖∇f‖ = 6.0020e-01, α = 5.94e+01, m = 0, nfg = 5\n┌ Warning: The function `add!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}, InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}, Int64, VectorInterface.One}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:163\n[ Info: LBFGS: iter    2, time  645.02 s: f = -0.501971411096, ‖∇f‖ = 5.3738e-01, α = 2.80e-01, m = 1, nfg = 2\n[ Info: LBFGS: iter    3, time  645.36 s: f = -0.523152816264, ‖∇f‖ = 3.9922e-01, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, time  646.10 s: f = -0.538652145758, ‖∇f‖ = 4.1551e-01, α = 2.29e-01, m = 3, nfg = 2\n[ Info: LBFGS: iter    5, time  648.50 s: f = -0.549861364689, ‖∇f‖ = 4.4015e-01, α = 6.94e-02, m = 4, nfg = 4\n[ Info: LBFGS: iter    6, time  649.35 s: f = -0.568951023367, ‖∇f‖ = 4.8339e-01, α = 2.24e-01, m = 5, nfg = 2\n[ Info: LBFGS: iter    7, time  649.72 s: f = -0.586980871663, ‖∇f‖ = 4.2463e-01, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    8, time  650.06 s: f = -0.599970185661, ‖∇f‖ = 2.1955e-01, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter    9, time  650.38 s: f = -0.606725496115, ‖∇f‖ = 1.9384e-01, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   10, time  650.70 s: f = -0.624986498009, ‖∇f‖ = 2.9776e-01, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, time  651.00 s: f = -0.638747320059, ‖∇f‖ = 2.3382e-01, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, time  651.32 s: f = -0.645577148853, ‖∇f‖ = 2.9937e-01, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, time  651.60 s: f = -0.650891062410, ‖∇f‖ = 1.4746e-01, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, time  651.90 s: f = -0.654569099868, ‖∇f‖ = 7.0690e-02, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, time  652.20 s: f = -0.655949603239, ‖∇f‖ = 5.0977e-02, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, time  652.51 s: f = -0.657146001976, ‖∇f‖ = 5.8056e-02, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, time  652.83 s: f = -0.658558478454, ‖∇f‖ = 5.0388e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, time  653.13 s: f = -0.659302065828, ‖∇f‖ = 4.0776e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   19, time  653.42 s: f = -0.659633838354, ‖∇f‖ = 2.2380e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   20, time  653.72 s: f = -0.659776177694, ‖∇f‖ = 2.1511e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   21, time  654.01 s: f = -0.659916031911, ‖∇f‖ = 2.0498e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   22, time  654.30 s: f = -0.660181523751, ‖∇f‖ = 1.7235e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   23, time  654.62 s: f = -0.660350536401, ‖∇f‖ = 1.8928e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   24, time  654.91 s: f = -0.660447076769, ‖∇f‖ = 1.0330e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   25, time  655.21 s: f = -0.660521574522, ‖∇f‖ = 1.0448e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   26, time  655.52 s: f = -0.660656071716, ‖∇f‖ = 1.8768e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   27, time  655.85 s: f = -0.660756412995, ‖∇f‖ = 3.2183e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   28, time  656.18 s: f = -0.660925447420, ‖∇f‖ = 1.3371e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   29, time  656.60 s: f = -0.661000634324, ‖∇f‖ = 9.8866e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   30, time  657.36 s: f = -0.661046316490, ‖∇f‖ = 9.1513e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   31, time  657.70 s: f = -0.661128304094, ‖∇f‖ = 9.6895e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   32, time  658.08 s: f = -0.661169144566, ‖∇f‖ = 1.3492e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   33, time  658.37 s: f = -0.661204525845, ‖∇f‖ = 9.6996e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   34, time  658.65 s: f = -0.661224003573, ‖∇f‖ = 6.2892e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   35, time  658.94 s: f = -0.661247137140, ‖∇f‖ = 4.4514e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   36, time  659.24 s: f = -0.661266456453, ‖∇f‖ = 5.3015e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   37, time  659.53 s: f = -0.661280686254, ‖∇f‖ = 9.2298e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   38, time  659.83 s: f = -0.661298851672, ‖∇f‖ = 5.9013e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   39, time  660.12 s: f = -0.661320547122, ‖∇f‖ = 6.2443e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   40, time  660.41 s: f = -0.661344887326, ‖∇f‖ = 9.9129e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   41, time  660.71 s: f = -0.661398950542, ‖∇f‖ = 1.6285e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   42, time  661.03 s: f = -0.661483277766, ‖∇f‖ = 1.6233e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   43, time  661.34 s: f = -0.661583013010, ‖∇f‖ = 2.8186e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   44, time  661.66 s: f = -0.661670888522, ‖∇f‖ = 3.9725e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   45, time  661.98 s: f = -0.661865434012, ‖∇f‖ = 1.3200e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   46, time  662.29 s: f = -0.661977354471, ‖∇f‖ = 1.5881e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   47, time  662.60 s: f = -0.662102076782, ‖∇f‖ = 2.0290e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   48, time  663.24 s: f = -0.662190125548, ‖∇f‖ = 2.2873e-02, α = 4.61e-01, m = 16, nfg = 2\n[ Info: LBFGS: iter   49, time  663.55 s: f = -0.662306892721, ‖∇f‖ = 1.3813e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   50, time  663.87 s: f = -0.662376465537, ‖∇f‖ = 1.9902e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   51, time  664.17 s: f = -0.662419493776, ‖∇f‖ = 1.2249e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   52, time  664.48 s: f = -0.662439251412, ‖∇f‖ = 7.3806e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   53, time  664.79 s: f = -0.662463629284, ‖∇f‖ = 5.1806e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   54, time  665.10 s: f = -0.662484473404, ‖∇f‖ = 4.6461e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   55, time  665.71 s: f = -0.662490501784, ‖∇f‖ = 6.3694e-03, α = 4.07e-01, m = 16, nfg = 2\n[ Info: LBFGS: iter   56, time  666.01 s: f = -0.662497687998, ‖∇f‖ = 2.9285e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   57, time  666.32 s: f = -0.662500949854, ‖∇f‖ = 2.1234e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   58, time  666.62 s: f = -0.662503723196, ‖∇f‖ = 4.1203e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   59, time  666.93 s: f = -0.662505780051, ‖∇f‖ = 3.0872e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   60, time  667.22 s: f = -0.662507116565, ‖∇f‖ = 1.9618e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   61, time  667.52 s: f = -0.662509290310, ‖∇f‖ = 1.5747e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   62, time  667.82 s: f = -0.662510568937, ‖∇f‖ = 1.3099e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   63, time  668.65 s: f = -0.662511109974, ‖∇f‖ = 2.7217e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   64, time  668.96 s: f = -0.662511878793, ‖∇f‖ = 1.0320e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   65, time  669.34 s: f = -0.662512042147, ‖∇f‖ = 5.9753e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   66, time  669.65 s: f = -0.662512275118, ‖∇f‖ = 6.6602e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   67, time  669.93 s: f = -0.662512678161, ‖∇f‖ = 9.0498e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   68, time  670.21 s: f = -0.662513114911, ‖∇f‖ = 1.8006e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   69, time  670.51 s: f = -0.662513454844, ‖∇f‖ = 9.5988e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   70, time  670.80 s: f = -0.662513639773, ‖∇f‖ = 5.2576e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   71, time  671.09 s: f = -0.662513713403, ‖∇f‖ = 4.0696e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   72, time  671.39 s: f = -0.662513818843, ‖∇f‖ = 4.8084e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   73, time  671.70 s: f = -0.662513978848, ‖∇f‖ = 6.8463e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   74, time  672.29 s: f = -0.662514066816, ‖∇f‖ = 5.2125e-04, α = 5.38e-01, m = 16, nfg = 2\n[ Info: LBFGS: iter   75, time  672.57 s: f = -0.662514122809, ‖∇f‖ = 3.2924e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   76, time  672.86 s: f = -0.662514184291, ‖∇f‖ = 2.7038e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   77, time  673.17 s: f = -0.662514214654, ‖∇f‖ = 4.6682e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   78, time  673.46 s: f = -0.662514242510, ‖∇f‖ = 2.7698e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   79, time  673.74 s: f = -0.662514253309, ‖∇f‖ = 1.6244e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   80, time  674.02 s: f = -0.662514263613, ‖∇f‖ = 1.2004e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   81, time  674.30 s: f = -0.662514271751, ‖∇f‖ = 1.4760e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   82, time  674.58 s: f = -0.662514281056, ‖∇f‖ = 1.6558e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   83, time  674.87 s: f = -0.662514283704, ‖∇f‖ = 2.1824e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: converged after 84 iterations and time 675.15 s: f = -0.662514288424, ‖∇f‖ = 5.9513e-05\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Note that fixedpoint returns the final optimized PEPS, the last converged environment, the final energy estimate as well as a NamedTuple of diagnostics. This allows us to, e.g., analyze the number of cost function calls or the history of gradient norms to evaluate the convergence rate:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"@show info_opt.fg_evaluations info_opt.gradnorms[1:10:end];","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"info_opt.fg_evaluations = 98\ninfo_opt.gradnorms[1:10:end] = [0.9354758925982428, 0.2977564979129917, 0.021510752143210195, 0.009151302712640632, 0.009912940904896769, 0.019901533415930574, 0.0019617677308353, 0.0005257609002981095, 0.00012003941670625574]\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Let's now compare the optimized energy against an accurate Quantum Monte Carlo estimate by Sandvik, where the energy per site was found to be E_textref=06694421. From our simple optimization we find:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"@show E;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"E = -0.6625142884244373\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"While this energy is in the right ballpark, there is still quite some deviation from the accurate reference energy. This, however, can be attributed to the small bond dimension - an optimization with larger bond dimension would approach this value much more closely.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"A more reasonable comparison would be against another finite bond dimension PEPS simulation. For example, Juraj Hasik's data from J_1text-J_2 PEPS simulations yields E_D=2chi=16=-0660231dots which is more in line with what we find here.","category":"page"},{"location":"examples/heisenberg/#Compute-the-correlation-lengths-and-transfer-matrix-spectra","page":"Optimizing the 2D Heisenberg model","title":"Compute the correlation lengths and transfer matrix spectra","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"In practice, in order to obtain an accurate and variational energy estimate, one would need to compute multiple energies at different environment dimensions and extrapolate in, e.g., the correlation length or the second gap of the transfer matrix spectrum. For that, we would need the correlation_length function, which computes the horizontal and vertical correlation lengths and transfer matrix spectra for all unit cell coordinates:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"ξ_h, ξ_v, λ_h, λ_v = correlation_length(peps, env)\n@show ξ_h ξ_v;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"ξ_h = [1.034117934253177]\nξ_v = [1.0240816290840877]\n","category":"page"},{"location":"examples/heisenberg/#Computing-observables","page":"Optimizing the 2D Heisenberg model","title":"Computing observables","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"As a last thing, we want to see how we can compute expectation values of observables, given the optimized PEPS and its CTMRG environment. To compute, e.g., the magnetization, we first need to define the observable as a TensorMap:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"σ_z = TensorMap([1.0 0.0; 0.0 -1.0], ℂ^2, ℂ^2)","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"TensorMap(ℂ^2 ← ℂ^2):\n 1.0   0.0\n 0.0  -1.0\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"In order to be able to contract it with the PEPS and environment, we define need to define a LocalOperator and specify on which physical spaces and sites the observable acts. That way, the PEPS-environment-operator contraction gets automatically generated (also works for multi-site operators!). See the LocalOperator docstring for more details. The magnetization is just a single-site observable, so we have:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"M = LocalOperator(fill(ℂ^2, 1, 1), (CartesianIndex(1, 1),) => σ_z)","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"LocalOperator{Tuple{Pair{Tuple{CartesianIndex{2}}, TensorKit.TensorMap{Float64, TensorKit.ComplexSpace, 1, 1, Vector{Float64}}}}, TensorKit.ComplexSpace}(TensorKit.ComplexSpace[ℂ^2;;], ((CartesianIndex(1, 1),) => TensorMap(ℂ^2 ← ℂ^2):\n 1.0   0.0\n 0.0  -1.0\n,))","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Finally, to evaluate the expecation value on the LocalOperator, we call:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"@show expectation_value(peps, M, env);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"expectation_value(peps, M, env) = -0.7554296202981441 + 2.541461125039123e-16im\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/environments/#Environments","page":"Environments","title":"Environments","text":"","category":"section"},{"location":"man/environments/","page":"Environments","title":"Environments","text":"note: Note\nThis section is still under construction.","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/2d_ising_partition_function/#e_2d_ising","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"","category":"section"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"While PEPSKit has a lot of use in quantum systems, describing states using InfinitePEPS that can be contracted via CTMRG or boundary MPS techniques, here we shift our focus to classical physics. We consider the 2D classical Ising model and compute its partition function defined as:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"mathcalZ(beta) = sum_s exp(-beta H(s)) text with  H(s) = -J sum_langle i j rangle s_i s_j ","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"where the classical spins s_i in +1 -1 are located on the vertices i of a 2D square lattice. The idea is to encode the partition function as an infinite square network consisting of local rank-4 tensors, which can then be contracted using CTMRG. An infinite square network of these rank-4 tensors can be represented as an InfinitePartitionFunction object, as we will see.","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"But first, let's seed the RNG and import all required modules:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"using Random, LinearAlgebra\nusing TensorKit, PEPSKit\nusing QuadGK\nRandom.seed!(234923);","category":"page"},{"location":"examples/2d_ising_partition_function/#Defining-the-partition-function","page":"The 2D classical Ising model using CTMRG","title":"Defining the partition function","text":"","category":"section"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"The first step is to define the rank-4 tensor that, when contracted on a square lattice, evaluates to the partition function value at a given beta. This is done through a fairly generic procedure where the interaction weights are distributed among vertex tensors in an appropriate way. Concretely, here we first define a 'link' matrix containing the Boltzmann weights associated to all possible spin configurations across a given link on the lattice. Next, we define site tensors as delta-tensors that ensiure that the spin value on all adjacent links is the same. Since we only want tensors on the sites in the end, we can symmetrically absorb the link weight tensors into the site tensors, which gives us exactly the kind of network we're looking for. Since we later want to compute the magnetization and energy to check our results, we define the appropriate rank-4 tensors here as well while we're at it.","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"function classical_ising(; beta=log(1 + sqrt(2)) / 2, J=1.0)\n    K = beta * J\n\n    # Boltzmann weights\n    t = ComplexF64[exp(K) exp(-K); exp(-K) exp(K)]\n    r = eigen(t)\n    nt = r.vectors * sqrt(Diagonal(r.values)) * r.vectors\n\n    # local partition function tensor\n    O = zeros(2, 2, 2, 2)\n    O[1, 1, 1, 1] = 1\n    O[2, 2, 2, 2] = 1\n    @tensor o[-1 -2; -3 -4] := O[3 4; 2 1] * nt[-3; 3] * nt[-4; 4] * nt[-2; 2] * nt[-1; 1]\n\n    # magnetization tensor\n    M = copy(O)\n    M[2, 2, 2, 2] *= -1\n    @tensor m[-1 -2; -3 -4] := M[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * nt[-3; 3] * nt[-4; 4]\n\n    # bond interaction tensor and energy-per-site tensor\n    e = ComplexF64[-J J; J -J] .* nt\n    @tensor e_hor[-1 -2; -3 -4] :=\n        O[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * nt[-3; 3] * e[-4; 4]\n    @tensor e_vert[-1 -2; -3 -4] :=\n        O[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * e[-3; 3] * nt[-4; 4]\n    e = e_hor + e_vert\n\n    # fixed tensor map space for all three\n    TMS = ℂ^2 ⊗ ℂ^2 ← ℂ^2 ⊗ ℂ^2\n\n    return TensorMap(o, TMS), TensorMap(m, TMS), TensorMap(e, TMS)\nend;","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"So let's initialize these tensors at inverse temperature beta=06, check that they are indeed rank-4 and construct the corresponding InfinitePartitionFunction:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"beta = 0.6\nO, M, E = classical_ising(; beta)\n@show space(O)\nZ = InfinitePartitionFunction(O)","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"InfinitePartitionFunction{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}[TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):\n[:, :, 1, 1] =\n  3.169519816780443 + 0.0im  0.4999999999999995 + 0.0im\n 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im\n\n[:, :, 2, 1] =\n 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im\n 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im\n\n[:, :, 1, 2] =\n 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im\n 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im\n\n[:, :, 2, 2] =\n 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im\n 0.4999999999999995 + 0.0im   3.169519816780443 + 0.0im\n;;])","category":"page"},{"location":"examples/2d_ising_partition_function/#Contracting-the-partition-function","page":"The 2D classical Ising model using CTMRG","title":"Contracting the partition function","text":"","category":"section"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"Next, we can contract the partition function as per usual by constructing a CTMRGEnv with a specified environment virtual space and calling leading_boundary with appropriate settings:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"Venv = ℂ^20\nenv₀ = CTMRGEnv(Z, Venv)\nenv, = leading_boundary(env₀, Z; tol=1e-8, maxiter=500);","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"[ Info: CTMRG init:\tobj = +1.767587313024e+00 -1.536527975696e+00im\terr = 1.0000e+00\n[ Info: CTMRG conv 62:\tobj = +3.353928644031e+00\terr = 4.7636155793e-09\ttime = 10.20 sec\n","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"Note that CTMRG environments for partition functions differ from the PEPS environments only by the edge tensors. Instead of two legs connecting the edges and the PEPS-PEPS sandwich, there is only one leg connecting the edges and the partition function tensor, meaning that the edge tensors are now rank-3:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"space.(env.edges)","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"4×1×1 Array{TensorKit.TensorMapSpace{TensorKit.ComplexSpace, 2, 1}, 3}:\n[:, :, 1] =\n (ℂ^20 ⊗ ℂ^2) ← ℂ^20\n (ℂ^20 ⊗ ℂ^2) ← ℂ^20\n (ℂ^20 ⊗ (ℂ^2)') ← ℂ^20\n (ℂ^20 ⊗ (ℂ^2)') ← ℂ^20","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"To compute the value of the partition function, we have to contract Z with the converged environment using network_value. Additionally, we will compute the magnetization and energy (per site), again using expectation_value but this time also specifying the index in the unit cell where we want to insert the local tensor:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"λ = network_value(Z, env)\nm = expectation_value(Z, (1, 1) => M, env)\ne = expectation_value(Z, (1, 1) => E, env)\n@show λ m e;","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"λ = 3.3539286440313765 - 3.486341495761219e-16im\nm = 0.9736086674403004 + 7.16942808669034e-17im\ne = -1.8637796145082448 + 0.0im\n","category":"page"},{"location":"examples/2d_ising_partition_function/#Comparing-against-the-exact-Onsager-solution","page":"The 2D classical Ising model using CTMRG","title":"Comparing against the exact Onsager solution","text":"","category":"section"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"In order to assess our results, we will compare against the exact Onsager solution of the 2D classical Ising model. To that end, we compute the exact free energy, magnetization and energy per site (where we use quadgk to perform integrals of an auxiliary variable from 0 to pi2):","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"function classical_ising_exact(; beta=log(1 + sqrt(2)) / 2, J=1.0)\n    K = beta * J\n\n    k = 1 / sinh(2 * K)^2\n    F = quadgk(\n        theta -> log(cosh(2 * K)^2 + 1 / k * sqrt(1 + k^2 - 2 * k * cos(2 * theta))), 0, pi\n    )[1]\n    f = -1 / beta * (log(2) / 2 + 1 / (2 * pi) * F)\n\n    m = 1 - (sinh(2 * K))^(-4) > 0 ? (1 - (sinh(2 * K))^(-4))^(1 / 8) : 0\n\n    E = quadgk(theta -> 1 / sqrt(1 - (4 * k) * (1 + k)^(-2) * sin(theta)^2), 0, pi / 2)[1]\n    e = -J * cosh(2 * K) / sinh(2 * K) * (1 + 2 / pi * (2 * tanh(2 * K)^2 - 1) * E)\n\n    return f, m, e\nend\n\nf_exact, m_exact, e_exact = classical_ising_exact(; beta);","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"And indeed, we do find agreement between the exact and CTMRG values (keeping in mind that energy accuracy is limited by the environment dimension and the lack of proper extrapolation):","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"@show (-log(λ) / beta - f_exact) / f_exact\n@show (abs(m) - abs(m_exact)) / abs(m_exact)\n@show (e - e_exact) / e_exact;","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"(-(log(λ)) / beta - f_exact) / f_exact = -1.1009271732942546e-15 - 8.58980335690302e-17im\n(abs(m) - abs(m_exact)) / abs(m_exact) = -1.1403175236145204e-16\n(e - e_exact) / e_exact = -0.02373206809908996 - 0.0im\n","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/multithreading/#Multithreading","page":"Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"man/multithreading/","page":"Multithreading","title":"Multithreading","text":"Before detailing the multithreading capabilities of PEPSKit, there are some general remarks to be made about parallelism in Julia. In particular, it is important to know the interaction of Julia threads and BLAS threads, and that the BLAS thread behavior is inconsistent among different vendors. Since these details have been explained many times elsewhere, we here want to point towards the MPSKit docs, which provide a good rundown of the threading behavior and what to be aware of.","category":"page"},{"location":"man/multithreading/","page":"Multithreading","title":"Multithreading","text":"PEPSKit's multithreading features are provided through OhMyThreads.jl. In addition, we also supply a differentiable parallel map, which parallelizes not only the forward pass but also the reverse pass of the map application, see PEPSKit.dtmap. The threading behaviour can be specified through a global scheduler that is interfaced through the set_scheduler! function:","category":"page"},{"location":"man/multithreading/#PEPSKit.Defaults.set_scheduler!","page":"Multithreading","title":"PEPSKit.Defaults.set_scheduler!","text":"set_scheduler!([scheduler]; kwargs...)\n\nSet OhMyThreads multithreading scheduler parameters.\n\nThe function either accepts a scheduler as an OhMyThreads.Scheduler or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via\n\nset_scheduler!(StaticScheduler(; ntasks=4, chunking=true))\n\nor equivalently with \n\nset_scheduler!(:static; ntasks=4, chunking=true)\n\nFor a detailed description of all schedulers and their keyword arguments consult the OhMyThreads documentation.\n\nIf no scheduler is passed and only kwargs are provided, the DynamicScheduler constructor is used with the provided kwargs.\n\nTo reset the scheduler to its default value, one calls set_scheduler! without passing arguments which then uses the default DynamicScheduler(). If the number of used threads is just one it falls back to SerialScheduler().\n\n\n\n\n\n","category":"function"},{"location":"man/multithreading/","page":"Multithreading","title":"Multithreading","text":"By default, the OhMyThreads machinery will be used to parallelize certain parts of the code, if Julia started with multiple threads. Cases where PEPSKit can leverage parallel threads are:","category":"page"},{"location":"man/multithreading/","page":"Multithreading","title":"Multithreading","text":"CTMRG steps using the :simultaneous scheme, where we parallelize over all unit cell coordinates and spatial directions\nThe reverse pass of these parallelized CTMRG steps\nEvaluating expectation values of observables, where we parallelize over the terms contained in the LocalOperator","category":"page"},{"location":"examples/#e_overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Here we provide a number of commented example pages that serve as short tutorials on how to use PEPSKit in various situations. Applications span from two-dimensional quantum models, including fermionic Hamiltonians, to classical three-dimensional statistical mechanics:","category":"page"},{"location":"examples/#Optimization","page":"Overview","title":"Optimization","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Pages = Main.examples_optimization\nDepth = 1","category":"page"},{"location":"examples/#Time-Evolution","page":"Overview","title":"Time Evolution","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Pages = Main.examples_time_evolution\nDepth = 1","category":"page"},{"location":"examples/#Partition-Functions","page":"Overview","title":"Partition Functions","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Pages = Main.examples_partition_functions\nDepth = 1","category":"page"},{"location":"examples/#Boundary-MPS","page":"Overview","title":"Boundary MPS","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Pages = Main.examples_boundary_mps\nDepth = 1","category":"page"},{"location":"man/precompilation/#Precompilation-using-PrecompileTools.jl","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"","category":"section"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"For certain PEPSKit applications, the \"time to first execution\" (TTFX) can be quite long. If frequent recompilation is required this can become a significant time sink. Especially in simulations involving AD code, the precompilation times of Zygote tend to be particularly bad.","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"Fortunately, there is an easy way out using PrecompileTools. By writing a precompilation script that executes and precompiles a toy problem which is suited to one's personal problem, one can cut down significantly on the TTFX. To see how that works in the context of PEPSKit, we will closely follow the PrecompileTools docs.","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"Let's say we have a project where we want to speed up the TTFX, located in a project environment called YourProject. Inside that project folder, we generate a Startup module which will contain the toy problem that we want to precompile:","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"(YourProject) pkg> generate Startup\n  Generating  project Startup:\n    Startup/Project.toml\n    Startup/src/Startup.jl\n\n(YourProject) pkg> dev ./Startup\n   Resolving package versions...\n    Updating `/YourProject/Project.toml`\n  [e9c42744] + Startup v0.1.0 `Startup`\n    Updating `/tmp/Project1/Manifest.toml`\n  [e9c42744] + Startup v0.1.0 `Startup`\n\n(YourProject) pkg> activate Startup/\n  Activating project at `/YourProject/Startup`\n\n(Startup) pkg> add PrecompileTools YourPackages...","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"The Startup module should depend on PrecompileTools as well as all the packages (YourPackages...) that are required to run the precompilation toy problem. Next, we edit the Startup/src/Startup.jl file and add to it all the code which we want PrecompileTools to compile. We will here provide a basic example featuring Zygote AD code on various algorithmic combinations:","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"module Startup\n\nusing Random\nusing TensorKit, KrylovKit, OptimKit\nusing ChainRulesCore, Zygote\nusing MPSKit, MPSKitModels\nusing PEPSKit\nusing PrecompileTools\n\n@setup_workload begin\n    t₀ = time_ns()\n    Random.seed!(20918352394)\n\n    # Hyperparameters\n    Dbond = 2\n    χenv = 4\n    gradtol = 1e-3\n    maxiter = 4\n    verbosity = -1\n    H = heisenberg_XYZ(InfiniteSquare())\n\n    # Algorithmic settings\n    ctmrg_algs = [\n        SimultaneousCTMRG(; maxiter, projector_alg=:halfinfinite, verbosity),\n        SequentialCTMRG(; maxiter, projector_alg=:halfinfinite, verbosity),\n    ]\n    gradient_algs = [\n        LinSolver(; solver_alg=BiCGStab(; tol=gradtol), iterscheme=:fixed),\n        LinSolver(; solver_alg=BiCGStab(; tol=gradtol), iterscheme=:diffgauge),\n        EigSolver(; solver_alg=Arnoldi(; tol=gradtol, eager=true), iterscheme=:fixed),\n    ]\n\n    # Initialize OhMyThreads scheduler (precompilation occurs before __init__ call)\n    set_scheduler!()\n\n    @compile_workload begin\n        # Initialize PEPS and environments with different unit cells, number types and symmetries\n        @info \"Precompiling workload: initializing PEPSs and environments\"\n        peps = InfinitePEPS(randn, ComplexF64, ComplexSpace(Dbond), ComplexSpace(Dbond))\n\n        env, = leading_boundary(CTMRGEnv(peps, ComplexSpace(χenv)), peps; verbosity)\n\n        # CTMRG\n        @info \"Precompiling workload: CTMRG leading_boundary\"\n        for ctmrg_alg in ctmrg_algs\n            leading_boundary(env, peps, ctmrg_alg)\n        end\n\n        # Differentiate CTMRG leading_boundary\n        @info \"Precompiling workload: backpropagation of leading_boundary\"\n        for alg_rrule in gradient_algs\n            Zygote.withgradient(peps) do ψ\n                env′, = PEPSKit.hook_pullback(\n                    leading_boundary, env, ψ, SimultaneousCTMRG(; verbosity); alg_rrule\n                )\n                return cost_function(ψ, env′, H)\n            end\n        end\n\n        # Optimize via fixedpoint using LBFGS\n        @info \"Precompiling workload: LBFGS fixedpoint optimization\"\n        fixedpoint(H, peps, env, opt_alg; tol=gradtol, maxiter, verbosity)\n\n        # Compute correlation length\n        @info \"Precompiling workload: correlation_length\"\n        correlation_length(peps, env)\n    end\n\n    duration = round((time_ns() - t₀) * 1e-9 / 60; digits=2) # minutes\n    @info \"Precompiling workload: finished after $duration min\"\nend\n\nend","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"Finally, activate YourProject again - where we want to benefit from the shortened execution times - and run using Startup. That way, all packages will be loaded with their precompiled code. Of course, we may also have multiple start-up routines where the precompiled code is tailored towards the needs of the respective projects.","category":"page"},{"location":"man/states/#States","page":"States","title":"States","text":"","category":"section"},{"location":"man/states/","page":"States","title":"States","text":"note: Note\nThis section is still under construction.","category":"page"},{"location":"man/peps_optimization/#PEPS-optimization","page":"PEPS optimization","title":"PEPS optimization","text":"","category":"section"},{"location":"man/peps_optimization/","page":"PEPS optimization","title":"PEPS optimization","text":"note: Note\nThis section is still under construction.","category":"page"},{"location":"man/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"man/models/","page":"Models","title":"Models","text":"PEPSKit implements physical models through the MPSKitModels.jl package as PEPSKit.LocalOperator structs. Here, we want to explain how users can define their own Hamiltonians and provide a list of already implemented models.","category":"page"},{"location":"man/models/#Implementing-custom-models","page":"Models","title":"Implementing custom models","text":"","category":"section"},{"location":"man/models/","page":"Models","title":"Models","text":"In order to define custom Hamiltonians, we leverage several of the useful tools provided in MPSKitModels. In particular, we use many of the pre-defined operators, which is especially useful when defining models with symmetric and fermionic tensors, since most of these operators can take a symmetry as an argument, returning the appropriate symmetric TensorMap. In order to specify the lattice on which the Hamiltonian is defined, we construct two-dimensional lattices as subtypes of MPSKitModels.AbstractLattice. Note that so far, all models are defined on infinite square lattices, see InfiniteSquare, but in the future, we plan to support other lattice geometries as well. In order to specify tensors acting on particular lattice sites, there are a couple of handy methods that we want to point to: see vertices, nearest_neighbors and next_nearest_neighbors defined here.","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"For a simple example on how to implement a custom model, let's look at the implementation of the MPSKitModels.transverse_field_ising model:","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"function MPSKitModels.transverse_field_ising(\n    T::Type{<:Number},\n    S::Union{Type{Trivial},Type{Z2Irrep}},\n    lattice::InfiniteSquare;\n    J=1.0,\n    g=1.0,\n)\n    ZZ = rmul!(σᶻᶻ(T, S), -J)\n    X = rmul!(σˣ(T, S), g * -J)\n    spaces = fill(domain(X)[1], (lattice.Nrows, lattice.Ncols))\n    return LocalOperator(\n        spaces,\n        (neighbor => ZZ for neighbor in nearest_neighbours(lattice))...,\n        ((idx,) => X for idx in vertices(lattice))...,\n    )\nend","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"This provides a good recipe for defining a model:","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"Define the locally-acting tensors as TensorMaps.\nConstruct a matrix of the physical spaces these TensorMaps act on based on the lattice geometry.\nReturn a LocalOperator where we specify on which sites (e.g. on-site, nearest neighbor, etc.) the local tensors act.","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"For more model implementations, check the PEPSKit repository.","category":"page"},{"location":"man/models/#Implemented-models","page":"Models","title":"Implemented models","text":"","category":"section"},{"location":"man/models/","page":"Models","title":"Models","text":"While PEPSKit provides an interface for specifying custom Hamiltonians, it also provides a number of pre-defined models. Some of these are models already defined in MPSKitModels, which are overloaded for two-dimensional lattices and re-exported, but there are new additions as well. The following models are provided:","category":"page"},{"location":"man/models/#MPSKitModels.jl-models","page":"Models","title":"MPSKitModels.jl models","text":"","category":"section"},{"location":"man/models/#MPSKitModels.transverse_field_ising","page":"Models","title":"MPSKitModels.transverse_field_ising","text":"transverse_field_ising([elt::Type{<:Number}], [symmetry::Type{<:Sector}],\n                       [lattice::AbstractLattice]; J=1.0, g=1.0)\n\nMPO for the hamiltonian of the one-dimensional Transverse-field Ising model, as defined by\n\nH = -Jleft(sum_langle ij rangle sigma^z_i sigma^z_j + g sum_i sigma^x_i right)\n\nwhere the sigma^i are the spin-1/2 Pauli operators. Possible values for the symmetry are Trivial, Z2Irrep or FermionParity.\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, with Trivial symmetry and with ComplexF64 entries of the tensors.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.heisenberg_XYZ","page":"Models","title":"MPSKitModels.heisenberg_XYZ","text":"heisenberg_XYZ([elt::Type{<:Number}], [lattice::AbstractLattice];\n    Jx=1.0, Jy=1.0, Jz=1.0, spin=1)\n\nMPO for the hamiltonian of the XYZ Heisenberg model, defined by\n\nH = sum_langle ij rangle left( J^x S_i^x S_j^x + J^y S_i^y S_j^y + J^z S_i^z S_j^z right)\n\nBy default, the model is defined on an infinite chain with unit lattice spacing and with ComplexF64 entries of the tensors.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.heisenberg_XXZ","page":"Models","title":"MPSKitModels.heisenberg_XXZ","text":"heisenberg_XXZ([elt::Type{<:Number}], [symmetry::Type{<:Sector}],\n               [lattice::AbstractLattice]; J=1.0, Delta=1.0, spin=1)\n\nMPO for the hamiltonian of the XXZ Heisenberg model, as defined by\n\nH = J left( sum_langle ij rangle S_i^x S_j^x + S_i^y S_j^y + Delta S_i^z S_j^z right)\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, without any symmetries and with ComplexF64 entries of the tensors.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.hubbard_model","page":"Models","title":"MPSKitModels.hubbard_model","text":"hubbard_model([elt::Type{<:Number}], [particle_symmetry::Type{<:Sector}],\n              [spin_symmetry::Type{<:Sector}], [lattice::AbstractLattice];\n              t, U, mu, n)\n\nMPO for the hamiltonian of the Hubbard model, as defined by\n\nH = -t sum_langle ij rangle sum_sigma left( e_isigma^+ e_jsigma^- + c_isigma^- c_jsigma^+ right) + U sum_i n_iuparrown_idownarrow - sum_i mu n_i\n\nwhere sigma is a spin index that can take the values uparrow or downarrow and n is the fermionic number operator e_number.\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, without any symmetries and with ComplexF64 entries of the tensors. If the particle_symmetry is not Trivial, a fixed particle number density n can be imposed.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.bose_hubbard_model","page":"Models","title":"MPSKitModels.bose_hubbard_model","text":"bose_hubbard_model([elt::Type{<:Number}], [symmetry::Type{<:Sector}],\n                   [lattice::AbstractLattice];\n                   cutoff, t, U, mu, n)\n\nMPO for the hamiltonian of the Bose-Hubbard model, as defined by\n\nH = -t sum_langle ij rangle left( a_i^+ a_j^- + a_i^- a_j^+ right) - mu sum_i N_i + fracU2 sum_i N_i(N_i - 1)\n\nwhere N is the bosonic number operator a_number.\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, without any symmetries and with ComplexF64 entries of the tensors. The Hilbert space is truncated such that at maximum of cutoff bosons can be at a single site. If the symmetry is not Trivial, a fixed (halfinteger) particle number density n can be imposed.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.tj_model","page":"Models","title":"MPSKitModels.tj_model","text":"tj_model([elt::Type{<:Number}], [particle_symmetry::Type{<:Sector}],\n              [spin_symmetry::Type{<:Sector}], [lattice::AbstractLattice];\n              t, J, mu, slave_fermion::Bool=false)\n\nMPO for the hamiltonian of the t-J model, as defined by\n\nH = -t sum_langle ij rangle sigma\n    (tildee^dagger_isigma tildee_jsigma + hc)\n    + J sum_langle ij rangle(mathbfS_i cdot mathbfS_j - frac14 n_i n_j)\n    - mu sum_i n_i\n\nwhere tildee_isigma is the electron operator with spin sigma restrict to the no-double-occupancy subspace. \n\n\n\n\n\n","category":"function"},{"location":"man/models/#PEPSKit.jl-models","page":"Models","title":"PEPSKit.jl models","text":"","category":"section"},{"location":"man/models/#PEPSKit.j1_j2_model","page":"Models","title":"PEPSKit.j1_j2_model","text":"j1_j2_model([elt::Type{T}, symm::Type{S},] lattice::InfiniteSquare;\n            J1=1.0, J2=1.0, spin=1//2, sublattice=true)\n\nSquare lattice J_1text-J_2 model, defined by the Hamiltonian\n\nH = J_1 sum_langle ij rangle vecS_i cdot vecS_j\n+ J_2 sum_langlelangle ij ranglerangle vecS_i cdot vecS_j\n\nwhere vecS_i = (S_i^x S_i^y S_i^z). We denote the nearest and next-nearest neighbor terms using langle ij rangle and langlelangle ij ranglerangle, respectively. The sublattice kwarg enables a single-site unit cell ground state via a unitary sublattice rotation.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#PEPSKit.pwave_superconductor","page":"Models","title":"PEPSKit.pwave_superconductor","text":"pwave_superconductor([T=ComplexF64,] lattice::InfiniteSquare; t=1, μ=2, Δ=1)\n\nSquare lattice p-wave superconductor model, defined by the Hamiltonian\n\n    H = -sum_langle ij rangle left( t c_i^dagger c_j +\n    Delta c_i c_j + texthc right) - mu sum_i n_i\n\nwhere t is the hopping amplitude, Delta specifies the superconducting gap, mu is the chemical potential, and n_i = c_i^dagger c_i is the fermionic number operator.\n\n\n\n\n\n","category":"function"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/3d_ising_partition_function/#e_3d_ising","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"In this example, we will showcase how one can use PEPSKit to study 3D classical statistical mechanics models. In particular, we will consider a specific case of the 3D classical Ising model, but the same techniques can be applied to other 3D classical models as well.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"As compared to simulations of 2D partition functions, the workflow presented in this example is a bit more experimental and less 'black-box'. Therefore, it also serves as a demonstration of some of the more internal functionality of PEPSKit, and how one can adapt it to less 'standard' kinds of problems.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Let us consider the partition function of the classical Ising model,","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"mathcalZ(beta) = sum_s exp(-beta H(s)) text with  H(s) = -J sum_langle i j rangle s_i s_j ","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"where the classical spins s_i in +1 -1 are located on the vertices i of a 3D cubic lattice. The partition function of this model can be represented as a 3D tensor network with a rank-6 tensor at each vertex of the lattice. Such a network can be contracted by finding the fixed point of the corresponding transfer operator, in exactly the same spirit as the boundary MPS methods demonstrated in another example.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Let's start by making the example deterministic and importing the required packages:","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"using Random\nusing LinearAlgebra\nusing PEPSKit, TensorKit\nusing KrylovKit, OptimKit, Zygote\n\nRandom.seed!(81812781144);","category":"page"},{"location":"examples/3d_ising_partition_function/#Defining-the-partition-function","page":"The 3D classical Ising model","title":"Defining the partition function","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Just as in the 2D case, the first step is to define the partition function as a tensor network. The procedure is exactly the same as before, the only difference being that now every spin participates in interactions associated to six links adjacent to that site. This means that the partition function can be written as an infinite 3D network with a single constituent rank-6 PEPSKit.PEPOTensor O located at each site of the cubic lattice. To verify our example we will check the magnetization and energy, so we also define the corresponding rank-6 tensors M and E while we're at it.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"function three_dimensional_classical_ising(; beta, J=1.0)\n    K = beta * J\n\n    # Boltzmann weights\n    t = ComplexF64[exp(K) exp(-K); exp(-K) exp(K)]\n    r = eigen(t)\n    q = r.vectors * sqrt(LinearAlgebra.Diagonal(r.values)) * r.vectors\n\n    # local partition function tensor\n    O = zeros(2, 2, 2, 2, 2, 2)\n    O[1, 1, 1, 1, 1, 1] = 1\n    O[2, 2, 2, 2, 2, 2] = 1\n    @tensor o[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n\n    # magnetization tensor\n    M = copy(O)\n    M[2, 2, 2, 2, 2, 2] *= -1\n    @tensor m[-1 -2; -3 -4 -5 -6] :=\n        M[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n\n    # bond interaction tensor and energy-per-site tensor\n    e = ComplexF64[-J J; J -J] .* q\n    @tensor e_x[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * e[-4; 4] * q[-5; 5] * q[-6; 6]\n    @tensor e_y[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * e[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n    @tensor e_z[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * e[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n    e = e_x + e_y + e_z\n\n    # fixed tensor map space for all three\n    TMS = ℂ^2 ⊗ (ℂ^2)' ← ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)'\n\n    return TensorMap(o, TMS), TensorMap(m, TMS), TensorMap(e, TMS)\nend;","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Let's initialize these tensors at inverse temperature beta=02391, which corresponds to a slightly lower temperature than the critical value beta_c=02216544","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"beta = 0.2391\nO, M, E = three_dimensional_classical_ising(; beta)\nO isa PEPSKit.PEPOTensor","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"true","category":"page"},{"location":"examples/3d_ising_partition_function/#Contracting-the-partition-function","page":"The 3D classical Ising model","title":"Contracting the partition function","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"To contract our infinite 3D partition function, we first reinterpret it as an infinite power of a slice-to-slice transfer operator T, where T can be seen as an infinite 2D projected entangled-pair operator (PEPO) which consists of the rank-6 tensor O at each site of an infinite 2D square lattice. In the same spirit as the boundary MPS approach, all we need to contract the whole partition function is to find the leading eigenvector of this PEPO. The fixed point of such a PEPO can be parametrized as a PEPS, and for the case of a Hermitian transfer operator we can find this PEPS through variational optimization.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Indeed, for a Hermitian transfer operator T we can characterize the fixed point PEPS psirangle which satisfies the eigenvalue equation T psirangle = Lambda psirangle corresponding to the largest magnitude eigenvalue Lambda as the solution of a variational problem","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"psirangle = textargmin_psirangle left ( lim_N to  - frac1N log left( fraclangle psi  T  psi ranglelangle psi  psi rangle right) right ) ","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"where N is the diverging number of sites of the 2D transfer operator T. The function minimized in this expression is exactly the free energy per site of the partition function, so we essentially find the fixed-point PEPS by variationally minimizing the free energy.","category":"page"},{"location":"examples/3d_ising_partition_function/#Defining-the-cost-function","page":"The 3D classical Ising model","title":"Defining the cost function","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Using PEPSKit.jl, this cost function and its gradient can be computed, after which we can use OptimKit.jl to actually optimize it. We can immediately recognize the denominator langle psi  psi rangle as the familiar PEPS norm, where we can compute the norm per site as the network_value of the corresponding InfiniteSquareNetwork by contracting it with the CTMRG algorithm. Similarly, the numerator langle psi  T  psi rangle is nothing more than an InfiniteSquareNetwork consisting of three layers corresponding to the ket, transfer operator and bra objects. This object can also be constructed and contracted in a straightforward way, so we can again compute its network_value.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"To define our cost function, we then need to construct the transfer operator as an InfinitePEPO, construct the two infinite 2D contractible networks for the numerator and denominator from the current PEPS and this transfer operator, and specify a contraction algorithm we can use to compute the values of these two networks. In addition, we'll specify the specific reverse rule algorithm that will be used to compute the gradient of this cost function.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"boundary_alg = SimultaneousCTMRG(; maxiter=150, tol=1e-8, verbosity=1)\nrrule_alg = EigSolver(;\n    solver_alg=KrylovKit.Arnoldi(; maxiter=30, tol=1e-6, eager=true), iterscheme=:diffgauge\n)\nT = InfinitePEPO(O)\n\nfunction pepo_costfun((peps, env_double_layer, env_triple_layer))\n    # use Zygote to compute the gradient automatically\n    E, gs = withgradient(peps) do ψ\n        # construct the PEPS norm network\n        n_double_layer = InfiniteSquareNetwork(ψ)\n        # contract this network\n        env_double_layer′, info = PEPSKit.hook_pullback(\n            leading_boundary,\n            env_double_layer,\n            n_double_layer,\n            boundary_alg;\n            alg_rrule=rrule_alg,\n        )\n        # construct the PEPS-PEPO-PEPS overlap network\n        n_triple_layer = InfiniteSquareNetwork(ψ, T)\n        # contract this network\n        env_triple_layer′, info = PEPSKit.hook_pullback(\n            leading_boundary,\n            env_triple_layer,\n            n_triple_layer,\n            boundary_alg;\n            alg_rrule=rrule_alg,\n        )\n        # update the environments for reuse\n        PEPSKit.ignore_derivatives() do\n            PEPSKit.update!(env_double_layer, env_double_layer′)\n            PEPSKit.update!(env_triple_layer, env_triple_layer′)\n        end\n        # compute the network values per site\n        λ3 = network_value(n_triple_layer, env_triple_layer)\n        λ2 = network_value(n_double_layer, env_double_layer)\n        # use this to compute the actual cost function\n        return -log(real(λ3 / λ2))\n    end\n    g = only(gs)\n    return E, g\nend;","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"There are a few things to note about this cost function definition. Since we will pass it to the OptimKit.optimize, we require it to return both our cost function and the corresponding gradient. To do this, we simply use the withgradient method from Zygote.jl to automatically compute the gradient of the cost function straight from the primal computation. Since our cost function involves contractions using leading_boundary, we also have to specify exactly how Zygote should handle the backpropagation of the gradient through this function. This can be done using the PEPSKit.hook_pullback function from PEPSKit.jl, which allows to hook into the pullback of a given function by specifying a specific algorithm for the pullback computation. Here, we opted to use an Arnoldi method to solve the linear problem defining the gradient of the network contraction at its fixed point. This is exactly the workflow that internally underlies PEPSKit.fixedpoint, and more info on particular gradient algorithms can be found in the corresponding docstrings.","category":"page"},{"location":"examples/3d_ising_partition_function/#Characterizing-the-optimization-manifold","page":"The 3D classical Ising model","title":"Characterizing the optimization manifold","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"In order to make the best use of OptimKit.jl, we should specify some properties of the manifold on which we are optimizing. Looking at our cost function defined above, a point on our optimization manifold corresponds to a Tuple of three objects. The first is an InfinitePEPS encoding the fixed point we are actually optimizing, while the second and third are CTMRGEnv objects corresponding to the environments of the double and triple layer networks langle psi  psi rangle and langle psi  T  psi rangle respectively. While the environments are just there so we can reuse them between subsequent contractions and we don't need to think about them much, optimizing over the manifold of InfinitePEPS requires a bit more care.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"In particular, we need to define two kinds of operations on this manifold: a retraction and a transport. The retraction, corresponding to the retract keyword argument of OptimKit.optimize, specifies how to move from a point on a manifold along a given descent direction to obtain a new manifold point. The transport, corresponding to the transport! keyword argument of OptimKit.optimize, specifies how to transport a descent direction at a given manifold point to a valid descent direction at a different manifold point according to the appropriate metric. For a more detailed explanation we refer to the OptimKit.jl README. In PEPSKit.jl, these two procedures are defined through the PEPSKit.peps_retract and PEPSKit.peps_transport! methods. While it is instructive to read the corresponding docstrings in order to understand what these actually do, here we can just blindly reuse them where the only difference is that we have to pass along an extra environment since our cost function requires two distinct contractions as opposed to the setting of Hamiltonian PEPS optimization which only requires a double-layer contraction.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"function pepo_retract((peps, env_double_layer, env_triple_layer), η, α)\n    (peps´, env_double_layer´), ξ = PEPSKit.peps_retract((peps, env_double_layer), η, α)\n    env_triple_layer´ = deepcopy(env_triple_layer)\n    return (peps´, env_double_layer´, env_triple_layer´), ξ\nend\nfunction pepo_transport!(\n    ξ,\n    (peps, env_double_layer, env_triple_layer),\n    η,\n    α,\n    (peps´, env_double_layer´, env_triple_layer´),\n)\n    return PEPSKit.peps_transport!(\n        ξ, (peps, env_double_layer), η, α, (peps´, env_double_layer´)\n    )\nend;","category":"page"},{"location":"examples/3d_ising_partition_function/#Finding-the-fixed-point","page":"The 3D classical Ising model","title":"Finding the fixed point","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"All that is left then is to specify the virtual spaces of the PEPS and the two environments, initialize them in the appropriate way, choose an optimization algortithm and call the optimize function from OptimKit.jl to get our desired PEPS fixed point.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Vpeps = ℂ^2\nVenv = ℂ^12\n\npsi0 = initializePEPS(T, Vpeps)\nenv2_0 = CTMRGEnv(InfiniteSquareNetwork(psi0), Venv)\nenv3_0 = CTMRGEnv(InfiniteSquareNetwork(psi0, T), Venv)\n\noptimizer_alg = LBFGS(32; maxiter=100, gradtol=1e-5, verbosity=3)\n\n(psi_final, env2_final, env3_final), f, = optimize(\n    pepo_costfun,\n    (psi0, env2_0, env3_0),\n    optimizer_alg;\n    inner=PEPSKit.real_inner,\n    retract=pepo_retract,\n    (transport!)=(pepo_transport!),\n);","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"[ Info: LBFGS: initializing with f = -0.554073395182, ‖∇f‖ = 7.7844e-01\n┌ Warning: The function `scale!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}, Float64}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:91\n┌ Warning: CTMRG cancel 150:\tobj = +1.702942227203e+01 +1.438609955721e-07im\terr = 2.4390784904e-05\ttime = 14.97 sec\n└ @ PEPSKit ~/git/PEPSKit.jl/src/algorithms/ctmrg/ctmrg.jl:155\n[ Info: LBFGS: iter    1, time  194.26 s: f = -0.777080930424, ‖∇f‖ = 3.1305e-02, α = 7.10e+02, m = 0, nfg = 7\n┌ Warning: The function `add!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}, InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}, Int64, VectorInterface.One}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:163\n[ Info: LBFGS: iter    2, time  197.93 s: f = -0.784111515920, ‖∇f‖ = 2.0103e-02, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    3, time  199.60 s: f = -0.792705733264, ‖∇f‖ = 2.3327e-02, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, time  200.55 s: f = -0.796289732161, ‖∇f‖ = 2.2475e-02, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    5, time  201.31 s: f = -0.799674902231, ‖∇f‖ = 7.0288e-03, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    6, time  202.01 s: f = -0.800082100115, ‖∇f‖ = 1.2717e-03, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    7, time  202.82 s: f = -0.800110603120, ‖∇f‖ = 1.3384e-03, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    8, time  203.52 s: f = -0.800262202003, ‖∇f‖ = 2.4945e-03, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter    9, time  204.21 s: f = -0.800450505439, ‖∇f‖ = 2.9259e-03, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   10, time  205.05 s: f = -0.800764917063, ‖∇f‖ = 1.7221e-03, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, time  205.88 s: f = -0.800876048822, ‖∇f‖ = 2.2475e-03, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, time  206.58 s: f = -0.801100867388, ‖∇f‖ = 1.5561e-03, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, time  207.45 s: f = -0.801317048785, ‖∇f‖ = 1.1561e-03, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, time  208.22 s: f = -0.801373050522, ‖∇f‖ = 7.1300e-04, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, time  208.98 s: f = -0.801388615258, ‖∇f‖ = 2.8462e-04, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, time  209.78 s: f = -0.801394633326, ‖∇f‖ = 2.7607e-04, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, time  210.48 s: f = -0.801408061547, ‖∇f‖ = 3.6096e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, time  211.41 s: f = -0.801509542237, ‖∇f‖ = 1.9822e-03, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   19, time  212.36 s: f = -0.801578405298, ‖∇f‖ = 1.8040e-03, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   20, time  215.65 s: f = -0.801694524832, ‖∇f‖ = 2.9356e-03, α = 5.48e-01, m = 19, nfg = 3\n[ Info: LBFGS: iter   21, time  217.92 s: f = -0.801761920585, ‖∇f‖ = 1.1993e-03, α = 3.82e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   22, time  218.94 s: f = -0.801797785496, ‖∇f‖ = 6.0337e-04, α = 1.00e+00, m = 21, nfg = 1\n[ Info: LBFGS: iter   23, time  221.10 s: f = -0.801808747834, ‖∇f‖ = 3.7053e-04, α = 5.24e-01, m = 22, nfg = 2\n[ Info: LBFGS: iter   24, time  222.14 s: f = -0.801812729196, ‖∇f‖ = 3.0781e-04, α = 1.00e+00, m = 23, nfg = 1\n[ Info: LBFGS: iter   25, time  223.24 s: f = -0.801816445181, ‖∇f‖ = 2.9994e-04, α = 1.00e+00, m = 24, nfg = 1\n[ Info: LBFGS: iter   26, time  224.28 s: f = -0.801824712580, ‖∇f‖ = 3.6497e-04, α = 1.00e+00, m = 25, nfg = 1\n[ Info: LBFGS: iter   27, time  225.47 s: f = -0.801839673918, ‖∇f‖ = 5.4217e-04, α = 1.00e+00, m = 26, nfg = 1\n[ Info: LBFGS: iter   28, time  226.66 s: f = -0.801857480042, ‖∇f‖ = 2.7918e-04, α = 1.00e+00, m = 27, nfg = 1\n[ Info: LBFGS: iter   29, time  227.86 s: f = -0.801864556175, ‖∇f‖ = 1.2323e-04, α = 1.00e+00, m = 28, nfg = 1\n[ Info: LBFGS: iter   30, time  228.94 s: f = -0.801865599394, ‖∇f‖ = 8.6049e-05, α = 1.00e+00, m = 29, nfg = 1\n[ Info: LBFGS: iter   31, time  230.08 s: f = -0.801867571015, ‖∇f‖ = 8.8673e-05, α = 1.00e+00, m = 30, nfg = 1\n[ Info: LBFGS: iter   32, time  231.29 s: f = -0.801870391456, ‖∇f‖ = 2.6510e-04, α = 1.00e+00, m = 31, nfg = 1\n[ Info: LBFGS: iter   33, time  232.57 s: f = -0.801874799763, ‖∇f‖ = 2.7836e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   34, time  233.84 s: f = -0.801877566434, ‖∇f‖ = 1.8512e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   35, time  235.10 s: f = -0.801878506140, ‖∇f‖ = 2.0603e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   36, time  236.21 s: f = -0.801878994665, ‖∇f‖ = 5.6086e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   37, time  237.29 s: f = -0.801879153394, ‖∇f‖ = 6.2420e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   38, time  238.40 s: f = -0.801879354902, ‖∇f‖ = 6.0532e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   39, time  239.51 s: f = -0.801880114487, ‖∇f‖ = 6.2680e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   40, time  240.72 s: f = -0.801881471358, ‖∇f‖ = 6.2392e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   41, time  242.04 s: f = -0.801882270540, ‖∇f‖ = 9.4942e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   42, time  243.95 s: f = -0.801882598674, ‖∇f‖ = 5.1910e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   43, time  245.85 s: f = -0.801882711254, ‖∇f‖ = 2.6275e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   44, time  246.97 s: f = -0.801882805203, ‖∇f‖ = 2.9425e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   45, time  248.06 s: f = -0.801883026107, ‖∇f‖ = 2.7910e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   46, time  249.21 s: f = -0.801883400172, ‖∇f‖ = 3.7426e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   47, time  250.38 s: f = -0.801883717581, ‖∇f‖ = 5.4717e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   48, time  251.58 s: f = -0.801883966703, ‖∇f‖ = 2.9045e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   49, time  252.76 s: f = -0.801884163647, ‖∇f‖ = 3.0661e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   50, time  253.97 s: f = -0.801884391105, ‖∇f‖ = 4.1905e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   51, time  255.20 s: f = -0.801884815983, ‖∇f‖ = 6.9018e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   52, time  256.37 s: f = -0.801885013427, ‖∇f‖ = 3.8025e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   53, time  257.66 s: f = -0.801885126302, ‖∇f‖ = 1.9306e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   54, time  258.84 s: f = -0.801885184513, ‖∇f‖ = 3.3083e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   55, time  260.08 s: f = -0.801885308658, ‖∇f‖ = 4.9014e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   56, time  261.40 s: f = -0.801885502272, ‖∇f‖ = 1.1303e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   57, time  262.77 s: f = -0.801885922461, ‖∇f‖ = 7.5880e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   58, time  264.15 s: f = -0.801886457901, ‖∇f‖ = 7.2957e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   59, time  265.39 s: f = -0.801886614664, ‖∇f‖ = 6.8816e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   60, time  267.82 s: f = -0.801886696733, ‖∇f‖ = 3.0687e-05, α = 4.26e-01, m = 32, nfg = 2\n[ Info: LBFGS: iter   61, time  269.06 s: f = -0.801886716271, ‖∇f‖ = 2.1581e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   62, time  270.16 s: f = -0.801886732686, ‖∇f‖ = 1.7659e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   63, time  271.80 s: f = -0.801886790357, ‖∇f‖ = 4.1045e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   64, time  273.78 s: f = -0.801886827022, ‖∇f‖ = 4.0831e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   65, time  275.59 s: f = -0.801886871472, ‖∇f‖ = 4.1034e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   66, time  277.47 s: f = -0.801886949562, ‖∇f‖ = 5.1171e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   67, time  279.44 s: f = -0.801887066612, ‖∇f‖ = 4.5902e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   68, time  281.52 s: f = -0.801887172301, ‖∇f‖ = 7.4810e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   69, time  283.60 s: f = -0.801887249759, ‖∇f‖ = 3.9619e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   70, time  285.46 s: f = -0.801887292124, ‖∇f‖ = 1.3999e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   71, time  287.42 s: f = -0.801887312574, ‖∇f‖ = 1.0813e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   72, time  289.39 s: f = -0.801887349749, ‖∇f‖ = 1.1335e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   73, time  291.40 s: f = -0.801887427066, ‖∇f‖ = 1.9028e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   74, time  293.37 s: f = -0.801887495625, ‖∇f‖ = 1.9286e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   75, time  297.21 s: f = -0.801887521350, ‖∇f‖ = 2.5284e-05, α = 5.43e-01, m = 32, nfg = 2\n[ Info: LBFGS: iter   76, time  299.15 s: f = -0.801887560129, ‖∇f‖ = 2.7094e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: converged after 77 iterations and time 300.65 s: f = -0.801887571684, ‖∇f‖ = 7.8819e-06\n","category":"page"},{"location":"examples/3d_ising_partition_function/#Verifying-the-result","page":"The 3D classical Ising model","title":"Verifying the result","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Having found the fixed point, we have essentially contracted the entire partition function and we can start computing observables. The free energy per site for example is just given by the final value of the cost function we have just optimized.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"@show f","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"-0.8018875716841548","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"As another check, we can compute the magnetization per site and compare it to a reference value obtaind through Monte-Carlo simulations.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"n3_final = InfiniteSquareNetwork(psi_final, T)\nnum = PEPSKit.contract_local_tensor((1, 1, 1), M, n3_final, env3_final)\ndenom = PEPSKit._contract_site((1, 1), n3_final, env3_final)\nm = abs(num / denom)\n\nm_ref = 0.667162\n\n@show abs(m - m_ref)","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"0.00011017609950225715","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/boundary_mps/#e_boundary_mps","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Instead of using CTMRG to contract the network encoding the norm of an infinite PEPS, one can also use so-called boundary MPS methods to contract this network. In this example, we will demonstrate how to use the VUMPS algorithm to do so.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Before we start, we'll fix the random seed for reproducability:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"using Random\nRandom.seed!(29384293742893);","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Besides TensorKit and PEPSKit, here we also need to load the MPSKit.jl package which implements a host of tools for working with 1D matrix product states (MPS), including the VUMPS algorithm:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"using TensorKit, PEPSKit, MPSKit","category":"page"},{"location":"examples/boundary_mps/#Computing-a-PEPS-norm","page":"Boundary MPS contractions of 2D networks","title":"Computing a PEPS norm","text":"","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"We start by initializing a random infinite PEPS. Let us use uniformly distributed complex entries using rand (which sometimes lead to better convergence than Gaussian distributed randn elements):","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"peps₀ = InfinitePEPS(rand, ComplexF64, ComplexSpace(2), ComplexSpace(2))","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}[TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')):\n[:, :, 1, 1, 1] =\n 0.8343040072662887 + 0.15425705836788395im  0.4612746978522435 + 0.7411151918989216im\n 0.6640771294125087 + 0.4428356798799721im   0.9163597170532635 + 0.24145695415210522im\n\n[:, :, 2, 1, 1] =\n 0.44289651954161835 + 0.5968081052313008im   0.5473659268881094 + 0.37528062658773764im\n 0.00644367423621961 + 0.9414462569909486im  0.36006028879229457 + 0.6157267258321241im\n\n[:, :, 1, 2, 1] =\n 0.04956065285909117 + 0.26119820734171617im    0.9153298540884296 + 0.3990244910357601im\n 0.17944112964295234 + 0.4233545106724528im   0.020358359069476473 + 0.6501897922267199im\n\n[:, :, 2, 2, 1] =\n 0.040493161136161526 + 0.03501665486055905im  0.2591040734810338 + 0.8830094105726012im\n    0.781658280511654 + 0.9662812119384394im   0.8169988652653896 + 0.674481616952991im\n\n[:, :, 1, 1, 2] =\n   0.2242833355717867 + 0.14929928451790686im  0.6883051212688887 + 0.588769359105893im\n 0.046322385671192734 + 0.8543796191082029im   0.6437874016748227 + 0.257253015722232im\n\n[:, :, 2, 1, 2] =\n 0.8719996187768273 + 0.25052026742300637im  0.5714417314833022 + 0.9944321644519715im\n 0.4273547968422168 + 0.6068478826937488im   0.4946426302106661 + 0.8353867377249198im\n\n[:, :, 1, 2, 2] =\n 0.6857354516279699 + 0.0952105576480895im  0.14591923452838773 + 0.0853564870114002im\n 0.6779060054394721 + 0.4947495895268207im   0.9280821860668365 + 0.931316796924268im\n\n[:, :, 2, 2, 2] =\n 0.3716373366637086 + 0.2556099109043021im  0.7954831107819061 + 0.016909518973250215im\n 0.9376161032047406 + 0.6320864548041844im  0.7900851372111909 + 0.5457560526661245im\n;;])","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"To compute its norm, usually we would construct a double-layer InfiniteSquareNetwork which encodes the bra-ket PEPS overlap and then contract this infinite square network, for example using CTMRG. Here however, we will use another approach. If we take out a single row of this infinite norm network, we can interpret it as a 2D row-to-row transfer operator T. Here, this transfer operator consists of an effective local rank-4 tensor at every site of a 2D square lattice, where the local effective tensor is given by the contraction of a bra and ket PEPSKit.PEPSTensor across their physical leg. Since the network we want to contract can be interpreted as the infinite power of T, we can contract it by finding its leading eigenvector as a 1D MPS, which we call the boundary MPS.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"In PEPSKit.jl, we can directly construct the transfer operator corresponding to a PEPS norm network from a given infinite PEPS as an InfiniteTransferPEPS object. Additionally, we need to specify which direction should be facing north (dir=1 corresponding to north, counting clockwise) and which row is selected from the north - but since we have a trivial unit cell there is only one row:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"dir = 1 ## does not rotate the partition function\nrow = 1\nT = InfiniteTransferPEPS(peps₀, dir, row)","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"single site MPSKit.InfiniteMPO{Tuple{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}}:\n╷  ⋮\n┼ O[1]: (TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')), TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')))\n╵  ⋮\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Since we'll find the leading eigenvector of T as a boundary MPS, we first need to construct an initial guess to supply to our algorithm. We can do this using the initialize_mps function, which constructs a random MPS with a specific virtual space for a given transfer operator. Here, we'll build an initial guess for the boundary MPS with a bond dimension of 20:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"mps₀ = initialize_mps(T, [ComplexSpace(20)])","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"single site InfiniteMPS:\n│   ⋮\n│ C[1]: TensorMap(ℂ^20 ← ℂ^20)\n├── AL[1]: TensorMap((ℂ^20 ⊗ ℂ^2 ⊗ (ℂ^2)') ← ℂ^20)\n│   ⋮\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Note that this will just construct a MPS with random Gaussian entries based on the physical spaces of the supplied transfer operator. Of course, one might come up with a better initial guess (leading to better convergence) depending on the application. To find the leading boundary MPS fixed point, we call leading_boundary using the MPSKit.VUMPS algorithm from MPSKit:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"mps, env, ϵ = leading_boundary(mps₀, T, VUMPS(; tol=1e-6, verbosity=2));","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"[ Info: VUMPS init:\tobj = +5.052950412844e+00 +1.493192627823e-02im\terr = 8.4684e-01\n[ Info: VUMPS conv 4:\tobj = +1.744071150138e+01 +2.417441557995e-08im\terr = 1.9047772246e-07\ttime = 3.69 sec\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"The norm of the state per unit cell is then given by the expectation value langle psi_textMPS  mathbbT  psi_textMPS rangle:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"norm_vumps = abs(prod(expectation_value(mps, T)))","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"17.440711501378814","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"This can be compared to the result obtained using CTMRG, where we see that the results match:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"env_ctmrg, = leading_boundary(\n    CTMRGEnv(peps₀, ComplexSpace(20)), peps₀; tol=1e-6, verbosity=2\n)\nnorm_ctmrg = abs(norm(peps₀, env_ctmrg))\n@show abs(norm_vumps - norm_ctmrg) / norm_vumps;","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"[ Info: CTMRG init:\tobj = -5.556349490423e-01 +1.605938670370e+00im\terr = 1.0000e+00\n[ Info: CTMRG conv 37:\tobj = +1.744071151099e+01\terr = 3.2056303631e-07\ttime = 4.37 sec\nabs(norm_vumps - norm_ctmrg) / norm_vumps = 5.510362083182129e-10\n","category":"page"},{"location":"examples/boundary_mps/#Working-with-unit-cells","page":"Boundary MPS contractions of 2D networks","title":"Working with unit cells","text":"","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"For PEPS with non-trivial unit cells, the principle is exactly the same. The only difference is that now the transfer operator of the PEPS norm partition function has multiple rows or 'lines', each of which can be represented by an InfiniteTransferPEPS object. Such a multi-line transfer operator is represented by a MultilineTransferPEPS object. In this case, the boundary MPS is an MultilineMPS object, which should be initialized by specifying a virtual space for each site in the partition function unit cell.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"First, we construct a PEPS with a 2 times 2 unit cell using the unitcell keyword argument and then define the corresponding transfer operator, where we again specify the direction which will be facing north:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"peps₀_2x2 = InfinitePEPS(\n    rand, ComplexF64, ComplexSpace(2), ComplexSpace(2); unitcell=(2, 2)\n)\nT_2x2 = PEPSKit.MultilineTransferPEPS(peps₀_2x2, dir);","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Now, the procedure is the same as before: We compute the norm once using VUMPS, once using CTMRG and then compare.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"mps₀_2x2 = initialize_mps(T_2x2, fill(ComplexSpace(20), 2, 2))\nmps_2x2, = leading_boundary(mps₀_2x2, T_2x2, VUMPS(; tol=1e-6, verbosity=2))\nnorm_2x2_vumps = abs(prod(expectation_value(mps_2x2, T_2x2)))\n\nenv_ctmrg_2x2, = leading_boundary(\n    CTMRGEnv(peps₀_2x2, ComplexSpace(20)), peps₀_2x2; tol=1e-6, verbosity=2\n)\nnorm_2x2_ctmrg = abs(norm(peps₀_2x2, env_ctmrg_2x2))\n\n@show abs(norm_2x2_vumps - norm_2x2_ctmrg) / norm_2x2_vumps;","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"[ Info: VUMPS init:\tobj = +6.668046237341e+02 -1.267878277078e+01im\terr = 8.7901e-01\n[ Info: VUMPS conv 69:\tobj = +9.723958968917e+04 -3.481605377714e-03im\terr = 6.3841720875e-07\ttime = 4.12 sec\n[ Info: CTMRG init:\tobj = +1.074898090007e+03 -2.096255594496e+02im\terr = 1.0000e+00\n[ Info: CTMRG conv 41:\tobj = +9.723959008610e+04\terr = 6.0518230963e-07\ttime = 1.54 sec\nabs(norm_2x2_vumps - norm_2x2_ctmrg) / norm_2x2_vumps = 4.08201516090106e-9\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Again, the results are compatible. Note that for larger unit cells and non-Hermitian PEPS the VUMPS algorithm may become unstable, in which case the CTMRG algorithm is recommended.","category":"page"},{"location":"examples/boundary_mps/#Contracting-PEPO-overlaps","page":"Boundary MPS contractions of 2D networks","title":"Contracting PEPO overlaps","text":"","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Using exactly the same machinery, we can contract 2D networks which encode the expectation value of a PEPO for a given PEPS state. As an example, we can consider the overlap of the PEPO correponding to the partition function of 3D classical Ising model with our random PEPS from before and evaluate the overlap langle psi_textPEPS  O_textPEPO  psi_textPEPS rangle.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"The classical Ising PEPO is defined as follows:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"function ising_pepo(β; unitcell=(1, 1, 1))\n    t = ComplexF64[exp(β) exp(-β); exp(-β) exp(β)]\n    q = sqrt(t)\n\n    O = zeros(2, 2, 2, 2, 2, 2)\n    O[1, 1, 1, 1, 1, 1] = 1\n    O[2, 2, 2, 2, 2, 2] = 1\n    @tensor o[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n    O = TensorMap(o, ℂ^2 ⊗ (ℂ^2)' ← ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')\n\n    return InfinitePEPO(O; unitcell)\nend;","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"To evaluate the overlap, we instantiate the PEPO and the corresponding InfiniteTransferPEPO in the right direction, on the right row of the partition function (trivial here):","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"pepo = ising_pepo(1)\ntransfer_pepo = InfiniteTransferPEPO(peps₀, pepo, 1, 1)","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"single site MPSKit.InfiniteMPO{Tuple{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 4, Vector{ComplexF64}}}}:\n╷  ⋮\n┼ O[1]: (TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')), TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')), TensorMap((ℂ^2 ⊗ (ℂ^2)') ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')))\n╵  ⋮\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"As before, we converge the boundary MPS using VUMPS and then compute the expectation value:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"mps₀_pepo = initialize_mps(transfer_pepo, [ComplexSpace(20)])\nmps_pepo, = leading_boundary(mps₀_pepo, transfer_pepo, VUMPS(; tol=1e-6, verbosity=2))\nnorm_pepo = abs(prod(expectation_value(mps_pepo, transfer_pepo)));\n@show norm_pepo;","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"[ Info: VUMPS init:\tobj = +3.309203535702e+01 -4.227375981212e-01im\terr = 9.3280e-01\n[ Info: VUMPS conv 5:\tobj = +2.483696258643e+02 +2.387851822319e-07im\terr = 5.0174146749e-08\ttime = 2.69 sec\nnorm_pepo = 248.36962586428106\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"These objects and routines can be used to optimize PEPS fixed points of 3D partition functions, see for example Vanderstraeten et al.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/bose_hubbard/#Optimizing-the-U(1)-symmetric-Bose-Hubbard-model","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"","category":"section"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"This example demonstrates the simulation of the two-dimensional Bose-Hubbard model. In particular, the point will be to showcase the use of internal symmetries and finite particle densities in PEPS ground state searches. As we will see, incorporating symmetries into the simulation consists of initializing a symmetric Hamiltonian, PEPS state and CTM environment - made possible through TensorKit.","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"But first let's seed the RNG and import the required modules:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"using Random\nusing TensorKit, PEPSKit\nusing MPSKit: add_physical_charge\nRandom.seed!(2928528935);","category":"page"},{"location":"examples/bose_hubbard/#Defining-the-model","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Defining the model","text":"","category":"section"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"We will construct the Bose-Hubbard model Hamiltonian through the bose_hubbard_model, function from MPSKitModels as reexported by PEPSKit. We'll simulate the model in its Mott-insulating phase where the ratio Ut is large, since in this phase we expect the ground state to be well approximated by a PEPS with a manifest global U(1) symmetry. Furthermore, we'll impose a cutoff at 2 bosons per site, set the chemical potential to zero and use a simple 1 times 1 unit cell:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"t = 1.0\nU = 30.0\ncutoff = 2\nmu = 0.0\nlattice = InfiniteSquare(1, 1);","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Next, we impose an explicit global U(1) symmetry as well as a fixed particle number density in our simulations. We can do this by setting the symmetry argument of the Hamiltonian constructor to U1Irrep and passing one as the particle number density keyword argument n:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"symmetry = U1Irrep\nn = 1\nH = bose_hubbard_model(ComplexF64, symmetry, lattice; cutoff, t, U, n);","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Before we continue, it might be interesting to inspect the corresponding lattice physical spaces (which is here just a 1 times 1 matrix due to the single-site unit cell):","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"physical_spaces = physicalspace(H)","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"1×1 Matrix{TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}}:\n Rep[TensorKitSectors.U₁](0=>1, 1=>1, -1=>1)","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Note that the physical space contains U(1) charges -1, 0 and +1. Indeed, imposing a particle number density of +1 corresponds to shifting the physical charges by -1 to 're-center' the physical charges around the desired density. When we do this with a cutoff of two bosons per site, i.e. starting from U(1) charges 0, 1 and 2 on the physical level, we indeed get the observed charges.","category":"page"},{"location":"examples/bose_hubbard/#Characterizing-the-virtual-spaces","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Characterizing the virtual spaces","text":"","category":"section"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"When running PEPS simulations with explicit internal symmetries, specifying the structure of the virtual spaces of the PEPS and its environment becomes a bit more involved. For the environment, one could in principle allow the virtual space to be chosen dynamically during the boundary contraction using CTMRG by using a truncation scheme that allows for this (e.g. using alg=:truncdim or alg=:truncbelow to truncate to a fixed total bond dimension or singular value cutoff respectively). For the PEPS virtual space however, the structure has to be specified before the optimization.","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"While there are a host of techniques to do this in an informed way (e.g. starting from a simple update result), here we just specify the virtual space manually. Since we're dealing with a model at unit filling our physical space only contains integer U(1) irreps. Therefore, we'll build our PEPS and environment spaces using integer U(1) irreps centered around the zero charge:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"V_peps = U1Space(0 => 2, 1 => 1, -1 => 1)\nV_env = U1Space(0 => 6, 1 => 4, -1 => 4, 2 => 2, -2 => 2);","category":"page"},{"location":"examples/bose_hubbard/#Finding-the-ground-state","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Finding the ground state","text":"","category":"section"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Having defined our Hamiltonian and spaces, it is just a matter of plugging this into the optimization framework in the usual way to find the ground state. So, we first specify all algorithms and their tolerances:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"boundary_alg = (; tol=1e-8, alg=:simultaneous, trscheme=(; alg=:fixedspace))\ngradient_alg = (; tol=1e-6, maxiter=10, alg=:eigsolver, iterscheme=:diffgauge)\noptimizer_alg = (; tol=1e-4, alg=:lbfgs, maxiter=150, ls_maxiter=2, ls_maxfg=2);","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"note: Note\nTaking CTMRG gradients and optimizing symmetric tensors tends to be more problematic than with dense tensors. In particular, this means that one frequently needs to tweak the boundary_alg, gradient_alg and optimizer_alg settings. There rarely is a general-purpose set of settings which will always work, so instead one has to adjust the simulation settings for each specific application. For example, it might help to switch between the CTMRG flavors alg=:simultaneous and alg=:sequential to improve convergence. The evaluation of the CTMRG gradient can be instable, so there it is advised to try the different iterscheme=:diffgauge and iterscheme=:fixed schemes as well as different alg keywords. Of course the tolerances of the algorithms and their subalgorithms also have to be compatible. For more details on the available options, see the fixedpoint docstring.","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Keep in mind that the PEPS is constructed from a unit cell of spaces, so we have to make a matrix of V_peps spaces:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"virtual_spaces = fill(V_peps, size(lattice)...)\npeps₀ = InfinitePEPS(randn, ComplexF64, physical_spaces, virtual_spaces)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, V_env), peps₀; boundary_alg...);","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"[ Info: CTMRG init:\tobj = +1.693461429863e+00 +8.390974048721e-02im\terr = 1.0000e+00\n[ Info: CTMRG conv 19:\tobj = +1.181834754305e+01 -1.514255254857e-11im\terr = 3.6943032119e-09\ttime = 8.27 sec\n","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"And at last, we optimize (which might take a bit):","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"peps, env, E, info = fixedpoint(\n    H, peps₀, env₀; boundary_alg, gradient_alg, optimizer_alg, verbosity=3\n)\n@show E;","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"[ Info: LBFGS: initializing with f = 9.360531870693, ‖∇f‖ = 1.6957e+01\n┌ Warning: The function `scale!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}, 1, 4, Vector{ComplexF64}}}, Float64}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:91\n[ Info: LBFGS: iter    1, time  862.65 s: f = 0.112865330403, ‖∇f‖ = 5.9876e+00, α = 1.56e+02, m = 0, nfg = 7\n┌ Warning: The function `add!!` is not implemented for (values of) type `Tuple{InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}, 1, 4, Vector{ComplexF64}}}, InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}, 1, 4, Vector{ComplexF64}}}, Int64, VectorInterface.One}`;\n│ this fallback will disappear in future versions of VectorInterface.jl\n└ @ VectorInterface ~/.julia/packages/VectorInterface/J6qCR/src/fallbacks.jl:163\n[ Info: LBFGS: iter    2, time  875.83 s: f = 0.031016651818, ‖∇f‖ = 4.7981e+00, α = 5.55e-01, m = 1, nfg = 2\n[ Info: LBFGS: iter    3, time  878.38 s: f = -0.073286659944, ‖∇f‖ = 1.4991e+00, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, time  881.06 s: f = -0.113074511097, ‖∇f‖ = 1.4104e+00, α = 1.00e+00, m = 3, nfg = 1\n┌ Warning: Linesearch not converged after 2 iterations and 3 function evaluations:\n│ α = 4.53e-02, dϕ = -5.09e-01, ϕ - ϕ₀ = -2.42e-02\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    5, time  888.55 s: f = -0.137293934550, ‖∇f‖ = 1.3317e+00, α = 4.53e-02, m = 4, nfg = 3\n┌ Warning: Linesearch not converged after 2 iterations and 3 function evaluations:\n│ α = 4.19e-02, dϕ = -3.58e-01, ϕ - ϕ₀ = -1.56e-02\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    6, time  896.03 s: f = -0.152882613133, ‖∇f‖ = 1.2515e+00, α = 4.19e-02, m = 5, nfg = 3\n[ Info: LBFGS: iter    7, time  906.18 s: f = -0.167778524643, ‖∇f‖ = 3.0370e+00, α = 3.97e-01, m = 6, nfg = 4\n[ Info: LBFGS: iter    8, time  908.59 s: f = -0.200610144885, ‖∇f‖ = 8.4562e-01, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter    9, time  911.30 s: f = -0.214869049363, ‖∇f‖ = 5.6088e-01, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   10, time  913.43 s: f = -0.222910672089, ‖∇f‖ = 9.8015e-01, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, time  915.49 s: f = -0.230707833300, ‖∇f‖ = 4.2302e-01, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, time  917.75 s: f = -0.238105633372, ‖∇f‖ = 2.5801e-01, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, time  919.64 s: f = -0.247331854867, ‖∇f‖ = 3.2459e-01, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, time  920.70 s: f = -0.253845651144, ‖∇f‖ = 2.4014e-01, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, time  922.02 s: f = -0.261289607017, ‖∇f‖ = 3.3777e-01, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, time  922.92 s: f = -0.267178486858, ‖∇f‖ = 2.0556e-01, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, time  923.72 s: f = -0.269417408686, ‖∇f‖ = 1.4442e-01, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, time  924.84 s: f = -0.270255942689, ‖∇f‖ = 7.8602e-02, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   19, time  925.66 s: f = -0.270672366603, ‖∇f‖ = 6.3259e-02, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   20, time  926.46 s: f = -0.271220543802, ‖∇f‖ = 8.8755e-02, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   21, time  927.59 s: f = -0.271543527453, ‖∇f‖ = 4.5233e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   22, time  928.38 s: f = -0.271650756946, ‖∇f‖ = 3.4057e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, time  929.16 s: f = -0.271894826592, ‖∇f‖ = 3.1507e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, time  930.27 s: f = -0.272056350007, ‖∇f‖ = 3.7796e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, time  931.08 s: f = -0.272233548851, ‖∇f‖ = 2.8370e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, time  931.89 s: f = -0.272383908712, ‖∇f‖ = 2.2903e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, time  933.01 s: f = -0.272455167221, ‖∇f‖ = 4.0448e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, time  933.79 s: f = -0.272553540301, ‖∇f‖ = 2.1431e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, time  934.56 s: f = -0.272695812729, ‖∇f‖ = 2.3543e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, time  935.67 s: f = -0.272771651851, ‖∇f‖ = 2.0076e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, time  936.45 s: f = -0.272799750606, ‖∇f‖ = 4.7874e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, time  937.23 s: f = -0.272878619780, ‖∇f‖ = 1.7612e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, time  938.34 s: f = -0.272929741282, ‖∇f‖ = 1.5455e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, time  939.14 s: f = -0.273001510559, ‖∇f‖ = 2.3641e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, time  939.94 s: f = -0.273050577801, ‖∇f‖ = 1.6253e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, time  941.06 s: f = -0.273061460544, ‖∇f‖ = 2.5195e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, time  941.84 s: f = -0.273079875270, ‖∇f‖ = 7.2299e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, time  942.63 s: f = -0.273083995266, ‖∇f‖ = 6.2322e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, time  943.75 s: f = -0.273091490830, ‖∇f‖ = 7.8002e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, time  944.54 s: f = -0.273097801979, ‖∇f‖ = 9.2495e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, time  945.33 s: f = -0.273103085883, ‖∇f‖ = 5.9273e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, time  946.45 s: f = -0.273106428950, ‖∇f‖ = 5.6938e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, time  947.24 s: f = -0.273111266609, ‖∇f‖ = 9.0725e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, time  948.06 s: f = -0.273121071175, ‖∇f‖ = 1.2386e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, time  949.20 s: f = -0.273137645098, ‖∇f‖ = 1.2942e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   46, time  950.82 s: f = -0.273141136808, ‖∇f‖ = 1.4282e-02, α = 1.35e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   47, time  951.96 s: f = -0.273154777599, ‖∇f‖ = 7.0317e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, time  952.79 s: f = -0.273161148021, ‖∇f‖ = 3.4952e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, time  953.57 s: f = -0.273164175099, ‖∇f‖ = 4.7738e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, time  954.68 s: f = -0.273166242670, ‖∇f‖ = 5.4242e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   51, time  955.48 s: f = -0.273168481006, ‖∇f‖ = 3.6862e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, time  956.27 s: f = -0.273172228386, ‖∇f‖ = 4.8463e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, time  957.40 s: f = -0.273174650673, ‖∇f‖ = 6.4469e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, time  958.18 s: f = -0.273178852481, ‖∇f‖ = 7.4990e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, time  958.98 s: f = -0.273186651745, ‖∇f‖ = 8.2158e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   56, time  960.10 s: f = -0.273190544009, ‖∇f‖ = 8.6751e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, time  960.89 s: f = -0.273194527074, ‖∇f‖ = 2.7365e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, time  961.68 s: f = -0.273195816168, ‖∇f‖ = 2.9114e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, time  962.81 s: f = -0.273197625913, ‖∇f‖ = 3.0896e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, time  963.60 s: f = -0.273198605154, ‖∇f‖ = 1.0394e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, time  964.39 s: f = -0.273202461926, ‖∇f‖ = 3.0652e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   62, time  965.50 s: f = -0.273203714519, ‖∇f‖ = 2.0133e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, time  966.28 s: f = -0.273204828019, ‖∇f‖ = 2.5951e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, time  968.19 s: f = -0.273205465822, ‖∇f‖ = 4.1444e-03, α = 4.87e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   65, time  969.01 s: f = -0.273206458356, ‖∇f‖ = 2.9919e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, time  969.82 s: f = -0.273208249293, ‖∇f‖ = 1.6948e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, time  970.96 s: f = -0.273208839969, ‖∇f‖ = 3.0193e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, time  971.74 s: f = -0.273209433106, ‖∇f‖ = 1.8534e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, time  972.52 s: f = -0.273210019598, ‖∇f‖ = 1.7898e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, time  973.63 s: f = -0.273211075315, ‖∇f‖ = 2.7930e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, time  974.42 s: f = -0.273212703695, ‖∇f‖ = 3.6612e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, time  975.22 s: f = -0.273214163920, ‖∇f‖ = 6.1973e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, time  976.34 s: f = -0.273216147362, ‖∇f‖ = 2.7120e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, time  977.11 s: f = -0.273217199407, ‖∇f‖ = 2.2842e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, time  977.91 s: f = -0.273218358117, ‖∇f‖ = 3.0566e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, time  979.04 s: f = -0.273219638996, ‖∇f‖ = 3.8811e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, time  979.83 s: f = -0.273221240011, ‖∇f‖ = 4.4440e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, time  980.62 s: f = -0.273222619191, ‖∇f‖ = 2.8356e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, time  981.74 s: f = -0.273223777532, ‖∇f‖ = 2.2842e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   80, time  982.53 s: f = -0.273224631407, ‖∇f‖ = 2.6013e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   81, time  983.33 s: f = -0.273225621866, ‖∇f‖ = 2.7625e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   82, time  984.46 s: f = -0.273226222472, ‖∇f‖ = 2.5785e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   83, time  985.23 s: f = -0.273226603039, ‖∇f‖ = 1.2203e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   84, time  986.03 s: f = -0.273226890308, ‖∇f‖ = 1.1848e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   85, time  987.16 s: f = -0.273227256564, ‖∇f‖ = 1.8281e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   86, time  987.96 s: f = -0.273227922952, ‖∇f‖ = 2.0191e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   87, time  989.91 s: f = -0.273228177117, ‖∇f‖ = 2.7409e-03, α = 3.30e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   88, time  990.72 s: f = -0.273228564518, ‖∇f‖ = 1.5762e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   89, time  991.52 s: f = -0.273228984011, ‖∇f‖ = 1.3435e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   90, time  992.64 s: f = -0.273229366257, ‖∇f‖ = 1.9460e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   91, time  993.46 s: f = -0.273230207912, ‖∇f‖ = 2.9080e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   92, time  994.25 s: f = -0.273231202568, ‖∇f‖ = 3.4541e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   93, time  995.36 s: f = -0.273232085510, ‖∇f‖ = 1.8388e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   94, time  996.15 s: f = -0.273232631167, ‖∇f‖ = 1.1594e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   95, time  996.93 s: f = -0.273232992148, ‖∇f‖ = 1.7787e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   96, time  998.04 s: f = -0.273233316686, ‖∇f‖ = 1.5449e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   97, time  998.85 s: f = -0.273233676058, ‖∇f‖ = 1.8482e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   98, time  999.62 s: f = -0.273233957076, ‖∇f‖ = 1.5452e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   99, time 1000.72 s: f = -0.273234130308, ‖∇f‖ = 1.2047e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  100, time 1001.53 s: f = -0.273234491906, ‖∇f‖ = 1.3723e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  101, time 1002.32 s: f = -0.273234862722, ‖∇f‖ = 2.2468e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  102, time 1003.43 s: f = -0.273235395986, ‖∇f‖ = 1.8201e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  103, time 1004.23 s: f = -0.273235884374, ‖∇f‖ = 1.7284e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  104, time 1005.03 s: f = -0.273236273215, ‖∇f‖ = 1.3732e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  105, time 1006.16 s: f = -0.273236575790, ‖∇f‖ = 1.4651e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  106, time 1006.95 s: f = -0.273236948216, ‖∇f‖ = 1.8153e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  107, time 1007.75 s: f = -0.273237435467, ‖∇f‖ = 2.6401e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  108, time 1008.87 s: f = -0.273237969174, ‖∇f‖ = 1.3197e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  109, time 1009.67 s: f = -0.273238333588, ‖∇f‖ = 1.0300e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  110, time 1010.46 s: f = -0.273238606412, ‖∇f‖ = 1.3512e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  111, time 1011.58 s: f = -0.273238763494, ‖∇f‖ = 2.0868e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  112, time 1012.38 s: f = -0.273238992097, ‖∇f‖ = 1.0034e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  113, time 1013.17 s: f = -0.273239242010, ‖∇f‖ = 1.0445e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  114, time 1014.29 s: f = -0.273239539038, ‖∇f‖ = 1.4904e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  115, time 1015.09 s: f = -0.273239986741, ‖∇f‖ = 1.4425e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  116, time 1017.02 s: f = -0.273240116483, ‖∇f‖ = 1.9754e-03, α = 2.24e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter  117, time 1017.83 s: f = -0.273240380183, ‖∇f‖ = 9.8175e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  118, time 1018.62 s: f = -0.273240575426, ‖∇f‖ = 8.6345e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  119, time 1019.74 s: f = -0.273240832012, ‖∇f‖ = 1.4287e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  120, time 1020.53 s: f = -0.273241210750, ‖∇f‖ = 1.8219e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  121, time 1022.47 s: f = -0.273241482573, ‖∇f‖ = 2.4856e-03, α = 5.47e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter  122, time 1023.28 s: f = -0.273241934058, ‖∇f‖ = 1.5033e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  123, time 1024.10 s: f = -0.273242166393, ‖∇f‖ = 1.2112e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  124, time 1025.25 s: f = -0.273242322900, ‖∇f‖ = 1.0134e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  125, time 1026.06 s: f = -0.273242508033, ‖∇f‖ = 1.0745e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  126, time 1026.87 s: f = -0.273242887106, ‖∇f‖ = 2.1256e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  127, time 1028.00 s: f = -0.273243341793, ‖∇f‖ = 1.6582e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  128, time 1028.81 s: f = -0.273243624575, ‖∇f‖ = 1.0434e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  129, time 1029.63 s: f = -0.273243926598, ‖∇f‖ = 1.0170e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  130, time 1030.76 s: f = -0.273244130570, ‖∇f‖ = 1.7663e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  131, time 1031.56 s: f = -0.273244384615, ‖∇f‖ = 1.4424e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  132, time 1032.37 s: f = -0.273244721419, ‖∇f‖ = 1.5925e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  133, time 1033.50 s: f = -0.273244883706, ‖∇f‖ = 1.0143e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  134, time 1034.30 s: f = -0.273244978610, ‖∇f‖ = 9.4449e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  135, time 1035.10 s: f = -0.273245503204, ‖∇f‖ = 1.2344e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  136, time 1036.22 s: f = -0.273245739413, ‖∇f‖ = 2.7009e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  137, time 1037.03 s: f = -0.273246059451, ‖∇f‖ = 1.4108e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  138, time 1037.84 s: f = -0.273246259501, ‖∇f‖ = 6.7238e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  139, time 1038.97 s: f = -0.273246408570, ‖∇f‖ = 9.2687e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  140, time 1039.79 s: f = -0.273246576606, ‖∇f‖ = 1.2150e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  141, time 1040.60 s: f = -0.273246729060, ‖∇f‖ = 1.3157e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  142, time 1041.73 s: f = -0.273246873413, ‖∇f‖ = 7.6123e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  143, time 1042.52 s: f = -0.273247027465, ‖∇f‖ = 7.9430e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  144, time 1043.32 s: f = -0.273247180548, ‖∇f‖ = 1.0894e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  145, time 1044.45 s: f = -0.273247387426, ‖∇f‖ = 2.2553e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  146, time 1045.24 s: f = -0.273247645050, ‖∇f‖ = 1.1468e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  147, time 1046.05 s: f = -0.273247846912, ‖∇f‖ = 9.1650e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  148, time 1047.17 s: f = -0.273248001067, ‖∇f‖ = 8.8945e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  149, time 1048.03 s: f = -0.273248315567, ‖∇f‖ = 1.2684e-03, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 150 iterations and time 1050.00 s: f = -0.273248467359, ‖∇f‖ = 1.1430e-03\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/lbfgs.jl:197\nE = -0.2732484673593871\n","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"We can compare our PEPS result to the energy obtained using a cylinder-MPS calculation using a cylinder circumference of L_y = 7 and a bond dimension of 446, which yields E = -0273284888:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"E_ref = -0.273284888\n@show (E - E_ref) / E_ref;","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"(E - E_ref) / E_ref = -0.00013326986676584008\n","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/hubbard_su/#Simple-update-for-the-Fermi-Hubbard-model-at-half-filling","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"","category":"section"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Once again, we consider the Hubbard model but this time we obtain the ground-state PEPS by imaginary time evolution. In particular, we'll use the SimpleUpdate algorithm. As a reminder, we define the Hubbard model as","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"H = -t sum_langle ij rangle sum_sigma left( c_isigma^+ c_jsigma^- -\nc_isigma^- c_jsigma^+ right) + U sum_i n_iuparrown_idownarrow - mu sum_i n_i","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"with sigma in uparrowdownarrow and n_isigma = c_isigma^+ c_isigma^-.","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Let's get started by seeding the RNG and importing the required modules:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"using Random\nusing TensorKit, PEPSKit\nRandom.seed!(12329348592498);","category":"page"},{"location":"examples/hubbard_su/#Defining-the-Hamiltonian","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Defining the Hamiltonian","text":"","category":"section"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"First, we define the Hubbard model at t=1 hopping and U=6 using Trivial sectors for the particle and spin symmetries, and set mu = U2 for half-filling. The model will be constructed on a 2 times 2 unit cell, so we have:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"t = 1\nU = 6\nNr, Nc = 2, 2\nH = hubbard_model(Float64, Trivial, Trivial, InfiniteSquare(Nr, Nc); t, U, mu=U / 2);","category":"page"},{"location":"examples/hubbard_su/#Running-the-simple-update-algorithm","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Running the simple update algorithm","text":"","category":"section"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Next, we'll specify the virtual PEPS bond dimension and define the fermionic physical and virtual spaces. The simple update algorithm evolves an infinite PEPS with weights on the virtual bonds, so we here need to intialize an InfiniteWeightPEPS. By default, the bond weights will be identity. Unlike in the other examples, we here use tensors with real Float64 entries:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Dbond = 8\nphysical_space = Vect[fℤ₂](0 => 2, 1 => 2)\nvirtual_space = Vect[fℤ₂](0 => Dbond / 2, 1 => Dbond / 2)\nwpeps = InfiniteWeightPEPS(rand, Float64, physical_space, virtual_space; unitcell=(Nr, Nc));","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Let's set the algorithm parameters: The plan is to successively decrease the time interval of the Trotter-Suzuki as well as the convergence tolerance such that we obtain a more accurate result at each iteration. To run the simple update, we call simpleupdate where we use the keyword bipartite=false - meaning that we use the full 2 times 2 unit cell without assuming a bipartite structure. Thus, we can start evolving:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"dts = [1e-2, 1e-3, 4e-4, 1e-4]\ntols = [1e-6, 1e-8, 1e-8, 1e-8]\nmaxiter = 20000\n\nfor (n, (dt, tol)) in enumerate(zip(dts, tols))\n    trscheme = truncerr(1e-10) & truncdim(Dbond)\n    alg = SimpleUpdate(dt, tol, maxiter, trscheme)\n    global wpeps, = simpleupdate(wpeps, H, alg; bipartite=false)\nend","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 2.355e+00,  time = 19.473 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 500    :  dt = 1e-02,  weight diff = 3.984e-04,  time = 0.020 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1000   :  dt = 1e-02,  weight diff = 2.866e-06,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU conv 1061   :  dt = 1e-02,  weight diff = 9.956e-07,  time = 38.226 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1      :  dt = 1e-03,  weight diff = 6.070e-03,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 500    :  dt = 1e-03,  weight diff = 1.874e-06,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1000   :  dt = 1e-03,  weight diff = 6.437e-07,  time = 0.019 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1500   :  dt = 1e-03,  weight diff = 2.591e-07,  time = 0.019 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 2000   :  dt = 1e-03,  weight diff = 1.053e-07,  time = 0.019 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 2500   :  dt = 1e-03,  weight diff = 4.280e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 3000   :  dt = 1e-03,  weight diff = 1.741e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU conv 3309   :  dt = 1e-03,  weight diff = 9.983e-09,  time = 53.956 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1      :  dt = 4e-04,  weight diff = 4.030e-04,  time = 0.020 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 500    :  dt = 4e-04,  weight diff = 1.776e-07,  time = 0.019 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1000   :  dt = 4e-04,  weight diff = 7.091e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1500   :  dt = 4e-04,  weight diff = 3.997e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 2000   :  dt = 4e-04,  weight diff = 2.622e-08,  time = 0.020 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 2500   :  dt = 4e-04,  weight diff = 1.796e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 3000   :  dt = 4e-04,  weight diff = 1.245e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU conv 3303   :  dt = 4e-04,  weight diff = 9.997e-09,  time = 54.244 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1      :  dt = 1e-04,  weight diff = 2.014e-04,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 500    :  dt = 1e-04,  weight diff = 5.664e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1000   :  dt = 1e-04,  weight diff = 4.106e-08,  time = 0.020 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 1500   :  dt = 1e-04,  weight diff = 3.033e-08,  time = 0.021 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 2000   :  dt = 1e-04,  weight diff = 2.290e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 2500   :  dt = 1e-04,  weight diff = 1.773e-08,  time = 0.015 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 3000   :  dt = 1e-04,  weight diff = 1.410e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU iter 3500   :  dt = 1e-04,  weight diff = 1.152e-08,  time = 0.014 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>4, 1=>4)\n[ Info: SU conv 3893   :  dt = 1e-04,  weight diff = 9.997e-09,  time = 63.901 sec\n","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"To obtain the evolved InfiniteWeightPEPS as an actual PEPS without weights on the bonds, we can just call the following constructor:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"peps = InfinitePEPS(wpeps);","category":"page"},{"location":"examples/hubbard_su/#Computing-the-ground-state-energy","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Computing the ground-state energy","text":"","category":"section"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"In order to compute the energy expectation value with evolved PEPS, we need to converge a CTMRG environment on it. We first converge an environment with a small enviroment dimension and then use that to initialize another run with bigger environment dimension. We'll use trscheme=truncdim(χ) for that such that the dimension is increased during the second CTMRG run:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"χenv₀, χenv = 6, 16\nenv_space = Vect[fℤ₂](0 => χenv₀ / 2, 1 => χenv₀ / 2)\n\nenv = CTMRGEnv(rand, Float64, peps, env_space)\nfor χ in [χenv₀, χenv]\n    global env, = leading_boundary(\n        env, peps; alg=:sequential, tol=1e-5, trscheme=truncdim(χ)\n    )\nend","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"[ Info: CTMRG init:\tobj = -1.542952315399e-10\terr = 1.0000e+00\n┌ Warning: CTMRG cancel 100:\tobj = +6.169093163834e-01\terr = 5.9784504048e-01\ttime = 32.80 sec\n└ @ PEPSKit ~/repos/PEPSKit.jl/src/algorithms/ctmrg/ctmrg.jl:155\n[ Info: CTMRG init:\tobj = +6.169093163834e-01\terr = 1.0000e+00\n[ Info: CTMRG conv 30:\tobj = +5.888235783866e-01\terr = 4.9402085825e-06\ttime = 1.24 min\n","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"We measure the energy by computing the H expectation value, where we have to make sure to normalize with respect to the unit cell to obtain the energy per site:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"E = expectation_value(peps, H, env) / (Nr * Nc)\n@show E;","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"E = -3.633302571096653\n","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Finally, we can compare the obtained ground-state energy against the literature, namely the QMC estimates from Qin et al.. We find that the results generally agree:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Es_exact = Dict(0 => -1.62, 2 => -0.176, 4 => 0.8603, 6 => -0.6567, 8 => -0.5243)\nE_exact = Es_exact[U] - U / 2\n@show (E - E_exact) / E_exact;","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"(E - E_exact) / E_exact = -0.006398509285242631\n","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#PEPSKit.jl","page":"Home","title":"PEPSKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for working with projected entangled-pair states","category":"page"},{"location":"","page":"Home","title":"Home","text":"It contracts, it optimizes, it may break.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed through the Julia general registry, via the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PEPSKit","category":"page"},{"location":"#Key-features","page":"Home","title":"Key features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Construction and manipulation of infinite projected entangled-pair states (PEPS)\nContraction of infinite PEPS using the corner transfer matrix renormalization group (CTMRG) and boundary MPS methods\nNative support for symmetric tensors through TensorKit, including fermionic tensors\nPEPS optimization using automatic differentiation (AD) provided through Zygote\nImaginary time evolution algorithms\nSupport for PEPS with generic unit cells\nSupport for classical 2D partition functions and projected entangled-pair operators (PEPOs)\nExtensible system for custom states, operators and algorithms","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After following the installation process, it should now be possible to load the packages and start simulating. For example, in order to obtain the ground state of the 2D Heisenberg model, we can use the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorKit, PEPSKit\n\n# construct the Hamiltonian\nH = heisenberg_XYZ(InfiniteSquare())\n\n# configure the parameters\nD = 2\nχ = 20\nctmrg_tol = 1e-10\ngrad_tol = 1e-4\n\n# initialize a PEPS and CTMRG environment\npeps₀ = InfinitePEPS(2, D)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, ComplexSpace(χ)), peps₀; tol=ctmrg_tol)\n\n# ground state search\npeps, env, E, = fixedpoint(H, peps₀, env₀; tol=grad_tol, boundary_alg=(; tol=ctmrg_tol))\n\n@show E # -0.6625...","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more in-depth explanation of this simple example, check the Optimizing the 2D Heisenberg model tutorial or consult the Manual pages.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A detailed rundown of PEPSKit's features can be found in the Manual section (not yet complete, more coming soon™), including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/models.md\", \"man/multithreading.md\", \"man/precompilation.md\"]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, we provide a list of commented examples in the Examples section which showcases most of PEPSKit's capabilities in action.","category":"page"},{"location":"man/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"man/operators/","page":"Operators","title":"Operators","text":"note: Note\nThis section is still under construction.","category":"page"}]
}
