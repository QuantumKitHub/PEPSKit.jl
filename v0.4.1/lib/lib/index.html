<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · PEPSKit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="PEPSKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="PEPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PEPSKit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../man/intro/">Manual</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/master/docs/src/lib/lib.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGAlgorithm" href="#PEPSKit.CTMRGAlgorithm"><code>PEPSKit.CTMRGAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CTMRGAlgorithm</code></pre><p>Abstract super type for the corner transfer matrix renormalization group (CTMRG) algorithm for contracting infinite PEPS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/ctmrg.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv" href="#PEPSKit.CTMRGEnv"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CTMRGEnv{C,T}</code></pre><p>Corner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.</p><p>Given arrays of corners <code>c</code> and edges <code>t</code>, they connect to the partition function tensors <code>P</code> at site <code>(r, c)</code> in the unit cell as:</p><pre><code class="nohighlight hljs">   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]
   |              |             |
   t[4,r,c-1]-----P[r,c]--------t[2,r,c+1]
   |              |             |
   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]</code></pre><p>Here <code>P</code> represents an effective local constituent tensor. This can either be a single rank-4 tensor, a pair of PEPS tensors, or a stack of PEPS-PEPO-PEPS tensors depending on the partition function being contracted.</p><p><strong>Fields</strong></p><ul><li><code>corners::Array{C,3}</code>: Array of corner tensors.</li><li><code>edges::Array{T,3}</code>: Array of edge tensors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/environments/ctmrg_environments.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfinitePEPS, A}, Tuple{InfinitePEPS, A, A}, Tuple{InfinitePEPS, A, A, A}, Tuple{InfinitePEPS, Vararg{A, 4}}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})" href="#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfinitePEPS, A}, Tuple{InfinitePEPS, A, A}, Tuple{InfinitePEPS, A, A, A}, Tuple{InfinitePEPS, Vararg{A, 4}}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, T=ComplexF64], peps::InfinitePEPS, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]
) where {A&lt;:AbstractMatrix{&lt;:Union{Int,ElementarySpace}}}</code></pre><p>Construct a CTMRG environment by specifying a corresponding <a href="#PEPSKit.InfinitePEPS"><code>InfinitePEPS</code></a>, and the north, east, south and west virtual spaces of the environment as matrices. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site <code>(r, c)</code>, <code>chis_north[r, c]</code> corresponds to the east space of the north edge tensor, <code>chis_east[r, c]</code> corresponds to the north space of the east edge tensor, <code>chis_south[r, c]</code> corresponds to the east space of the south edge tensor, and <code>chis_west[r, c]</code> corresponds to the north space of the west edge tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/environments/ctmrg_environments.jl#L218-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfinitePartitionFunction, A}, Tuple{InfinitePartitionFunction, A, A}, Tuple{InfinitePartitionFunction, A, A, A}, Tuple{InfinitePartitionFunction, Vararg{A, 4}}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})" href="#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfinitePartitionFunction, A}, Tuple{InfinitePartitionFunction, A, A}, Tuple{InfinitePartitionFunction, A, A, A}, Tuple{InfinitePartitionFunction, Vararg{A, 4}}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, T=ComplexF64], partfunc::InfinitePartitionFunction, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]
) where {A&lt;:AbstractMatrix{&lt;:Union{Int,ElementarySpace}}}</code></pre><p>Construct a CTMRG environment by specifying a corresponding <a href="#PEPSKit.InfinitePartitionFunction"><code>InfinitePartitionFunction</code></a>, and the north, east, south and west virtual spaces of the environment as matrices. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site <code>(r, c)</code>, <code>chis_north[r, c]</code> corresponds to the east space of the north edge tensor, <code>chis_east[r, c]</code> corresponds to the north space of the east edge tensor, <code>chis_south[r, c]</code> corresponds to the east space of the south edge tensor, and <code>chis_west[r, c]</code> corresponds to the north space of the west edge tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/environments/ctmrg_environments.jl#L286-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{B}, Tuple{A}, Tuple{A, A, B}, Tuple{A, A, B, B}, Tuple{A, A, B, B, B}, Tuple{A, A, Vararg{B, 4}}} where {A&lt;:(AbstractMatrix{&lt;:Union{NTuple{N, Int64}, NTuple{N, var&quot;#s122&quot;} where var&quot;#s122&quot;&lt;:TensorKit.ElementarySpace} where N}), B&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})}" href="#PEPSKit.CTMRGEnv-Union{Tuple{B}, Tuple{A}, Tuple{A, A, B}, Tuple{A, A, B, B}, Tuple{A, A, B, B, B}, Tuple{A, A, Vararg{B, 4}}} where {A&lt;:(AbstractMatrix{&lt;:Union{NTuple{N, Int64}, NTuple{N, var&quot;#s122&quot;} where var&quot;#s122&quot;&lt;:TensorKit.ElementarySpace} where N}), B&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, ComplexF64], Ds_north::A, Ds_east::A, chis_north::B, [chis_east::B], [chis_south::B], [chis_west::B]
) where {A&lt;:AbstractMatrix{&lt;:SpaceLike}, B&lt;:AbstractMatrix{&lt;:ElementarySpaceLike}}</code></pre><p>Construct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding partition function and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site <code>(r, c)</code>, <code>chis_north[r, c]</code> corresponds to the east space of the north edge tensor, <code>chis_east[r, c]</code> corresponds to the north space of the east edge tensor, <code>chis_south[r, c]</code> corresponds to the east space of the south edge tensor, and <code>chis_west[r, c]</code> corresponds to the north space of the west edge tensor.</p><p>Each entry of the <code>Ds_north</code> and <code>Ds_east</code> matrices corresponds to an effective local space of the partition function, represented as a tuple of elementary spaces encoding a product space. This can either contain a single elementary space for the case of a partition function defined in terms of local rank-4 tensors, or a tuple of elementary spaces representing a product space for the case of a partition function representing overlaps of PEPSs and PEPOs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/environments/ctmrg_environments.jl#L61-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfinitePEPS, S}, Tuple{InfinitePEPS, S, S}, Tuple{InfinitePEPS, S, S, S}, Tuple{InfinitePEPS, Vararg{S, 4}}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}" href="#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfinitePEPS, S}, Tuple{InfinitePEPS, S, S}, Tuple{InfinitePEPS, S, S, S}, Tuple{InfinitePEPS, Vararg{S, 4}}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    peps::InfinitePEPS, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S],
) where {S&lt;:Union{Int,ElementarySpace}}</code></pre><p>Construct a CTMRG environment by specifying a corresponding <a href="#PEPSKit.InfinitePEPS"><code>InfinitePEPS</code></a>, and the north, east, south and west virtual spaces of the environment. By default, the virtual spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/environments/ctmrg_environments.jl#L355-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfinitePartitionFunction, S}, Tuple{InfinitePartitionFunction, S, S}, Tuple{InfinitePartitionFunction, S, S, S}, Tuple{InfinitePartitionFunction, Vararg{S, 4}}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}" href="#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfinitePartitionFunction, S}, Tuple{InfinitePartitionFunction, S, S}, Tuple{InfinitePartitionFunction, S, S, S}, Tuple{InfinitePartitionFunction, Vararg{S, 4}}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    peps::InfinitePartitionFunction, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S],
) where {S&lt;:ElementarySpaceLike</code></pre><p>Construct a CTMRG environment by specifying a corresponding <a href="#PEPSKit.InfinitePartitionFunction"><code>InfinitePartitionFunction</code></a>, and the north, east, south and west virtual spaces of the environment. By default, the virtual spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/environments/ctmrg_environments.jl#L402-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{P}, Tuple{P, P, S}, Tuple{P, P, S, S}, Tuple{P, P, S, S, S}, Tuple{P, P, Vararg{S, 4}}} where {P&lt;:(Union{NTuple{N, Int64}, NTuple{N, var&quot;#s122&quot;} where var&quot;#s122&quot;&lt;:TensorKit.ElementarySpace} where N), S&lt;:Union{Int64, TensorKit.ElementarySpace}}" href="#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{P}, Tuple{P, P, S}, Tuple{P, P, S, S}, Tuple{P, P, S, S, S}, Tuple{P, P, Vararg{S, 4}}} where {P&lt;:(Union{NTuple{N, Int64}, NTuple{N, var&quot;#s122&quot;} where var&quot;#s122&quot;&lt;:TensorKit.ElementarySpace} where N), S&lt;:Union{Int64, TensorKit.ElementarySpace}}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, ComplexF64], D_north::P, D_east::P, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S]; unitcell::Tuple{Int,Int}=(1, 1),
) where {P&lt;:ProductSpaceLike,S&lt;:ElementarySpaceLike}</code></pre><p>Construct a CTMRG environment by specifying the north and east virtual spaces of the corresponding <a href="#PEPSKit.InfinitePEPS"><code>InfinitePEPS</code></a> and the north, east, south and west virtual spaces of the environment. The PEPS unit cell can be specified by the <code>unitcell</code> keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/environments/ctmrg_environments.jl#L161-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.EnlargedCorner" href="#PEPSKit.EnlargedCorner"><code>PEPSKit.EnlargedCorner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EnlargedCorner{TC,TE,TA}</code></pre><p>Enlarged CTMRG corner tensor storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sparse_environments.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.EnlargedCorner-Tuple{PEPSKit.InfiniteSquareNetwork, Any, Any}" href="#PEPSKit.EnlargedCorner-Tuple{PEPSKit.InfiniteSquareNetwork, Any, Any}"><code>PEPSKit.EnlargedCorner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EnlargedCorner(network::InfiniteSquareNetwork, envs, coordinates)</code></pre><p>Construct an enlarged corner with the correct row and column indices based on the given <code>coordinates</code> which are of the form <code>(dir, row, col)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sparse_environments.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.FixedSVD" href="#PEPSKit.FixedSVD"><code>PEPSKit.FixedSVD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FixedSVD</code></pre><p>SVD struct containing a pre-computed decomposition or even multiple ones. The call to <code>tsvd</code> just returns the pre-computed U, S and V. In the reverse pass, the SVD adjoint is computed with these exact U, S, and V.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/svd.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.FixedSpaceTruncation" href="#PEPSKit.FixedSpaceTruncation"><code>PEPSKit.FixedSpaceTruncation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FixedSpaceTruncation &lt;: TensorKit.TruncationScheme</code></pre><p>CTMRG specific truncation scheme for <code>tsvd</code> which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from <code>TruncationSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/projectors.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.FullInfiniteEnv" href="#PEPSKit.FullInfiniteEnv"><code>PEPSKit.FullInfiniteEnv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FullInfiniteEnv{TC,TE,TA}</code></pre><p>Full-infinite CTMRG environment tensor storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sparse_environments.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.FullInfiniteEnv-Tuple{Any, Val{false}}" href="#PEPSKit.FullInfiniteEnv-Tuple{Any, Val{false}}"><code>PEPSKit.FullInfiniteEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(env::FullInfiniteEnv)(x, ::Val{false}) 
(env::FullInfiniteEnv)(x, ::Val{true})</code></pre><p>Contract full-infinite environment with a vector <code>x</code>, such that the environment acts as a linear map or adjoint linear map on <code>x</code> if <code>Val(true)</code> or <code>Val(false)</code> is passed, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sparse_environments.jl#L313-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.FullInfiniteProjector" href="#PEPSKit.FullInfiniteProjector"><code>PEPSKit.FullInfiniteProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FullInfiniteProjector{S,T}(; svd_alg=Defaults.svd_alg,
                                  trscheme=Defaults.trscheme, verbosity=0)</code></pre><p>Projector algorithm implementing projectors from SVDing the full 4x4 CTMRG environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/projectors.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.GeomSum" href="#PEPSKit.GeomSum"><code>PEPSKit.GeomSum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GeomSum(; maxiter=Defaults.fpgrad_maxiter, tol=Defaults.fpgrad_tol,
               verbosity=0, iterscheme=Defaults.iterscheme) &lt;: GradMode{iterscheme}</code></pre><p>Gradient mode for CTMRG using explicit evaluation of the geometric sum.</p><p>With <code>iterscheme</code> the style of CTMRG iteration which is being differentiated can be chosen. If set to <code>:fixed</code>, the differentiated CTMRG iteration is assumed to have a pre-computed SVD of the environments with a fixed set of gauges. Alternatively, if set to <code>:diffgauge</code>, the differentiated iteration consists of a CTMRG iteration and a subsequent gauge fixing step, such that <code>gauge_fix</code> will also be differentiated everytime a CTMRG derivative is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/peps_opt.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.HalfInfiniteEnv" href="#PEPSKit.HalfInfiniteEnv"><code>PEPSKit.HalfInfiniteEnv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HalfInfiniteEnv{C,E,A,A′}</code></pre><p>Half-infinite CTMRG environment tensor storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sparse_environments.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.HalfInfiniteEnv-Tuple{Any, Val{false}}" href="#PEPSKit.HalfInfiniteEnv-Tuple{Any, Val{false}}"><code>PEPSKit.HalfInfiniteEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(env::HalfInfiniteEnv)(x, ::Val{false}) 
(env::HalfInfiniteEnv)(x, ::Val{true})</code></pre><p>Contract half-infinite environment with a vector <code>x</code>, such that the environment acts as a linear map or adjoint linear map on <code>x</code> if <code>Val(true)</code> or <code>Val(false)</code> is passed, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sparse_environments.jl#L187-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.HalfInfiniteProjector" href="#PEPSKit.HalfInfiniteProjector"><code>PEPSKit.HalfInfiniteProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HalfInfiniteProjector{S,T}(; svd_alg=Defaults.svd_alg,
                                  trscheme=Defaults.trscheme, verbosity=0)</code></pre><p>Projector algorithm implementing projectors from SVDing the half-infinite CTMRG environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/projectors.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO" href="#PEPSKit.InfinitePEPO"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InfinitePEPO{T&lt;:PEPOTensor}</code></pre><p>Represents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/infinitepepo.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePEPO-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPO(A; unitcell=(1, 1, 1))</code></pre><p>Create an InfinitePEPO by specifying a tensor and unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/infinitepepo.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPO(A::AbstractArray{T, 3})</code></pre><p>Allow users to pass in an array of tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/infinitepepo.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A&lt;:(AbstractArray{&lt;:TensorKit.ElementarySpace, 3})" href="#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A&lt;:(AbstractArray{&lt;:TensorKit.ElementarySpace, 3})"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPO(f=randn, T=ComplexF64, Pspaces, Nspaces, Espaces)</code></pre><p>Allow users to pass in arrays of spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/infinitepepo.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:TensorKit.ElementarySpace" href="#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPO(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1,1))</code></pre><p>Create an InfinitePEPO by specifying its spaces and unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/infinitepepo.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS" href="#PEPSKit.InfinitePEPS"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InfinitePEPS{T&lt;:PEPSTensor}</code></pre><p>Represents an infinite projected entangled-pair state on a 2D square lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepeps.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS-Tuple{InfiniteWeightPEPS}" href="#PEPSKit.InfinitePEPS-Tuple{InfiniteWeightPEPS}"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPS(peps::InfiniteWeightPEPS)</code></pre><p>Create <code>InfinitePEPS</code> from <code>InfiniteWeightPEPS</code> by absorbing bond weights into vertex tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infiniteweightpeps.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePEPS-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPS(A; unitcell=(1, 1))</code></pre><p>Create an <code>InfinitePEPS</code> by specifying a tensor and unit cell.</p><p>The unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index <code>[r, c]</code> by one, respectively:</p><pre><code class="nohighlight hljs">   |            |          |
---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---
   |            ||         ||
---T[r,c-1]=====AA[r,c]====AA[r,c+1]====
   |            ||         ||
---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==
   |            ||         ||</code></pre><p>The unit cell has periodic boundary conditions, so <code>[r, c]</code> is indexed modulo the size of the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepeps.jl#L63-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePEPS-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPS(A::AbstractMatrix{T})</code></pre><p>Create an <code>InfinitePEPS</code> by specifying a matrix containing the PEPS tensors at each site in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepeps.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS-Union{Tuple{A}, Tuple{A, A, A}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})" href="#PEPSKit.InfinitePEPS-Union{Tuple{A}, Tuple{A, A, A}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPS(
    f=randn, T=ComplexF64, Pspaces::A, Nspaces::A, [Espaces::A]
) where {A&lt;:AbstractMatrix{&lt;:Union{Int,ElementarySpace}}}</code></pre><p>Create an <code>InfinitePEPS</code> by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an <code>Int</code> or an <code>ElementarySpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepeps.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}" href="#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPS(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1))</code></pre><p>Create an InfinitePEPS by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via <code>Int</code> or via <code>ElementarySpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepeps.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePartitionFunction" href="#PEPSKit.InfinitePartitionFunction"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InfinitePartitionFunction{T&lt;:PartitionFunctionTensor}</code></pre><p>Represents an infinite projected entangled-pair state on a 2D square lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepartitionfunction.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePartitionFunction-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePartitionFunction-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePartitionFunction(A; unitcell=(1, 1))</code></pre><p>Create an <code>InfinitePartitionFunction</code> by specifying a tensor and unit cell.</p><p>The unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if partition function tensor or environment tensor, is obtained by shifting the row and column index <code>[r, c]</code> by one, respectively:</p><pre><code class="nohighlight hljs">   |            |          |
---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---
   |            |          |
---T[r,c-1]-----AA[r,c]----AA[r,c+1]----
   |            |          |
---T[r+1,c-1]---AA[r+1,c]--AA[r+1,c+1]--
   |            |          |</code></pre><p>The unit cell has periodic boundary conditions, so <code>[r, c]</code> is indexed modulo the size of the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepartitionfunction.jl#L67-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePartitionFunction-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePartitionFunction-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePartitionFunction(A::AbstractMatrix{T})</code></pre><p>Create an <code>InfinitePartitionFunction</code> by specifying a matrix containing the PEPS tensors at each site in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepartitionfunction.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePartitionFunction-Union{Tuple{A}, Tuple{A, A}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})" href="#PEPSKit.InfinitePartitionFunction-Union{Tuple{A}, Tuple{A, A}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePartitionFunction(
    f=randn, T=ComplexF64, Pspaces::A, Nspaces::A, [Espaces::A]
) where {A&lt;:AbstractMatrix{&lt;:Union{Int,ElementarySpace}}}</code></pre><p>Create an <code>InfinitePartitionFunction</code> by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an <code>Int</code> or an <code>ElementarySpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepartitionfunction.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePartitionFunction-Union{Tuple{S}, Tuple{S, S}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}" href="#PEPSKit.InfinitePartitionFunction-Union{Tuple{S}, Tuple{S, S}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePartitionFunction(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1))</code></pre><p>Create an InfinitePartitionFunction by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via <code>Int</code> or via <code>ElementarySpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infinitepartitionfunction.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteSquare" href="#PEPSKit.InfiniteSquare"><code>PEPSKit.InfiniteSquare</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InfiniteSquare(Nrows::Integer=1, Ncols::Integer=1)</code></pre><p>Infinite square lattice with a unit cell of size <code>(Nrows, Ncols)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/lattices/squarelattice.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteSquareNetwork" href="#PEPSKit.InfiniteSquareNetwork"><code>PEPSKit.InfiniteSquareNetwork</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InfiniteSquareNetwork{T,N}</code></pre><p>Abstract infinite tensor network consisting of a translationally invariant unit cell on a square lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/networks/infinitesquarenetwork.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteTransferPEPO" href="#PEPSKit.InfiniteTransferPEPO"><code>PEPSKit.InfiniteTransferPEPO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPO{H,T,O}</code></pre><p>Represents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an <code>InfinitePEPO</code> between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}" href="#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}"><code>PEPSKit.InfiniteTransferPEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)</code></pre><p>Constructs a transfer operator corresponding to a single row of a partition function representing the expectation value of <code>O</code> for the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north, after which its <code>row</code>th row from the north is selected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L129-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteTransferPEPS" href="#PEPSKit.InfiniteTransferPEPS"><code>PEPSKit.InfiniteTransferPEPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPS{T}</code></pre><p>Represents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}" href="#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}"><code>PEPSKit.InfiniteTransferPEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPS(T::InfinitePEPS, dir, row)</code></pre><p>Constructs a transfer operator corresponding to a single row of a partition function representing the norm of the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north, after which its <code>row</code>th row from the north is selected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteWeightPEPS" href="#PEPSKit.InfiniteWeightPEPS"><code>PEPSKit.InfiniteWeightPEPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InfiniteWeightPEPS{T&lt;:PEPSTensor,E&lt;:PEPSWeight}</code></pre><p>Represents an infinite projected entangled-pair state on a 2D square lattice consisting of vertex tensors and bond weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infiniteweightpeps.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteWeightPEPS-Union{Tuple{E}, Tuple{T}, Tuple{Matrix{T}, Vararg{Matrix{E}}}} where {T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), E&lt;:(TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S})}" href="#PEPSKit.InfiniteWeightPEPS-Union{Tuple{E}, Tuple{T}, Tuple{Matrix{T}, Vararg{Matrix{E}}}} where {T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), E&lt;:(TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S})}"><code>PEPSKit.InfiniteWeightPEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteWeightPEPS(
    vertices::Matrix{T}, weight_mats::Matrix{E}...
) where {T&lt;:PEPSTensor,E&lt;:PEPSWeight}</code></pre><p>Create an InfiniteWeightPEPS from matrices of vertex tensors, and separate matrices of weights on each type of bond at all locations in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infiniteweightpeps.jl#L83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteWeightPEPS-Union{Tuple{S}, Tuple{Any, Any, S, S}, Tuple{Any, Any, S, S, S}} where S&lt;:TensorKit.ElementarySpace" href="#PEPSKit.InfiniteWeightPEPS-Union{Tuple{S}, Tuple{Any, Any, S, S}, Tuple{Any, Any, S, S, S}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit.InfiniteWeightPEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteWeightPEPS(
    f, T, Pspace::S, Nspace::S, Espace::S=Nspace; unitcell::Tuple{Int,Int}=(1, 1)
) where {S&lt;:ElementarySpace}</code></pre><p>Create an InfiniteWeightPEPS by specifying its physical, north and east spaces (as <code>ElementarySpace</code>s) and unit cell size. Use <code>T</code> to specify the element type of the vertex tensors.  Bond weights are initialized as identity matrices of element type <code>Float64</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infiniteweightpeps.jl#L97-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.IterSVD" href="#PEPSKit.IterSVD"><code>PEPSKit.IterSVD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IterSVD(; alg=KrylovKit.GKL(), fallback_threshold = Inf)</code></pre><p>Iterative SVD solver based on KrylovKit&#39;s GKL algorithm, adapted to (symmetric) tensors. The number of targeted singular values is set via the <code>TruncationSpace</code> in <code>ProjectorAlg</code>. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn&#39;t converge, the algorithm falls back to a dense SVD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/svd.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.LinSolver" href="#PEPSKit.LinSolver"><code>PEPSKit.LinSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LinSolver(; solver=KrylovKit.GMRES(), iterscheme=Defaults.iterscheme) &lt;: GradMode{iterscheme}</code></pre><p>Gradient mode wrapper around <code>KrylovKit.LinearSolver</code> for solving the gradient linear problem using iterative solvers.</p><p>With <code>iterscheme</code> the style of CTMRG iteration which is being differentiated can be chosen. If set to <code>:fixed</code>, the differentiated CTMRG iteration is assumed to have a pre-computed SVD of the environments with a fixed set of gauges. Alternatively, if set to <code>:diffgauge</code>, the differentiated iteration consists of a CTMRG iteration and a subsequent gauge fixing step, such that <code>gauge_fix</code> will also be differentiated everytime a CTMRG derivative is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/peps_opt.jl#L57-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.LocalOperator" href="#PEPSKit.LocalOperator"><code>PEPSKit.LocalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LocalOperator{T&lt;:Tuple,S}</code></pre><p>A sum of local operators acting on a lattice. The lattice is stored as a matrix of vector spaces, and the terms are stored as a tuple of pairs of indices and operators.</p><p><strong>Fields</strong></p><ul><li><code>lattice::Matrix{S}</code>: The lattice on which the operator acts.</li><li><code>terms::T</code>: The terms of the operator, stored as a tuple of pairs of indices and operators.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">LocalOperator(lattice::Matrix{S}, terms::Pair...)
LocalOperator{T,S}(lattice::Matrix{S}, terms::T) where {T,S} # expert mode</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lattice = fill(ℂ^2, 1, 1) # single-site unitcell
O1 = LocalOperator(lattice, ((1, 1),) =&gt; σx, ((1, 1), (1, 2)) =&gt; σx ⊗ σx, ((1, 1), (2, 1)) =&gt; σx ⊗ σx)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/localoperator.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.ManualIter" href="#PEPSKit.ManualIter"><code>PEPSKit.ManualIter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ManualIter(; maxiter=Defaults.fpgrad_maxiter, tol=Defaults.fpgrad_tol,
                  verbosity=0, iterscheme=Defaults.iterscheme) &lt;: GradMode{iterscheme}</code></pre><p>Gradient mode for CTMRG using manual iteration to solve the linear problem.</p><p>With <code>iterscheme</code> the style of CTMRG iteration which is being differentiated can be chosen. If set to <code>:fixed</code>, the differentiated CTMRG iteration is assumed to have a pre-computed SVD of the environments with a fixed set of gauges. Alternatively, if set to <code>:diffgauge</code>, the differentiated iteration consists of a CTMRG iteration and a subsequent gauge fixing step, such that <code>gauge_fix</code> will also be differentiated everytime a CTMRG derivative is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/peps_opt.jl#L31-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.MultilineTransferPEPO" href="#PEPSKit.MultilineTransferPEPO"><code>PEPSKit.MultilineTransferPEPO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const MultilineTransferPEPO = MPSKit.Multiline{&lt;:InfiniteTransferPEPO}</code></pre><p>Type that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an <code>InfinitePEPO</code> between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.MultilineTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any}" href="#PEPSKit.MultilineTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any}"><code>PEPSKit.MultilineTransferPEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilineTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir)</code></pre><p>Construct a multi-row transfer operator corresponding to the partition function representing the expectation value of <code>O</code> for the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.MultilineTransferPEPS" href="#PEPSKit.MultilineTransferPEPS"><code>PEPSKit.MultilineTransferPEPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const MultilineTransferPEPS = MPSKit.Multiline{&lt;:InfiniteTransferPEPS}</code></pre><p>Type that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.MultilineTransferPEPS-Tuple{InfinitePEPS, Any}" href="#PEPSKit.MultilineTransferPEPS-Tuple{InfinitePEPS, Any}"><code>PEPSKit.MultilineTransferPEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilineTransferPEPS(T::InfinitePEPS, dir)</code></pre><p>Construct a multi-row transfer operator corresponding to the partition function representing the norm of the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PEPOTensor" href="#PEPSKit.PEPOTensor"><code>PEPSKit.PEPOTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const PEPOTensor{S}</code></pre><p>Default type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: <span>$T : P ⊗ P´ ← N ⊗ E ⊗ S ⊗ W$</span>. Here, <span>$P´$</span> and <span>$P$</span> denote the incoming and outgoing physical space respectively, encoding the physical mapping from <span>$P´&#39;$</span> to <span>$P$</span> where <span>$P´&#39;$</span> corresponds to a physical PEPS index. <span>$N$</span>, <span>$E$</span>, <span>$S$</span> and <span>$W$</span> denote the physics, north, east, south and west spaces, respectively.</p><pre><code class="nohighlight hljs">        P´ N
        | ╱
        |╱
   W---- ----E
       ╱|
      ╱ |
     S  P</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/networks/tensors.jl#L94-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PEPSOptimize" href="#PEPSKit.PEPSOptimize"><code>PEPSKit.PEPSOptimize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEPSOptimize{G}(; boundary_alg=Defaults.ctmrg_alg, optimizer::OptimKit.OptimizationAlgorithm=Defaults.optimizer
                reuse_env::Bool=true, gradient_alg::G=Defaults.gradient_alg)</code></pre><p>Algorithm struct that represent PEPS ground-state optimization using AD. Set the algorithm to contract the infinite PEPS in <code>boundary_alg</code>; currently only <code>CTMRGAlgorithm</code>s are supported. The <code>optimizer</code> computes the gradient directions based on the CTMRG gradient and updates the PEPS parameters. In this optimization, the CTMRG runs can be started on the converged environments of the previous optimizer step by setting <code>reuse_env</code> to true. Otherwise a random environment is used at each step. The CTMRG gradient itself is computed using the <code>gradient_alg</code> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/peps_opt.jl#L79-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PEPSTensor" href="#PEPSKit.PEPSTensor"><code>PEPSKit.PEPSTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const PEPSTensor{S}</code></pre><p>Default type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: <span>$T : P ← N ⊗ E ⊗ S ⊗ W$</span>. Here, <span>$P$</span> denotes the physical space and <span>$N$</span>, <span>$E$</span>, <span>$S$</span> and <span>$W$</span> denote the north, east, south and west virtual spaces, respectively.</p><pre><code class="nohighlight hljs">           N
          ╱
         ╱
   W---- ----E
       ╱|
      ╱ |
     S  P</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/networks/tensors.jl#L33-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S&lt;:TensorKit.ElementarySpace}" href="#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.PEPSTensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,
           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S&lt;:ElementarySpace}
PEPSTensor(f, ::Type{T}, Pspace::Int, Nspace::Int,
           [Espace::Int], [Sspace::Int], [Wspace::Int]) where {T}</code></pre><p>Construct a PEPS tensor based on the physical, north, east, west and south spaces. Alternatively, only the space dimensions can be provided and ℂ is assumed as the field. The tensor elements are generated based on <code>f</code> and the element type is specified in <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/networks/tensors.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PEPSWeight" href="#PEPSKit.PEPSWeight"><code>PEPSKit.PEPSWeight</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const PEPSWeight</code></pre><p>Default type for PEPS bond weights with 2 virtual indices, conventionally ordered as: <span>$wt : WS ← EN$</span>.  <code>WS</code>, <code>EN</code> denote the west/south, east/north spaces for x/y-weights on the square lattice, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infiniteweightpeps.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PartitionFunctionTensor" href="#PEPSKit.PartitionFunctionTensor"><code>PEPSKit.PartitionFunctionTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const PartitionFunctionTensor{S}</code></pre><p>Default type for partition function tensors with 4 virtual indices, conventionally ordered as: <span>$T : W ⊗ S ← N ⊗ E$</span>. Here, <span>$N$</span>, <span>$E$</span>, <span>$S$</span> and <span>$W$</span> denote the north, east, south and west spaces, respectively.</p><pre><code class="nohighlight hljs">          N
         ╱
        ╱
  W---- ----E
      ╱
     ╱
    S </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/networks/tensors.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.ProjectorAlgorithm" href="#PEPSKit.ProjectorAlgorithm"><code>PEPSKit.ProjectorAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectorAlgorithm</code></pre><p>Abstract super type for all CTMRG projector algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/projectors.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.ReflectDepth" href="#PEPSKit.ReflectDepth"><code>PEPSKit.ReflectDepth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReflectDepth &lt;: SymmetrizationStyle</code></pre><p>Reflection symmmetrization along the horizontal axis, such that north and south are mirrored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/symmetrization.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.ReflectWidth" href="#PEPSKit.ReflectWidth"><code>PEPSKit.ReflectWidth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReflectWidth &lt;: SymmetrizationStyle</code></pre><p>Reflection symmmetrization along the vertical axis, such that east and west are mirrored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/symmetrization.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.Rotate" href="#PEPSKit.Rotate"><code>PEPSKit.Rotate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Rotate &lt;: SymmetrizationStyle</code></pre><p>Rotation symmmetrization leaving the object invariant under π/2 rotations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/symmetrization.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.RotateReflect" href="#PEPSKit.RotateReflect"><code>PEPSKit.RotateReflect</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotateReflect &lt;: SymmetrizationStyle</code></pre><p>Full reflection and rotation symmmetrization, such that reflection along the horizontal and vertical axis as well as π/2 rotations leave the object invariant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/symmetrization.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.SUWeight" href="#PEPSKit.SUWeight"><code>PEPSKit.SUWeight</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SUWeight{E&lt;:PEPSWeight}</code></pre><p>Schmidt bond weights used in simple/cluster update. Weight elements are always real.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infiniteweightpeps.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.SVDAdjoint" href="#PEPSKit.SVDAdjoint"><code>PEPSKit.SVDAdjoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SVDAdjoint(; fwd_alg=Defaults.fwd_alg, rrule_alg=Defaults.rrule_alg,
                  broadening=nothing)</code></pre><p>Wrapper for a SVD algorithm <code>fwd_alg</code> with a defined reverse rule <code>rrule_alg</code>. If <code>isnothing(rrule_alg)</code>, Zygote differentiates the forward call automatically. In case of degenerate singular values, one might need a <code>broadening</code> scheme which removes the divergences from the adjoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/svd.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.SequentialCTMRG" href="#PEPSKit.SequentialCTMRG"><code>PEPSKit.SequentialCTMRG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SequentialCTMRG(; tol=Defaults.ctmrg_tol, maxiter=Defaults.ctmrg_maxiter,
                  miniter=Defaults.ctmrg_miniter, verbosity=0,
                  projector_alg=typeof(Defaults.projector_alg),
                  svd_alg=SVDAdjoint(), trscheme=FixedSpaceTruncation())</code></pre><p>CTMRG algorithm where the expansions and renormalization is performed sequentially column-wise. This is implemented as a growing and projecting step to the left, followed by a clockwise rotation (performed four times). The projectors are computed using <code>projector_alg</code> from <code>svd_alg</code> SVDs where the truncation scheme is set via <code>trscheme</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sequential.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.SimpleUpdate" href="#PEPSKit.SimpleUpdate"><code>PEPSKit.SimpleUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SimpleUpdate</code></pre><p>Algorithm struct for simple update (SU) of infinite PEPS with bond weights. Each SU run is converged when the singular value difference becomes smaller than <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/time_evolution/simpleupdate.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.SimultaneousCTMRG" href="#PEPSKit.SimultaneousCTMRG"><code>PEPSKit.SimultaneousCTMRG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimultaneousCTMRG(; tol=Defaults.ctmrg_tol, maxiter=Defaults.ctmrg_maxiter,
                  miniter=Defaults.ctmrg_miniter, verbosity=0,
                  projector_alg=Defaults.projector_alg,
                  svd_alg=SVDAdjoint(), trscheme=FixedSpaceTruncation())</code></pre><p>CTMRG algorithm where all sides are grown and renormalized at the same time. In particular, the projectors are applied to the corners from two sides simultaneously. The projectors are computed using <code>projector_alg</code> from <code>svd_alg</code> SVDs where the truncation scheme is set via  <code>trscheme</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/simultaneous.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.TensorMap-Tuple{PEPSKit.EnlargedCorner, Int64}" href="#TensorKit.TensorMap-Tuple{PEPSKit.EnlargedCorner, Int64}"><code>TensorKit.TensorMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TensorKit.TensorMap(Q::EnlargedCorner, dir::Int)</code></pre><p>Instantiate enlarged corner as <code>TensorMap</code> where <code>dir</code> selects the correct contraction direction, i.e. the way the environment and PEPS tensors connect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sparse_environments.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.TensorMap-Tuple{PEPSKit.FullInfiniteEnv}" href="#TensorKit.TensorMap-Tuple{PEPSKit.FullInfiniteEnv}"><code>TensorKit.TensorMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TensorKit.TensorMap(env::FullInfiniteEnv)</code></pre><p>Instantiate full-infinite environment as <code>TensorMap</code> explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sparse_environments.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.TensorMap-Tuple{PEPSKit.HalfInfiniteEnv}" href="#TensorKit.TensorMap-Tuple{PEPSKit.HalfInfiniteEnv}"><code>TensorKit.TensorMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TensorKit.TensorMap(env::HalfInfiniteEnv)</code></pre><p>Instantiate half-infinite environment as <code>TensorMap</code> explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sparse_environments.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSKit.correlation_length-Tuple{Any, CTMRGEnv}" href="#MPSKit.correlation_length-Tuple{Any, CTMRGEnv}"><code>MPSKit.correlation_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">correlation_length(state, env::CTMRGEnv; num_vals=2, kwargs...)</code></pre><p>Compute the correlation length associated to <code>state</code> as contracted using the environment <code>env</code>, based on the spectrum of the horizontal and vertical transfer matrices associated to <code>env</code>. Additionally the (normalized) eigenvalue spectrum is returned. The number of computed eigenvalues can be specified using <code>num_vals</code>, and any remaining keyword arguments are passed through to <code>MPSKit.transfer_spectrum</code> (e.g. allowing to target the correlation length in a specific symmetry sector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/toolbox.jl#L172-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSKit.expectation_value-Tuple{Any, Any}" href="#MPSKit.expectation_value-Tuple{Any, Any}"><code>MPSKit.expectation_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})
MPSKit.expectation_value(st::MultilineMPS, op::Union{MultilineTransferPEPS,MultilineTransferPEPO})</code></pre><p>Compute expectation value of the transfer operator <code>op</code> for the state <code>st</code> for each site in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSKit.expectation_value-Tuple{InfinitePEPS, LocalOperator, CTMRGEnv}" href="#MPSKit.expectation_value-Tuple{InfinitePEPS, LocalOperator, CTMRGEnv}"><code>MPSKit.expectation_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expectation_value(peps::InfinitePEPS, O::LocalOperator, envs::CTMRGEnv)</code></pre><p>Compute the expectation value ⟨peps|O|peps⟩ / ⟨peps|peps⟩ of a <a href="#PEPSKit.LocalOperator"><code>LocalOperator</code></a> <code>O</code> for a PEPS <code>peps</code> using a given CTMRG environment <code>envs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/toolbox.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSKit.expectation_value-Union{Tuple{S}, Tuple{T}, Tuple{InfinitePartitionFunction, Pair{CartesianIndex{2}, &lt;:TensorKit.AbstractTensorMap{T, S, 2, 2}}, CTMRGEnv}} where {T, S}" href="#MPSKit.expectation_value-Union{Tuple{S}, Tuple{T}, Tuple{InfinitePartitionFunction, Pair{CartesianIndex{2}, &lt;:TensorKit.AbstractTensorMap{T, S, 2, 2}}, CTMRGEnv}} where {T, S}"><code>MPSKit.expectation_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expectation_value(pf::InfinitePartitionFunction, inds =&gt; O, envs::CTMRGEnv)</code></pre><p>Compute the expectation value corresponding to inserting a local tensor(s) <code>O</code> at position <code>inds</code> in the partition function <code>pf</code> and contracting the chole using a given CTMRG environment <code>envs</code>.</p><p>Here <code>inds</code> can be specified as either a <code>Tuple{Int,Int}</code> or a <code>CartesianIndex{2}</code>, and <code>O</code> should be a rank-4 tensor conforming to the <a href="#PEPSKit.PartitionFunctionTensor"><code>PartitionFunctionTensor</code></a> indexing convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/toolbox.jl#L15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSKit.leading_boundary-Tuple{Any, Any, Any}" href="#MPSKit.leading_boundary-Tuple{Any, Any, Any}"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPSKit.leading_boundary(
    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [envs]
)
MPSKit.leading_boundary(
    st::MPSMulitline, op::Union{MultilineTransferPEPS,MultilineTransferPEPO}, alg, [envs]
)</code></pre><p>Approximate the leading boundary MPS eigenvector for the transfer operator <code>op</code> using <code>st</code> as initial guess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L232-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSKit.leading_boundary-Tuple{Any, PEPSKit.CTMRGAlgorithm}" href="#MPSKit.leading_boundary-Tuple{Any, PEPSKit.CTMRGAlgorithm}"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPSKit.leading_boundary([envinit], state, alg::CTMRGAlgorithm)</code></pre><p>Contract <code>state</code> using CTMRG and return the CTM environment. Per default, a random initial environment is used.</p><p>Each CTMRG run is converged up to <code>alg.tol</code> where the singular value convergence of the corners and edges is checked. The maximal and minimal number of CTMRG iterations is set with <code>alg.maxiter</code> and <code>alg.miniter</code>.</p><p>Different levels of output information are printed depending on <code>alg.verbosity</code>, where <code>0</code> suppresses all output, <code>1</code> only prints warnings, <code>2</code> gives information at the start and end, and <code>3</code> prints information every iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/ctmrg.jl#L16-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit._absorb_weight-Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace, Int64, Int64, String, SUWeight}" href="#PEPSKit._absorb_weight-Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace, Int64, Int64, String, SUWeight}"><code>PEPSKit._absorb_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Absorb environment weights into tensor <code>t</code> in position <code>[row, col]</code> in an iPEPS with <code>weights</code>.  A full weight is absorbed into axes of <code>t</code> on the boundary (specified by <code>open_axs</code>). But on internal bonds, square root of weights are absorbed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/time_evolution/evoltools.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit._dag-Union{Tuple{TensorKit.AbstractTensorMap{T, S, N, 1} where T}, Tuple{N}, Tuple{S}} where {S, N}" href="#PEPSKit._dag-Union{Tuple{TensorKit.AbstractTensorMap{T, S, N, 1} where T}, Tuple{N}, Tuple{S}} where {S, N}"><code>PEPSKit._dag</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adjoint of an MPS tensor, but permutes the physical spaces back into the codomain. Intuitively, this conjugates a tensor and then reinterprets its &#39;direction&#39; as an MPS tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/toolbox.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit._mirror_antidiag_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S&lt;:Union{Tuple{Int64, Int64}, CartesianIndex{2}}" href="#PEPSKit._mirror_antidiag_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S&lt;:Union{Tuple{Int64, Int64}, CartesianIndex{2}}"><code>PEPSKit._mirror_antidiag_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_mirror_antidiag_site(
    site::S, (Nrow, Ncol)::NTuple{2,Int}
) where {S&lt;:Union{CartesianIndex{2},NTuple{2,Int}}}</code></pre><p>Get the position of <code>site</code> after reflection about the anti-diagonal line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/localoperator.jl#L115-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit._rot180_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S&lt;:Union{Tuple{Int64, Int64}, CartesianIndex{2}}" href="#PEPSKit._rot180_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S&lt;:Union{Tuple{Int64, Int64}, CartesianIndex{2}}"><code>PEPSKit._rot180_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rot180_site(
    site::S, (Nrow, Ncol)::NTuple{2,Int}
) where {S&lt;:Union{CartesianIndex{2},NTuple{2,Int}}}</code></pre><p>Get the position of <code>site</code> after rotation by 180 degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/localoperator.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit._rotl90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S&lt;:Union{Tuple{Int64, Int64}, CartesianIndex{2}}" href="#PEPSKit._rotl90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S&lt;:Union{Tuple{Int64, Int64}, CartesianIndex{2}}"><code>PEPSKit._rotl90_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rotl90_site(
    site::S, (Nrow, Ncol)::NTuple{2,Int}
) where {S&lt;:Union{CartesianIndex{2},NTuple{2,Int}}}</code></pre><p>Get the position of <code>site</code> after counter-clockwise (left) rotation by 90 degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/localoperator.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit._rotr90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S&lt;:Union{Tuple{Int64, Int64}, CartesianIndex{2}}" href="#PEPSKit._rotr90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S&lt;:Union{Tuple{Int64, Int64}, CartesianIndex{2}}"><code>PEPSKit._rotr90_site</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rotr90_site(
    site::S, (Nrow, Ncol)::NTuple{2,Int}
) where {S&lt;:Union{CartesianIndex{2},NTuple{2,Int}}}</code></pre><p>Get the position of <code>site</code> after clockwise (right) rotation by 90 degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/localoperator.jl#L129-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}" href="#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}"><code>PEPSKit._rrule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rrule(alg_rrule, config, f, args...; kwargs...) -&gt; ∂f, ∂args...</code></pre><p>Customize the pullback of a function <code>f</code>. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default <code>alg_rrule=nothing</code> results in the default AD pullback.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>No tangent is expected for the <code>alg_rrule</code> argument</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/hook_pullback.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit._su_bondx!-Union{Tuple{S}, Tuple{T}, Tuple{Int64, Int64, TensorKit.AbstractTensorMap{T, S, 2, 2}, InfiniteWeightPEPS, SimpleUpdate}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}" href="#PEPSKit._su_bondx!-Union{Tuple{S}, Tuple{T}, Tuple{Int64, Int64, TensorKit.AbstractTensorMap{T, S, 2, 2}, InfiniteWeightPEPS, SimpleUpdate}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._su_bondx!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><em>su</em>bondx!(row::Int, col::Int, gate::AbstractTensorMap{T,S,2,2},            peps::InfiniteWeightPEPS, alg::SimpleUpdate) where {S&lt;:ElementarySpace}</p><p>Simple update of the x-bond <code>peps.weights[1,r,c]</code>.</p><pre><code class="nohighlight hljs">                [2,r,c]             [2,r,c+1]
                ↓                   ↓
    [1,r,c-1] ← T[r,c] ← [1,r,c] ←- T[r,c+1] ← [1,r,c+1]
                ↓                   ↓
                [2,r+1,c]           [2,r+1,c+1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/time_evolution/simpleupdate.jl#L22-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.absorb_s-Tuple{TensorKit.AbstractTensorMap, TensorKit.DiagonalTensorMap, TensorKit.AbstractTensorMap}" href="#PEPSKit.absorb_s-Tuple{TensorKit.AbstractTensorMap, TensorKit.DiagonalTensorMap, TensorKit.AbstractTensorMap}"><code>PEPSKit.absorb_s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absorb_s(u::AbstractTensorMap, s::DiagonalTensorMap, vh::AbstractTensorMap)</code></pre><p>Given <code>tsvd</code> result <code>u</code>, <code>s</code> and <code>vh</code>, absorb singular values <code>s</code> into <code>u</code> and <code>vh</code> by:</p><pre><code class="nohighlight hljs">    u -&gt; u * sqrt(s), vh -&gt; sqrt(s) * vh</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/util.jl#L91-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.absorb_weight-Union{Tuple{T}, Tuple{T, Int64, Int64, Int64, SUWeight}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.absorb_weight-Union{Tuple{T}, Tuple{T, Int64, Int64, Int64, SUWeight}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.absorb_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absorb_weight(t::T, row::Int, col::Int, ax::Int, weights::SUWeight;
              sqrtwt::Bool=false, invwt::Bool=false) where {T&lt;:PEPSTensor}</code></pre><p>Absorb or remove environment weight on axis <code>ax</code> of vertex tensor <code>t</code>  known to be located at position (<code>row</code>, <code>col</code>) in the unit cell.  Weights around the tensor at <code>(row, col)</code> are</p><pre><code class="nohighlight hljs">                    ↓
                [2,r,c]
                    ↓
    ← [1,r,c-1] ← T[r,c] ← [1,r,c] ←
                    ↓
                [1,r+1,c]
                    ↓</code></pre><p><strong>Arguments</strong></p><ul><li><code>t::T</code>: The vertex tensor to which the weight will be absorbed. The first axis of <code>t</code> should be the physical axis. </li><li><code>row::Int</code>: The row index specifying the position in the tensor network.</li><li><code>col::Int</code>: The column index specifying the position in the tensor network.</li><li><code>ax::Int</code>: The axis along which the weight is absorbed.</li><li><code>weights::SUWeight</code>: The weight object to absorb into the tensor.</li><li><code>sqrtwt::Bool=false</code> (optional): If <code>true</code>, the square root of the weight is absorbed.</li><li><code>invwt::Bool=false</code> (optional): If <code>true</code>, the inverse of the weight is absorbed.</li></ul><p><strong>Details</strong></p><p>The optional kwargs <code>sqrtwt</code> and <code>invwt</code> allow taking the square root or the inverse of the weight before absorption. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Absorb the weight into the 2nd axis of tensor at position (2, 3)
absorb_weight(t, 2, 3, 2, weights)

# Absorb the square root of the weight into the tensor
absorb_weight(t, 2, 3, 2, weights; sqrtwt=true)

# Absorb the inverse of (i.e. remove) the weight into the tensor
absorb_weight(t, 2, 3, 2, weights; invwt=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infiniteweightpeps.jl#L118-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.calc_convergence-Tuple{Any, Any, Any}" href="#PEPSKit.calc_convergence-Tuple{Any, Any, Any}"><code>PEPSKit.calc_convergence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_convergence(envs, CS_old, TS_old)
calc_convergence(envs_new::CTMRGEnv, envs_old::CTMRGEnv)</code></pre><p>Given a new environment <code>envs</code>, compute the maximal singular value distance. This determined either from the previous corner and edge singular values <code>CS_old</code> and <code>TS_old</code>, or alternatively, directly from the old environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/ctmrg.jl#L102-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}" href="#PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}"><code>PEPSKit.calc_elementwise_convergence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_elementwise_convergence(envfinal, envfix; atol=1e-6)</code></pre><p>Check if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below some tolerance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/gaugefix.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.checklattice-Tuple" href="#PEPSKit.checklattice-Tuple"><code>PEPSKit.checklattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checklattice(Bool, args...)
checklattice(args...)</code></pre><p>Helper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/localoperator.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.compute_projector-Tuple{Any, Any, HalfInfiniteProjector}" href="#PEPSKit.compute_projector-Tuple{Any, Any, HalfInfiniteProjector}"><code>PEPSKit.compute_projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_projector(enlarged_corners, coordinate, alg::ProjectorAlgorithm)</code></pre><p>Determine left and right projectors at the bond given determined by the enlarged corners and the given coordinate using the specified <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/projectors.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.contract_local_norm-Union{Tuple{N}, Tuple{NTuple{N, CartesianIndex{2}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N" href="#PEPSKit.contract_local_norm-Union{Tuple{N}, Tuple{NTuple{N, CartesianIndex{2}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N"><code>PEPSKit.contract_local_norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract_local_norm(inds, peps, env)</code></pre><p>Contract a local norm of the PEPS <code>peps</code> around indices <code>inds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/localoperator.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.contract_local_operator-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{T, S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {T, S, N}" href="#PEPSKit.contract_local_operator-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{T, S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {T, S, N}"><code>PEPSKit.contract_local_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract_local_operator(inds, O, peps, env)</code></pre><p>Contract a local operator <code>O</code> on the PEPS <code>peps</code> at the indices <code>inds</code> using the environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/localoperator.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.contract_local_tensor-Union{Tuple{C}, Tuple{S}, Tuple{T}, Tuple{Tuple{Int64, Int64}, TensorKit.AbstractTensorMap{T, S, 2, 2}, CTMRGEnv{C, &lt;:TensorKit.AbstractTensorMap{T, S, 2, 1} where {T, S}}}} where {T, S, C}" href="#PEPSKit.contract_local_tensor-Union{Tuple{C}, Tuple{S}, Tuple{T}, Tuple{Tuple{Int64, Int64}, TensorKit.AbstractTensorMap{T, S, 2, 2}, CTMRGEnv{C, &lt;:TensorKit.AbstractTensorMap{T, S, 2, 1} where {T, S}}}} where {T, S, C}"><code>PEPSKit.contract_local_tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract_local_tensor(inds, O, env)</code></pre><p>Contract a local tensor <code>O</code> inserted into a partition function <code>pf</code> at position <code>inds</code>, using the environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/localoperator.jl#L268-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.contract_projectors-NTuple{5, Any}" href="#PEPSKit.contract_projectors-NTuple{5, Any}"><code>PEPSKit.contract_projectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract_projectors(U, S, V, Q, Q_next)</code></pre><p>Compute projectors based on a SVD of <code>Q * Q_next</code>, where the inverse square root <code>isqS</code> of the singular values is computed.</p><p>Left projector:</p><pre><code class="nohighlight hljs">    -- |~~~~~~| -- |~~|
       |Q_next|    |V&#39;| -- isqS --
    == |~~~~~~| == |~~|</code></pre><p>Right projector:</p><pre><code class="nohighlight hljs">               |~~| -- |~~~| --
    -- isqS -- |U&#39;|    | Q |
               |~~| == |~~~| ==</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L334-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.ctmrg_iteration-Tuple{Any, Any, PEPSKit.CTMRGAlgorithm}" href="#PEPSKit.ctmrg_iteration-Tuple{Any, Any, PEPSKit.CTMRGAlgorithm}"><code>PEPSKit.ctmrg_iteration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctmrg_iteration(state, env, alg::CTMRGAlgorithm) -&gt; env′, info</code></pre><p>Perform a single CTMRG iteration in which all directions are being grown and renormalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/ctmrg.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.dtmap-Tuple" href="#PEPSKit.dtmap-Tuple"><code>PEPSKit.dtmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dtmap(args...; kwargs...)</code></pre><p>Differentiable wrapper around <code>OhMyThreads.tmap</code>.</p><p>All calls of <code>dtmap</code> inside of PEPSKit use the threading scheduler stored inside <code>Defaults.scheduler</code> which can be modified using <code>set_scheduler!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/diffable_threads.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.eachcoordinate" href="#PEPSKit.eachcoordinate"><code>PEPSKit.eachcoordinate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachcoordinate(x, dirs=1:4)</code></pre><p>Enumerate all (dir, row, col) pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/util.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.enlarge_northeast_corner" href="#PEPSKit.enlarge_northeast_corner"><code>PEPSKit.enlarge_northeast_corner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enlarge_northeast_corner((row, col), envs, ket::InfinitePEPS, bra::InfinitePEPS=ket)
enlarge_northeast_corner((row, col), envs, partfunc::InfinitePartitionFunction)
enlarge_northeast_corner(E_north, C_northeast, E_east, ket::PEPSTensor, bra::PEPSTensor=ket)
enlarge_northeast_corner(E_north, C_northeast, E_east, partfunc::PartitionFunctionTensor)</code></pre><p>Contract the enlarged northeast corner of the CTMRG environment, either by specifying the coordinates, environments and networks, or by directly providing the tensors.</p><p>The networks and tensors (denoted <code>A</code> below) can correspond to either:</p><ul><li>a pair of &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> networks and a pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>an <code>InfinitePartitionFunction</code> network and a <code>PartitionFunctionTensor</code>.</li></ul><pre><code class="nohighlight hljs">    -- E_north -- C_northeast
          |             |
    --    A    --    E_east
          |             |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L73-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.enlarge_northwest_corner" href="#PEPSKit.enlarge_northwest_corner"><code>PEPSKit.enlarge_northwest_corner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enlarge_northwest_corner((row, col), envs, ket::InfinitePEPS, bra::InfinitePEPS=ket)
enlarge_northwest_corner((row, col), envs, partfunc::InfinitePartitionFunction)
enlarge_northwest_corner(E_west, C_northwest, E_north, ket::PEPSTensor, bra::PEPSTensor=ket)
enlarge_northwest_corner(E_west, C_northwest, E_north, partfunc::PartitionFunctionTensor)</code></pre><p>Contract the enlarged northwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.</p><p>The networks and tensors (denoted <code>A</code> below) can correspond to either:</p><ul><li>a pair of &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> networks and a pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>an <code>InfinitePartitionFunction</code> network and a <code>PartitionFunctionTensor</code>.</li></ul><pre><code class="nohighlight hljs">    C_northwest -- E_north --
         |            |
      E_west    --    A    --
         |            |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L9-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.enlarge_southeast_corner" href="#PEPSKit.enlarge_southeast_corner"><code>PEPSKit.enlarge_southeast_corner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enlarge_southeast_corner((row, col), envs, ket::InfinitePEPS, bra::InfinitePEPS=ket)
enlarge_southeast_corner((row, col), envs, partfunc::InfinitePartitionFunction)
enlarge_southeast_corner(E_east, C_southeast, E_south, ket::PEPSTensor, bra::PEPSTensor=ket)
enlarge_southeast_corner(E_east, C_southeast, E_south, partfunc::PartitionFunctionTensor)</code></pre><p>Contract the enlarged southeast corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.</p><p>The networks and tensors (denoted <code>A</code> below) can correspond to either:</p><ul><li>a pair of &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> networks and a pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>an <code>InfinitePartitionFunction</code> network and a <code>PartitionFunctionTensor</code>.</li></ul><pre><code class="nohighlight hljs">          |             |
    --    A    --    E_east
          |             |
    -- E_south -- C_southeast</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L137-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.enlarge_southwest_corner" href="#PEPSKit.enlarge_southwest_corner"><code>PEPSKit.enlarge_southwest_corner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enlarge_southwest_corner((row, col), envs, ket::InfinitePEPS, bra::InfinitePEPS=ket)
enlarge_southwest_corner((row, col), envs, partfunc::InfinitePartitionFunction)
enlarge_southwest_corner(E_south, C_southwest, E_west, ket::PEPSTensor, bra::PEPSTensor=ket)
enlarge_southwest_corner(E_south, C_southwest, E_west, partfunc::PartitionFunctionTensor)</code></pre><p>Contract the enlarged southwest corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.</p><p>The networks and tensors (denoted <code>A</code> below) can correspond to either:</p><ul><li>a pair of &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> networks and a pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>an <code>InfinitePartitionFunction</code> network and a <code>PartitionFunctionTensor</code>.</li></ul><pre><code class="nohighlight hljs">          |           |       
       E_west   --    A    --
          |           |       
    C_southwest -- E_south -- </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L201-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}" href="#PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}"><code>PEPSKit.fix_gauge_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_corner(corner, σ_in, σ_out)</code></pre><p>Multiply corner tensor with incoming and outgoing gauge signs.</p><pre><code class="nohighlight hljs">    corner -- σ_out --
      |  
     σ_in
      |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1549-L1560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}" href="#PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_east_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_east_edge((row, col), envs, signs)</code></pre><p>Apply <code>fix_gauge_edge</code> to the east edge with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1657-L1661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}" href="#PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_east_left_vecs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_east_left_vecs((row, col), U, signs)</code></pre><p>Multiply east left singular vectors with gauge signs from the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1703-L1707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}" href="#PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_east_right_vecs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_east_right_vecs((row, col), V, signs)</code></pre><p>Multiply east right singular vectors with gauge signs from the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1741-L1745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_edge-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}" href="#PEPSKit.fix_gauge_edge-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}"><code>PEPSKit.fix_gauge_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_edge(edge, σ_in, σ_out)</code></pre><p>Multiply edge tensor with incoming and outgoing gauge signs.</p><pre><code class="nohighlight hljs">    -- σ_in -- edge -- σ_out --</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1622-L1630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}" href="#PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_north_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_north_edge((row, col), envs, signs)</code></pre><p>Apply <code>fix_gauge_edge</code> to the north edge with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1644-L1648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}" href="#PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_north_left_vecs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_north_left_vecs((row, col), U, signs)</code></pre><p>Multiply north left singular vectors with gauge signs from the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1694-L1698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}" href="#PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_north_right_vecs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_north_right_vecs((row, col), V, signs)</code></pre><p>Multiply north right singular vectors with gauge signs from the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1732-L1736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}" href="#PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_northeast_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_northeast_corner((row, col), envs, signs)</code></pre><p>Apply <code>fix_gauge_corner</code> to the northeast corner with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1581-L1585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}" href="#PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_northwest_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_northwest_corner((row, col), envs, signs)</code></pre><p>Apply <code>fix_gauge_corner</code> to the northwest corner with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1568-L1572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}" href="#PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_south_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_south_edge((row, col), envs, signs)</code></pre><p>Apply <code>fix_gauge_edge</code> to the south edge with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1668-L1672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}" href="#PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_south_left_vecs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_south_left_vecs((row, col), U, signs)</code></pre><p>Multiply south left singular vectors with gauge signs from the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1712-L1716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}" href="#PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_south_right_vecs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_south_right_vecs((row, col), V, signs)</code></pre><p>Multiply south right singular vectors with gauge signs from the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1750-L1754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}" href="#PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_southeast_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_southeast_corner((row, col), envs, signs)</code></pre><p>Apply <code>fix_gauge_corner</code> to the southeast corner with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1594-L1598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}" href="#PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_southwest_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_southwest_corner((row, col), envs, signs)</code></pre><p>Apply <code>fix_gauge_corner</code> to the southwest corner with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1607-L1611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}" href="#PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_west_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_south_edge((row, col), envs, signs)</code></pre><p>Apply <code>fix_gauge_edge</code> to the west edge with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1681-L1685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}" href="#PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_west_left_vecs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_west_left_vecs((row, col), U, signs)</code></pre><p>Multiply west left singular vectors with gauge signs from the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1721-L1725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}" href="#PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_west_right_vecs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_gauge_west((row, col), V, signs)</code></pre><p>Multiply west right singular vectors with gauge signs from the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1759-L1763">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fixedpoint-Union{Tuple{F}, Tuple{InfinitePEPS{F}, Any, PEPSOptimize}, Tuple{InfinitePEPS{F}, Any, PEPSOptimize, CTMRGEnv}} where F" href="#PEPSKit.fixedpoint-Union{Tuple{F}, Tuple{InfinitePEPS{F}, Any, PEPSOptimize}, Tuple{InfinitePEPS{F}, Any, PEPSOptimize, CTMRGEnv}} where F"><code>PEPSKit.fixedpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fixedpoint(ψ₀::InfinitePEPS{T}, H, alg::PEPSOptimize, [env₀::CTMRGEnv];
           finalize!=OptimKit._finalize!, symmetrization=nothing) where {T}</code></pre><p>Optimize <code>ψ₀</code> with respect to the Hamiltonian <code>H</code> according to the parameters supplied in <code>alg</code>. The initial environment <code>env₀</code> serves as an initial guess for the first CTMRG run. By default, a random initial environment is used.</p><p>The <code>finalize!</code> kwarg can be used to insert a function call after each optimization step by utilizing the <code>finalize!</code> kwarg of <code>OptimKit.optimize</code>. The function maps <code>(peps, envs), f, g = finalize!((peps, envs), f, g, numiter)</code>. The <code>symmetrization</code> kwarg accepts <code>nothing</code> or a <code>SymmetrizationStyle</code>, in which case the PEPS and PEPS gradient are symmetrized after each optimization iteration. Note that this requires a symmmetric <code>ψ₀</code> and <code>env₀</code> to converge properly.</p><p>The function returns a <code>NamedTuple</code> which contains the following entries:</p><ul><li><code>peps</code>: final <code>InfinitePEPS</code></li><li><code>env</code>: <code>CTMRGEnv</code> corresponding to the final PEPS</li><li><code>E</code>: final energy</li><li><code>E_history</code>: convergence history of the energy function</li><li><code>grad</code>: final energy gradient</li><li><code>gradnorm_history</code>: convergence history of the energy gradient norms</li><li><code>numfg</code>: total number of calls to the energy function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/peps_opt.jl#L120-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fpgrad" href="#PEPSKit.fpgrad"><code>PEPSKit.fpgrad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)</code></pre><p>Compute the gradient of the cost function for CTMRG by solving the following equation:</p><p>dx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA</p><p>where <code>∂F∂x</code> is the gradient of the cost function with respect to the PEPS tensors, <code>∂f∂x</code> is the partial gradient of the CTMRG iteration with respect to the environment tensors, <code>∂f∂A</code> is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and <code>y0</code> is the initial guess for the fixed-point iteration. The function returns the gradient <code>dx</code> of the fixed-point iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/peps_opt.jl#L285-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.full_infinite_environment-Union{Tuple{T}, NTuple{4, T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Number, &lt;:TensorKit.ElementarySpace, 3, 3})" href="#PEPSKit.full_infinite_environment-Union{Tuple{T}, NTuple{4, T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Number, &lt;:TensorKit.ElementarySpace, 3, 3})"><code>PEPSKit.full_infinite_environment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">full_infinite_environment(
    quadrant1::T, quadrant2::T, quadrant3::T, quadrant4::T
) where {T&lt;:AbstractTensorMap{&lt;:Number,&lt;:ElementarySpace,3,3}}
function full_infinite_environment(
    half1::T, half2::T
) where {T&lt;:AbstractTensorMap{&lt;:Number,&lt;:ElementarySpace,3,3}}
full_infinite_environment(C_1, C_2, C_3, C_4, E_1, E_2, E_3, E_4, E_5, E_6, E_7, E_8,
                          ket_1::P, bra_1::P, ket_2::P, bra_2::P,
                          ket_3::P, bra_3::P, ket_4::P, bra_4::P) where {P&lt;:PEPSTensor}
full_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x,
                          ket_1::P, bra_1::P, ket_2::P, bra_2::P,
                          ket_3::P, bra_3::P, ket_4::P, bra_4::P) where {P&lt;:PEPSTensor}
full_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4,
                          ket_1::P, bra_1::P, ket_2::P, bra_2::P,
                          ket_3::P, bra_3::P, ket_4::P, bra_4::P) where {P&lt;:PEPSTensor}

full_infinite_environment(
    quadrant1::T, quadrant2::T, quadrant3::T, quadrant4::T
) where {T&lt;:AbstractTensorMap{&lt;:Number,&lt;:ElementarySpace,2,2}}
function full_infinite_environment(
    half1::T, half2::T
) where {T&lt;:AbstractTensorMap{&lt;:Number,&lt;:ElementarySpace,2,2}}
full_infinite_environment(C_1, C_2, C_3, C_4, E_1, E_2, E_3, E_4, E_5, E_6, E_7, E_8,
                          partfunc_1::P, partfunc_2::P, partfunc_3::P, partfunc_4::P) where {P&lt;:PartitionFunctionTensor}
full_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x,
                          partfunc_1::P, partfunc_2::P, partfunc_3::P, partfunc_4::P) where {P&lt;:PartitionFunctionTensor}
full_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4,
                          partfunc_1::P, partfunc_2::P, partfunc_3::P, partfunc_4::P) where {P&lt;:PartitionFunctionTensor}</code></pre><p>Contract four quadrants (enlarged corners) to form a full-infinite environment.</p><pre><code class="nohighlight hljs">    |~~~~~~~~~| -- |~~~~~~~~~|
    |quadrant1|    |quadrant2|
    |~~~~~~~~~| -- |~~~~~~~~~|
      |     |        |     |
                     |     |
      |     |        |     |
    |~~~~~~~~~| -- |~~~~~~~~~|
    |quadrant4|    |quadrant3|
    |~~~~~~~~~| -- |~~~~~~~~~|</code></pre><p>In the same manner two halfs can be used to contract the full-infinite environment.</p><pre><code class="nohighlight hljs">    |~~~~~~~~~~~~~~~~~~~~~~~~|
    |         half1          |
    |~~~~~~~~~~~~~~~~~~~~~~~~|
      |     |        |     |
                     |     |
      |     |        |     |
    |~~~~~~~~~~~~~~~~~~~~~~~~|
    |         half2          |
    |~~~~~~~~~~~~~~~~~~~~~~~~|</code></pre><p>The environment can also be contracted directly from all its constituent tensors.</p><pre><code class="nohighlight hljs">    C_1 -- E_2 -- E_3 -- C_2
     |      |      |      | 
    E_1 -- A_1 -- A_2 -- E_4
     |      |      |      |
                   |      |
     |      |      |      |
    E_8 -- A_4 -- A_3 -- E_5
     |      |      |      |
    C_4 -- E_7 -- E_6 -- C_3</code></pre><p>Alternatively, contract the environment with a vector <code>x</code> acting on it</p><pre><code class="nohighlight hljs">    C_1 -- E_2 -- E_3 -- C_2
     |      |      |      | 
    E_1 -- A_1 -- A_2 -- E_4
     |      |      |      |
                   |      |
    [~~~~x~~~]     |      |
     |      |      |      |
    E_8 -- A_4 -- A_3 -- E_5
     |      |      |      |
    C_4 -- E_7 -- E_6 -- C_3
</code></pre><p>or contract the adjoint environment with <code>x</code>, e.g. as needed for iterative solvers.</p><p>Here <code>A</code> systematically denotes either:</p><ul><li>a local pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L535-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}" href="#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}"><code>PEPSKit.gauge_fix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gauge_fix(envprev::CTMRGEnv{C,T}, envfinal::CTMRGEnv{C,T}) where {C,T}</code></pre><p>Fix the gauge of <code>envfinal</code> based on the previous environment <code>envprev</code>. This assumes that the <code>envfinal</code> is the result of one CTMRG iteration on <code>envprev</code>. Given that the CTMRG run is converged, the returned environment will be element-wise converged to <code>envprev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/gaugefix.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.get_gate-Tuple{Float64, LocalOperator}" href="#PEPSKit.get_gate-Tuple{Float64, LocalOperator}"><code>PEPSKit.get_gate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_gate(dt::Float64, H::LocalOperator)</code></pre><p>Compute <code>exp(-dt * H)</code> from the nearest neighbor Hamiltonian <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/time_evolution/evoltools.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.get_gateterm-Tuple{LocalOperator, Tuple{CartesianIndex{2}, CartesianIndex{2}}}" href="#PEPSKit.get_gateterm-Tuple{LocalOperator, Tuple{CartesianIndex{2}, CartesianIndex{2}}}"><code>PEPSKit.get_gateterm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_gateterm(gate::LocalOperator, bond::NTuple{2,CartesianIndex{2}})</code></pre><p>Get the term of a 2-site gate acting on a certain bond. Input <code>gate</code> should only include one term for each nearest neighbor bond.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/time_evolution/evoltools.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.half_infinite_environment-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, TensorKit.AbstractTensorMap{T, S, 3, 3}}} where {T, S}" href="#PEPSKit.half_infinite_environment-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, TensorKit.AbstractTensorMap{T, S, 3, 3}}} where {T, S}"><code>PEPSKit.half_infinite_environment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">half_infinite_environment(quadrant1::AbstractTensorMap{T,S,3,3}, quadrant2::AbstractTensorMap{T,S,3,3})
half_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4,
                          ket_1::P, bra_1::P, ket_2::P, bra_2::P) where {P&lt;:PEPSTensor}
half_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x,
                          ket_1::P bra_1::P, ket_2::P,, bra_2::P) where {P&lt;:PEPSTensor}
half_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4,
                          ket_1::P, bra_1::P, ket_2::P, bra_2::P) where {P&lt;:PEPSTensor}

half_infinite_environment(quadrant1::AbstractTensorMap{T,S,2,2}, quadrant2::AbstractTensorMap{T,S,2,2})
half_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4,
                          partfunc_1::P, partfunc_2::P) where {P&lt;:PartitionFunctionTensor}
half_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x,
                          partfunc_1::P, partfunc_2::P) where {P&lt;:PartitionFunctionTensor}
half_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4,
                          partfunc_1::P, partfunc_2::P) where {P&lt;:PartitionFunctionTensor}</code></pre><p>Contract two quadrants (enlarged corners) to form a half-infinite environment.</p><pre><code class="nohighlight hljs">    |~~~~~~~~~| -- |~~~~~~~~~|
    |quadrant1|    |quadrant2|
    |~~~~~~~~~| -- |~~~~~~~~~|
      |     |        |     |</code></pre><p>The environment can also be contracted directly from all its constituent tensors.</p><pre><code class="nohighlight hljs">    C_1 -- E_2 -- E_3 -- C_2
     |      |      |      | 
    E_1 -- A_1 -- A_2 -- E_4
     |      |      |      |</code></pre><p>Alternatively, contract the environment with a vector <code>x</code> acting on it</p><pre><code class="nohighlight hljs">    C_1 -- E_2 -- E_3 -- C_2
     |      |      |      | 
    E_1 -- A_1 -- A_2 -- E_4
     |      |      |      |
                  [~~~x~~~~]</code></pre><p>or contract the adjoint environment with <code>x</code>, e.g. as needed for iterative solvers.</p><p>Here <code>A</code> systematically denotes either:</p><ul><li>a local pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L361-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}" href="#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}"><code>PEPSKit.hook_pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hook_pullback(f, args...; alg_rrule=nothing, kwargs...)</code></pre><p>Wrapper function to customize the pullback of a function <code>f</code>. This function is equivalent to <code>f(args...; kwargs...)</code>, but the pullback can be customized by implementing the following function:</p><pre><code class="nohighlight hljs">_rrule(alg_rrule, config, f, args...; kwargs...) -&gt; NoTangent(), ∂f, ∂args...</code></pre><p>This function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default <code>alg_rrule=nothing</code> results in the default AD pullback.</p><p>See also <a href="#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}"><code>_rrule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/hook_pullback.jl#L10-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.initializeMPS-Union{Tuple{S}, Tuple{Union{MPSKit.MPO{Tuple{T, T}, MPSKit.PeriodicArray{Tuple{T, T}, 1}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), MPSKit.MPO{Tuple{T, T, NTuple{H, O}}, MPSKit.PeriodicArray{Tuple{T, T, NTuple{H, O}}, 1}} where {H, T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), O&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)}}, AbstractVector{S}}} where S" href="#PEPSKit.initializeMPS-Union{Tuple{S}, Tuple{Union{MPSKit.MPO{Tuple{T, T}, MPSKit.PeriodicArray{Tuple{T, T}, 1}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), MPSKit.MPO{Tuple{T, T, NTuple{H, O}}, MPSKit.PeriodicArray{Tuple{T, T, NTuple{H, O}}, 1}} where {H, T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), O&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)}}, AbstractVector{S}}} where S"><code>PEPSKit.initializeMPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initializeMPS(
    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},
    virtualspaces::AbstractArray{&lt;:ElementarySpace,1}
)
initializeMPS(
    O::Union{MultilineTransferPEPS,MultilineTransferPEPO},
    virtualspaces::AbstractArray{&lt;:ElementarySpace,2}
)</code></pre><p>Inialize a boundary MPS for the transfer operator <code>O</code> by specifying an array of virtual spaces consistent with the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/transfermatrix.jl#L174-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.is_equivalent-Tuple{Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{Int64, Int64}}" href="#PEPSKit.is_equivalent-Tuple{Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{Int64, Int64}}"><code>PEPSKit.is_equivalent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_equivalent(bond1::NTuple{2,CartesianIndex{2}}, bond2::NTuple{2,CartesianIndex{2}}, (Nrow, Ncol)::NTuple{2,Int})</code></pre><p>Check if two 2-site bonds are related by a (periodic) lattice translation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/time_evolution/evoltools.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.j1_j2-Tuple{InfiniteSquare}" href="#PEPSKit.j1_j2-Tuple{InfiniteSquare}"><code>PEPSKit.j1_j2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">j1_j2([elt::Type{T}], [symm::Type{S}], [lattice::InfiniteSquare];
      J1=1.0, J2=1.0, spin=1//2, sublattice=true)</code></pre><p>Square lattice J₁-J₂ model. The <code>sublattice</code> kwarg enables a single site unit cell via a sublattice rotation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/models.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.left_projector" href="#PEPSKit.left_projector"><code>PEPSKit.left_projector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">left_projector(E_1, C, E_2, V, isqS, ket::PEPSTensor, bra::PEPSTensor=ket)
left_projector(E_1, C, E_2, V, isqS, partfunc::PartitionFunctionTensor)</code></pre><p>Contract the CTMRG left projector with the higher-dimensional subspace facing to the left.</p><pre><code class="nohighlight hljs">     C  --  E_2    -- |~~|
     |       |        |V&#39;| -- isqS --
    E_1 --   A     -- |~~|
     |       |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L268-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.mirror_antidiag-Tuple{AbstractMatrix}" href="#PEPSKit.mirror_antidiag-Tuple{AbstractMatrix}"><code>PEPSKit.mirror_antidiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mirror_antidiag(arr::AbstractMatrix)</code></pre><p>Mirror a matrix by its anti-diagonal line (the 45 degree line through the lower-left corner).</p><p>The element originally at [r, c] is moved [Nc-c+1, Nr-r+1], i.e. the element now at [r, c] was originally at [Nr-c+1, Nc-r+1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/mirror.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.mirror_antidiag-Tuple{InfiniteWeightPEPS}" href="#PEPSKit.mirror_antidiag-Tuple{InfiniteWeightPEPS}"><code>PEPSKit.mirror_antidiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mirror_antidiag(peps::InfiniteWeightPEPS)</code></pre><p>Mirror the unit cell of an iPEPS with weights by its anti-diagonal line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/states/infiniteweightpeps.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.mirror_antidiag-Tuple{LocalOperator}" href="#PEPSKit.mirror_antidiag-Tuple{LocalOperator}"><code>PEPSKit.mirror_antidiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mirror_antidiag(H::LocalOperator)</code></pre><p>Mirror a <code>LocalOperator</code> across the anti-diagonal axis of its lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/localoperator.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.nearest_neighbour_hamiltonian-Union{Tuple{T}, Tuple{S}, Tuple{Matrix{S}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {S, T}" href="#PEPSKit.nearest_neighbour_hamiltonian-Union{Tuple{T}, Tuple{S}, Tuple{Matrix{S}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {S, T}"><code>PEPSKit.nearest_neighbour_hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nearest_neighbour_hamiltonian(
    lattice::Matrix{S}, h::AbstractTensorMap{T,S,2,2}
) where {S,T}</code></pre><p>Create a nearest neighbor <code>LocalOperator</code> by specifying the 2-site interaction term <code>h</code> which acts both in horizontal and vertical direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/models.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.product_peps-Tuple" href="#PEPSKit.product_peps-Tuple"><code>PEPSKit.product_peps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">product_peps(peps_args...; unitcell=(1, 1), noise_amp=1e-2, state_vector=nothing)</code></pre><p>Initialize a normalized random product PEPS with noise. The given arguments are passed on to the <code>InfinitePEPS</code> constructor.</p><p>The noise intensity can be tuned with <code>noise_amp</code>. The product state coefficients can be specified using the <code>state_vector</code> kwarg in the form of a matrix of size <code>unitcell</code> containing vectors that match the PEPS physical dimensions. If <code>nothing</code> is provided, random Gaussian coefficients are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/toolbox.jl#L214-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.pwave_superconductor-Tuple{InfiniteSquare}" href="#PEPSKit.pwave_superconductor-Tuple{InfiniteSquare}"><code>PEPSKit.pwave_superconductor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pwave_superconductor(::Type{T}=ComplexF64; t=1, μ=2, Δ=1, unitcell=(1, 1))</code></pre><p>Square lattice p-wave superconductor model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/operators/models.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_bottom_corner-Union{Tuple{C}, Tuple{Any, CTMRGEnv{C, &lt;:TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}}, Any}} where C" href="#PEPSKit.renormalize_bottom_corner-Union{Tuple{C}, Tuple{Any, CTMRGEnv{C, &lt;:TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}}, Any}} where C"><code>PEPSKit.renormalize_bottom_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_bottom_corner((r, c), envs, projectors)</code></pre><p>Apply bottom projector to southwest corner and south edge.</p><pre><code class="nohighlight hljs">        | 
    [P_bottom]
     |     |
     C --  E -- in</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1198-L1208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_corner-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, Any, Any}} where {T, S}" href="#PEPSKit.renormalize_corner-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, Any, Any}} where {T, S}"><code>PEPSKit.renormalize_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_corner(quadrant::AbstractTensorMap{T,S,3,3}, P_left, P_right)
renormalize_corner(quadrant::AbstractTensorMap{T,S,2,2}, P_left, P_right)</code></pre><p>Apply projectors to each side of a quadrant.</p><pre><code class="nohighlight hljs">    |~~~~~~~~| -- |~~~~~~|
    |quadrant|    |P_left| --
    |~~~~~~~~| -- |~~~~~~|
     |     |
    [P_right]
        |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L911-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_east_edge" href="#PEPSKit.renormalize_east_edge"><code>PEPSKit.renormalize_east_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">renormalize_east_edge((row, col), envs, P_top, P_bottom, ket::InfinitePEPS, bra::InfinitePEPS=ket)
renormalize_east_edge(E_east, P_top, P_bottom, ket::PEPSTensor, bra::PEPSTensor=ket)
renormalize_east_edge((row, col), envs, P_top, P_bottom, partfunc::InfinitePartitionFunction)
renormalize_east_edge(E_east, P_top, P_bottom, partfunc::PartitionFunctionTensor)</code></pre><p>Absorb a blocal effective tensor into the east edge using the given projectors and environment tensors.</p><pre><code class="nohighlight hljs">           |
     [~P_bottom~]
      |        |
    E_east --  A -- 
      |        |
     [~~P_top~~~]
           |</code></pre><p>Here <code>A</code> denotes either:</p><ul><li>a pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1317-L1339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_north_edge" href="#PEPSKit.renormalize_north_edge"><code>PEPSKit.renormalize_north_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">renormalize_north_edge((row, col), envs, P_left, P_right, ket::InfinitePEPS, bra::InfinitePEPS=ket)
renormalize_north_edge(E_north, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)
renormalize_north_edge((row, col), envs, P_left, P_right, partfunc::InfinitePartitionFunction)
renormalize_north_edge(E_north, P_left, P_right, partfunc::PartitionFunctionTensor)</code></pre><p>Absorb a local effective tensor <code>A</code> into the north edge using the given projectors and environment tensors.</p><pre><code class="nohighlight hljs">       |~~~~~~| -- E_north -- |~~~~~~~| 
    -- |P_left|       |       |P_right| --
       |~~~~~~| --    A    -- |~~~~~~~| 
                      |</code></pre><p>Here <code>A</code> denotes either:</p><ul><li>a pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1256-L1275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_northeast_corner-NTuple{4, Any}" href="#PEPSKit.renormalize_northeast_corner-NTuple{4, Any}"><code>PEPSKit.renormalize_northeast_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_northeast_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)
renormalize_northwest_corner(quadrant::AbstractTensorMap{T,S,3,3}, P_left, P_right) where {T,S}
renormalize_northeast_corner(E_north, C_northeast, E_east, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)
renormalize_northwest_corner(quadrant::AbstractTensorMap{T,S,2,2}, P_left, P_right) where {T,S}
renormalize_northeast_corner(E_north, C_northeast, E_east, P_left, P_right, partfunc::PartitionFunctionTensor)</code></pre><p>Apply <code>renormalize_corner</code> to the enlarged northeast corner. Alternatively, provide the constituent tensors and perform the complete contraction.</p><pre><code class="nohighlight hljs">       |~~~~~~~| -- E_north -- C_northeast
    -- |P_right|       |            |  
       |~~~~~~~| --    A    --    E_east
                       |            |
                     [~~~~~P_left~~~~~]
                              |</code></pre><p>Here <code>A</code> denotes either:</p><ul><li>a local pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1003-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_northwest_corner-NTuple{4, Any}" href="#PEPSKit.renormalize_northwest_corner-NTuple{4, Any}"><code>PEPSKit.renormalize_northwest_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_northwest_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)
renormalize_northwest_corner(quadrant::AbstractTensorMap{T,S,3,3}, P_left, P_right) where {T,S}
renormalize_northwest_corner(E_west, C_northwest, E_north, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)
renormalize_northwest_corner(quadrant::AbstractTensorMap{T,S,2,2}, P_left, P_right) where {T,S}
renormalize_northwest_corner(E_west, C_northwest, E_north, P_left, P_right, partfunc::PartitionFunctionTensor)</code></pre><p>Apply <code>renormalize_corner</code> to the enlarged northwest corner. Alternatively, provide the constituent tensors and perform the complete contraction.</p><pre><code class="nohighlight hljs">    C_northwest -- E_north -- |~~~~~~|
         |           |        |P_left| --
      E_west    --   A     -- |~~~~~~|
         |           |
      [~~~~~P_right~~~~]
               |</code></pre><p>Here <code>A</code> denotes either:</p><ul><li>a local pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L939-L961">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_sequentially-Tuple{Int64, Any, Any, Any}" href="#PEPSKit.renormalize_sequentially-Tuple{Int64, Any, Any, Any}"><code>PEPSKit.renormalize_sequentially</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_sequentially(col::Int, projectors, state, envs)</code></pre><p>Renormalize one column of the CTMRG environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sequential.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_simultaneously-NTuple{4, Any}" href="#PEPSKit.renormalize_simultaneously-NTuple{4, Any}"><code>PEPSKit.renormalize_simultaneously</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_simultaneously(enlarged_corners, projectors, state, envs)</code></pre><p>Renormalize all enlarged corners and edges simultaneously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/simultaneous.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_south_edge" href="#PEPSKit.renormalize_south_edge"><code>PEPSKit.renormalize_south_edge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">renormalize_south_edge((row, col), envs, P_left, P_right, ket::InfinitePEPS, bra::InfinitePEPS=ket)
renormalize_south_edge(E_south, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)
renormalize_south_edge((row, col), envs, P_left, P_right, partfunc::InfinitePartitionFunction)
renormalize_south_edge(E_south, P_left, P_right, partfunc::PartitionFunctionTensor)</code></pre><p>Absorb a local effective tensor into the south edge using the given projectors and environment tensors.</p><pre><code class="nohighlight hljs">                       |
       |~~~~~~~| --    A    -- |~~~~~~| 
    -- |P_right|       |       |P_left| --
       |~~~~~~~| -- E_south -- |~~~~~~| 
                       |</code></pre><p>Here <code>A</code> denotes either:</p><ul><li>a pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1381-L1401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_southeast_corner-NTuple{4, Any}" href="#PEPSKit.renormalize_southeast_corner-NTuple{4, Any}"><code>PEPSKit.renormalize_southeast_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_southeast_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)
renormalize_southeast_corner(quadrant::AbstractTensorMap{T,S,3,3}, P_left, P_right) where {T,S}
renormalize_southeast_corner(E_east, C_southeast, E_south, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)
renormalize_southeast_corner(quadrant::AbstractTensorMap{T,S,2,2}, P_left, P_right) where {T,S}
renormalize_southeast_corner(E_east, C_southeast, E_south, P_left, P_right, partfunc::PartitionFunctionTensor)</code></pre><p>Apply <code>renormalize_corner</code> to the enlarged southeast corner. Alternatively, provide the constituent tensors and perform the complete contraction.</p><pre><code class="nohighlight hljs">                            |
                    [~~~~P_right~~~~]
                      |           |
       |~~~~~~| --    A    --   E_east
    -- |P_left|       |           |
       |~~~~~~| -- E_south -- C_southeast</code></pre><p>Here <code>A</code> denotes either:</p><ul><li>a local pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1069-L1091">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_southwest_corner-NTuple{4, Any}" href="#PEPSKit.renormalize_southwest_corner-NTuple{4, Any}"><code>PEPSKit.renormalize_southwest_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_southwest_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)
renormalize_southwest_corner(quadrant::AbstractTensorMap{T,S,3,3}, P_left, P_right) where {T,S}
renormalize_southwest_corner(E_south, C_southwest, E_west, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)
renormalize_southwest_corner(quadrant::AbstractTensorMap{T,S,2,2}, P_left, P_right) where {T,S}
renormalize_southwest_corner(E_south, C_southwest, E_west, P_left, P_right, partfunc::PartitionFunctionTensor)</code></pre><p>Apply <code>renormalize_corner</code> to the enlarged southwest corner. Alternatively, provide the constituent tensors and perform the complete contraction.</p><pre><code class="nohighlight hljs">               |
       [~~~~P_right~~~~~]
         |            |
       E_west   --    A    -- |~~~~~~|
         |            |       |P_left| --
    C_southwest -- E_south -- |~~~~~~|</code></pre><p>Here <code>A</code> denotes either:</p><ul><li>a pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1134-L1156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_top_corner-Tuple{Any, CTMRGEnv, Any}" href="#PEPSKit.renormalize_top_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.renormalize_top_corner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_top_corner((row, col), envs::CTMRGEnv, projectors)</code></pre><p>Apply top projector to northwest corner and north edge.</p><pre><code class="nohighlight hljs">     C -- E -- 
     |    |
    [~P_top~]
        | </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1228-L1238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.renormalize_west_edge-Union{Tuple{Pb}, Tuple{Pt}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfinitePEPS}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfinitePEPS, InfinitePEPS}} where {Pt, Pb}" href="#PEPSKit.renormalize_west_edge-Union{Tuple{Pb}, Tuple{Pt}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfinitePEPS}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfinitePEPS, InfinitePEPS}} where {Pt, Pb}"><code>PEPSKit.renormalize_west_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormalize_west_edge((row, col), envs, P_top, P_bottom, ket::InfinitePEPS, bra::InfinitePEPS=ket)
renormalize_west_edge(E_west, P_top, P_bottom, ket::PEPSTensor, bra::PEPSTensor=ket)
renormalize_west_edge((row, col), envs, P_top, P_bottom, partfunc::InfinitePartitionFunction)
renormalize_west_edge(E_west, P_top, P_bottom, partfunc::PartitionFunctionTensor)</code></pre><p>Absorb a local effective tensor into the west edge using the given projectors and environment tensors.</p><pre><code class="nohighlight hljs">           |
     [~P_bottom~]
      |        |
   -- A  --  E_west
      |        |
     [~~P_top~~~]
           |</code></pre><p>Here <code>A</code> denotes either:</p><ul><li>a pair of &#39;ket&#39; and &#39;bra&#39; <code>PEPSTensor</code>s</li><li>a <code>PartitionFunctionTensor</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L1443-L1465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.right_projector" href="#PEPSKit.right_projector"><code>PEPSKit.right_projector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">right_projector(E_1, C, E_2, U, isqS, ket::PEPSTensor, bra::PEPSTensor=ket)
right_projector(E_1, C, E_2, U, isqS, partfunc::PartitionFunctionTensor)</code></pre><p>Contract the CTMRG right projector with the higher-dimensional subspace facing to the right.</p><pre><code class="nohighlight hljs">               |~~| --   E_2   --  C
    -- isqS -- |U&#39;|      |         |
               |~~| --   A     -- E_1
                         |         |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/contractions/ctmrg_contractions.jl#L301-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.rotate_north-Tuple{Any, Any}" href="#PEPSKit.rotate_north-Tuple{Any, Any}"><code>PEPSKit.rotate_north</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_north(t, dir)</code></pre><p>Rotate the <code>dir</code> direction of <code>t</code> to face north by successive applications of <code>rotl90</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/rotations.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.sdiag_pow-Tuple{TensorKit.DiagonalTensorMap, Real}" href="#PEPSKit.sdiag_pow-Tuple{TensorKit.DiagonalTensorMap, Real}"><code>PEPSKit.sdiag_pow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sdiag_pow(s, pow::Real; tol::Real=eps(scalartype(s))^(3 / 4))</code></pre><p>Compute <code>s^pow</code> for a diagonal matrix <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/util.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.sequential_projectors-Tuple{Int64, PEPSKit.InfiniteSquareNetwork, CTMRGEnv, PEPSKit.ProjectorAlgorithm}" href="#PEPSKit.sequential_projectors-Tuple{Int64, PEPSKit.InfiniteSquareNetwork, CTMRGEnv, PEPSKit.ProjectorAlgorithm}"><code>PEPSKit.sequential_projectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sequential_projectors(col::Int, state::InfinitePEPS, envs::CTMRGEnv, alg::ProjectorAlgorithm)
sequential_projectors(coordinate::NTuple{3,Int}, state::InfinitePEPS, envs::CTMRGEnv, alg::ProjectorAlgorithm)</code></pre><p>Compute CTMRG projectors in the <code>:sequential</code> scheme either for an entire column <code>col</code> or for a specific <code>coordinate</code> (where <code>dir=WEST</code> is already implied in the <code>:sequential</code> scheme).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/sequential.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.simpleupdate-Tuple{InfiniteWeightPEPS, LocalOperator, SimpleUpdate}" href="#PEPSKit.simpleupdate-Tuple{InfiniteWeightPEPS, LocalOperator, SimpleUpdate}"><code>PEPSKit.simpleupdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simpleupdate(peps::InfiniteWeightPEPS, ham::LocalOperator, alg::SimpleUpdate;
             bipartite::Bool=false, check_int::Int=500)</code></pre><p>Perform simple update with nearest neighbor Hamiltonian <code>ham</code>, where the evolution information is printed every <code>check_int</code> steps. </p><p>If <code>bipartite == true</code> (for square lattice), a unit cell size of <code>(2, 2)</code> is assumed,  as well as tensors and x/y weights which are the same across the diagonals, i.e. at <code>(row, col)</code> and <code>(row+1, col+1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/time_evolution/simpleupdate.jl#L159-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.simultaneous_projectors-Union{Tuple{E}, Tuple{Array{E, 3}, CTMRGEnv, PEPSKit.ProjectorAlgorithm}} where E" href="#PEPSKit.simultaneous_projectors-Union{Tuple{E}, Tuple{Array{E, 3}, CTMRGEnv, PEPSKit.ProjectorAlgorithm}} where E"><code>PEPSKit.simultaneous_projectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simultaneous_projectors(enlarged_corners::Array{E,3}, envs::CTMRGEnv, alg::ProjectorAlgorithm)
simultaneous_projectors(coordinate, enlarged_corners::Array{E,3}, alg::ProjectorAlgorithm)</code></pre><p>Compute CTMRG projectors in the <code>:simultaneous</code> scheme either for all provided enlarged corners or on a specific <code>coordinate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/ctmrg/simultaneous.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.su_iter-Tuple{LocalOperator, InfiniteWeightPEPS, SimpleUpdate}" href="#PEPSKit.su_iter-Tuple{LocalOperator, InfiniteWeightPEPS, SimpleUpdate}"><code>PEPSKit.su_iter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">su_iter(gate::LocalOperator, peps::InfiniteWeightPEPS, alg::SimpleUpdate; bipartite::Bool=false)</code></pre><p>One round of simple update on <code>peps</code> applying the nearest neighbor <code>gate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/time_evolution/simpleupdate.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}" href="#PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}"><code>PEPSKit.symmetrize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetrize!(peps::InfinitePEPS, ::SymmetrizationStyle)</code></pre><p>Symmetrize a PEPS using the given <code>SymmetrizationStyle</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/symmetrization.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.symmetrize_retract_and_finalize!-Tuple{PEPSKit.SymmetrizationStyle}" href="#PEPSKit.symmetrize_retract_and_finalize!-Tuple{PEPSKit.SymmetrizationStyle}"><code>PEPSKit.symmetrize_retract_and_finalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetrize_retract_and_finalize!(symm::SymmetrizationStyle)</code></pre><p>Return the <code>retract</code> and <code>finalize!</code> function for symmetrizing the <code>peps</code> and <code>grad</code> tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/symmetrization.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.value-Tuple{InfinitePartitionFunction, CTMRGEnv}" href="#PEPSKit.value-Tuple{InfinitePartitionFunction, CTMRGEnv}"><code>PEPSKit.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(partfunc::InfinitePartitionFunction, env::CTMRGEnv)</code></pre><p>Return the value (per site) of a given partition function contracted using a given CTMRG environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/algorithms/toolbox.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.tsvd-Tuple{Any, Any}" href="#TensorKit.tsvd-Tuple{Any, Any}"><code>TensorKit.tsvd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PEPSKit.tsvd(t, alg; trunc=notrunc(), p=2)</code></pre><p>Wrapper around <code>TensorKit.tsvd</code> which dispatches on the <code>alg</code> argument. This is needed since a custom adjoint for <code>PEPSKit.tsvd</code> may be defined, depending on the algorithm. E.g., for <code>IterSVD</code> the adjoint for a truncated SVD from <code>KrylovKit.svdsolve</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/svd.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.@autoopt-Tuple{Any}" href="#PEPSKit.@autoopt-Tuple{Any}"><code>PEPSKit.@autoopt</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">autoopt(ex)</code></pre><p>Preprocessor macro for <code>@tensor</code> which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with <code>d</code>, <code>D</code>, or <code>χ</code> are automatically inserted with the corresponding costs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/autoopt.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.@diffset-Tuple{Any}" href="#PEPSKit.@diffset-Tuple{Any}"><code>PEPSKit.@diffset</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@diffset assign</code></pre><p>Helper macro which allows in-place operations in the forward-pass of Zygote, but resorts to non-mutating operations in the backwards-pass. The expression <code>assign</code> should assign an object to an pre-existing <code>AbstractArray</code> and the use of updating operators is also possible. This is especially needed when in-place assigning tensors to unit-cell arrays of environments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/diffset.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.@fwdthreads-Tuple{Any}" href="#PEPSKit.@fwdthreads-Tuple{Any}"><code>PEPSKit.@fwdthreads</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@fwdthreads(ex)</code></pre><p>Apply <code>Threads.@threads</code> only in the forward pass of the program.</p><p>It works by wrapping the for-loop expression in an if statement where in the forward pass the loop in computed in parallel using <code>Threads.@threads</code>, whereas in the backwards pass the <code>Threads.@threads</code> is omitted in order to make the expression differentiable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/diffable_threads.jl#L36-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.@showtypeofgrad-Tuple{Any}" href="#PEPSKit.@showtypeofgrad-Tuple{Any}"><code>PEPSKit.@showtypeofgrad</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@showtypeofgrad(x)</code></pre><p>Macro utility to show to type of the gradient that is about to accumulate for <code>x</code>.</p><p>See also <a href="lib/@ref"><code>Zygote.@showgrad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/utility/util.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.Defaults" href="#PEPSKit.Defaults"><code>PEPSKit.Defaults</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Defaults
    const ctmrg_maxiter = 100
    const ctmrg_miniter = 4
    const ctmrg_tol = 1e-8
    const fpgrad_maxiter = 30
    const fpgrad_tol = 1e-6
    const reuse_env = true
    const trscheme = FixedSpaceTruncation()
    const fwd_alg = TensorKit.SDD()
    const rrule_alg = Arnoldi(; tol=1e-2fpgrad_tol, krylovdim=48, verbosity=-1)
    const svd_alg = SVDAdjoint(; fwd_alg, rrule_alg)
    const projector_alg_type = HalfInfiniteProjector
    const projector_alg = projector_alg_type(svd_alg, trscheme, 2)
    const ctmrg_alg = SimultaneousCTMRG(
        ctmrg_tol, ctmrg_maxiter, ctmrg_miniter, 2, projector_alg
    )
    const optimizer = LBFGS(32; maxiter=100, gradtol=1e-4, verbosity=3)
    const gradient_linsolver = KrylovKit.BiCGStab(;
        maxiter=Defaults.fpgrad_maxiter, tol=Defaults.fpgrad_tol
    )
    const iterscheme = :fixed
    const gradient_alg = LinSolver(; solver=gradient_linsolver, iterscheme)
    const scheduler = Ref{Scheduler}(Threads.nthreads() == 1 ? SerialScheduler() : DynamicScheduler())
end</code></pre><p>Module containing default values that represent typical algorithm parameters.</p><ul><li><code>ctmrg_maxiter</code>: Maximal number of CTMRG iterations per run</li><li><code>ctmrg_miniter</code>: Minimal number of CTMRG carried out</li><li><code>ctmrg_tol</code>: Tolerance checking singular value and norm convergence</li><li><code>fpgrad_maxiter</code>: Maximal number of iterations for computing the CTMRG fixed-point gradient</li><li><code>fpgrad_tol</code>: Convergence tolerance for the fixed-point gradient iteration</li><li><code>reuse_env</code>: If <code>true</code>, the current optimization step is initialized on the previous environment</li><li><code>trscheme</code>: Truncation scheme for SVDs and other decompositions</li><li><code>fwd_alg</code>: SVD algorithm that is used in the forward pass</li><li><code>rrule_alg</code>: Reverse-rule for differentiating that SVD</li><li><code>svd_alg</code>: Combination of <code>fwd_alg</code> and <code>rrule_alg</code></li><li><code>projector_alg_type</code>: Default type of projector algorithm</li><li><code>projector_alg</code>: Algorithm to compute CTMRG projectors</li><li><code>ctmrg_alg</code>: Algorithm for performing CTMRG runs</li><li><code>optimizer</code>: Optimization algorithm for PEPS ground-state optimization</li><li><code>gradient_linsolver</code>: Default linear solver for the <code>LinSolver</code> gradient algorithm</li><li><code>iterscheme</code>: Scheme for differentiating one CTMRG iteration</li><li><code>gradient_alg</code>: Algorithm to compute the gradient fixed-point</li><li><code>scheduler</code>: Multi-threading scheduler which can be accessed via <code>set_scheduler!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/PEPSKit.jl#L61-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.Defaults.set_scheduler!" href="#PEPSKit.Defaults.set_scheduler!"><code>PEPSKit.Defaults.set_scheduler!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_scheduler!([scheduler]; kwargs...)</code></pre><p>Set <code>OhMyThreads</code> multi-threading scheduler parameters.</p><p>The function either accepts a <code>scheduler</code> as an <code>OhMyThreads.Scheduler</code> or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via</p><pre><code class="nohighlight hljs">set_scheduler!(StaticScheduler(; ntasks=4, chunking=true))</code></pre><p>or equivalently with </p><pre><code class="nohighlight hljs">set_scheduler!(:static; ntasks=4, chunking=true)</code></pre><p>For a detailed description of all schedulers and their keyword arguments consult the <a href="https://juliafolds2.github.io/OhMyThreads.jl/stable/refs/api/#Schedulers"><code>OhMyThreads</code> documentation</a>.</p><p>If no <code>scheduler</code> is passed and only kwargs are provided, the <code>DynamicScheduler</code> constructor is used with the provided kwargs.</p><p>To reset the scheduler to its default value, one calls <code>set_scheduler!</code> without passing arguments which then uses the default <code>DynamicScheduler()</code>. If the number of used threads is just one it falls back to <code>SerialScheduler()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/f0382f4f9da690a8e2c6b22608fe32f03323963b/src/PEPSKit.jl#L141-L166">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 5 February 2025 13:06">Wednesday 5 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
