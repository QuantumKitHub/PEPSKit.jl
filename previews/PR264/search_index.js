var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Corboz, P. (2016). Variational optimization with infinite projected entangled-pair states. Phys. Rev. B 94, 035133.\n\n\n\nEvenbly, G. (2018). Gauge fixing, canonical forms, and optimal truncations in tensor networks with closed loops. Phys. Rev. B 98, 085155.\n\n\n\nFrancuz, A.; Schuch, N. and Vanhecke, B. (2025). Stable and Efficient Differentiation of Tensor Network Algorithms. Physical Review Research 7, 013237.\n\n\n\nHaegeman, J. and Verstraete, F. (2017). Diagonalizing Transfer Matrices and Matrix Product Operators: A Medley of Exact and Computational Methods. Annual Review of Condensed Matter Physics 8, 355–406.\n\n\n\nHasenbusch, M. (2001). Monte Carlo Studies of the Three-Dimensional Ising Model in Equilibrium. International Journal of Modern Physics C 12, 911–1009.\n\n\n\nLiu, W.-Y.; Gong, S.-S.; Li, Y.-B.; Poilblanc, D.; Chen, W.-Q. and Gu, Z.-C. (2022). Gapless quantum spin liquid and global phase diagram of the spin-1/2 J1-J2 square antiferromagnetic Heisenberg model. Science Bulletin 67, 1034–1041.\n\n\n\nQin, M.; Shi, H. and Zhang, S. (2016). Benchmark study of the two-dimensional Hubbard model with auxiliary-field quantum Monte Carlo method. Phys. Rev. B 94, 085103.\n\n\n\nSandvik, A. W. (2010). Computational Studies of Quantum Spin Systems. AIP Conference Proceedings 1297, 135–338.\n\n\n\nVanderstraeten, L.; Burgelman, L.; Ponsioen, B.; Van Damme, M.; Vanhecke, B.; Corboz, P.; Haegeman, J. and Verstraete, F. (2022). Variational Methods for Contracting Projected Entangled-Pair States. Physical Review B 105, 195140.\n\n\n\nVanderstraeten, L.; Haegeman, J. and Verstraete, F. (2019). Tangent-Space Methods for Uniform Matrix Product States. SciPost Physics Lecture Notes, 007.\n\n\n\nVanderstraeten, L.; Vanhecke, B. and Verstraete, F. (2018). Residual entropies for three-dimensional frustrated spin systems with tensor networks. Phys. Rev. E 98, 042145.\n\n\n\n","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/xxz/#Néel-order-in-the-U(1)-symmetric-XXZ-model","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"","category":"section"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Here, we want to look at a special case of the Heisenberg model, where the x and y couplings are equal, called the XXZ model","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"H_0 = J big(sum_langle i j rangle S_i^x S_j^x + S_i^y S_j^y + Delta S_i^z S_j^z big) ","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"For appropriate Delta, the model enters an antiferromagnetic phase (Néel order) which we will force by adding staggered magnetic charges to H_0. Furthermore, since the XXZ Hamiltonian obeys a U(1) symmetry, we will make use of that and work with U(1)-symmetric PEPS and CTMRG environments. For simplicity, we will consider spin-12 operators.","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"But first, let's make this example deterministic and import the required packages:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"using Random\nusing TensorKit, PEPSKit\nusing MPSKit: add_physical_charge\nRandom.seed!(2928528935);","category":"page"},{"location":"examples/xxz/#Constructing-the-model","page":"Néel order in the U(1)-symmetric XXZ model","title":"Constructing the model","text":"","category":"section"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Let us define the U(1)-symmetric XXZ Hamiltonian on a 2 times 2 unit cell with the parameters:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"J = 1.0\nDelta = 1.0\nspin = 1 // 2\nsymmetry = U1Irrep\nlattice = InfiniteSquare(2, 2)\nH₀ = heisenberg_XXZ(ComplexF64, symmetry, lattice; J, Delta, spin);","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"This ensures that our PEPS ansatz can support the bipartite Néel order. As discussed above, we encode the Néel order directly in the ansatz by adding staggered auxiliary physical charges:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"S_aux = [\n    U1Irrep(-1 // 2) U1Irrep(1 // 2)\n    U1Irrep(1 // 2) U1Irrep(-1 // 2)\n]\nH = add_physical_charge(H₀, S_aux);","category":"page"},{"location":"examples/xxz/#Specifying-the-symmetric-virtual-spaces","page":"Néel order in the U(1)-symmetric XXZ model","title":"Specifying the symmetric virtual spaces","text":"","category":"section"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Before we create an initial PEPS and CTM environment, we need to think about which symmetric spaces we need to construct. Since we want to exploit the global U(1) symmetry of the model, we will use TensorKit's U1Spaces where we specify dimensions for each symmetry sector. From the virtual spaces, we will need to construct a unit cell (a matrix) of spaces which will be supplied to the PEPS constructor. The same is true for the physical spaces, which can be extracted directly from the Hamiltonian LocalOperator:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"V_peps = U1Space(0 => 2, 1 => 1, -1 => 1)\nV_env = U1Space(0 => 6, 1 => 4, -1 => 4, 2 => 2, -2 => 2)\nvirtual_spaces = fill(V_peps, size(lattice)...)\nphysical_spaces = physicalspace(H)","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"2×2 Matrix{TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}}:\n Rep[TensorKitSectors.U₁](0=>1, 1=>1)   Rep[TensorKitSectors.U₁](0=>1, -1=>1)\n Rep[TensorKitSectors.U₁](0=>1, -1=>1)  Rep[TensorKitSectors.U₁](0=>1, 1=>1)","category":"page"},{"location":"examples/xxz/#Ground-state-search","page":"Néel order in the U(1)-symmetric XXZ model","title":"Ground state search","text":"","category":"section"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"From this point onwards it's business as usual: Create an initial PEPS and environment (using the symmetric spaces), specify the algorithmic parameters and optimize:","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"boundary_alg = (; tol = 1.0e-8, alg = :simultaneous, trscheme = (; alg = :fixedspace))\ngradient_alg = (; tol = 1.0e-6, alg = :eigsolver, maxiter = 10, iterscheme = :diffgauge)\noptimizer_alg = (; tol = 1.0e-4, alg = :lbfgs, maxiter = 85, ls_maxiter = 3, ls_maxfg = 3)\n\npeps₀ = InfinitePEPS(randn, ComplexF64, physical_spaces, virtual_spaces)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, V_env), peps₀; boundary_alg...);","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"[ Info: CTMRG init:\tobj = -2.356413456811e+03 +3.307968169629e+02im\terr = 1.0000e+00\n[ Info: CTMRG conv 30:\tobj = +6.245129734283e+03 -4.008688847534e-08im\terr = 5.3638617378e-09\ttime = 13.26 sec\n","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Finally, we can optimize the PEPS with respect to the XXZ Hamiltonian and check the resulting ground state energy per site using our (2 times 2) unit cell. Note that the optimization might take a while since precompilation of symmetric AD code takes longer and because symmetric tensors do create a bit of overhead (which does pay off at larger bond and environment dimensions):","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"peps, env, E, info = fixedpoint(\n    H, peps₀, env₀; boundary_alg, gradient_alg, optimizer_alg, verbosity = 3\n)\n@show E / prod(size(lattice));","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"[ Info: LBFGS: initializing with f = -0.138513609508, ‖∇f‖ = 1.2196e+00\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -2.40e-02, ϕ - ϕ₀ = -4.51e-01\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    1, time  398.63 s: f = -0.589257888877, ‖∇f‖ = 3.6887e+00, α = 2.50e+01, m = 0, nfg = 4\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -7.97e-03, ϕ - ϕ₀ = -1.52e+00\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    2, time  471.79 s: f = -2.110619430506, ‖∇f‖ = 3.0001e+00, α = 2.50e+01, m = 0, nfg = 4\n[ Info: LBFGS: iter    3, time  489.29 s: f = -2.211007715638, ‖∇f‖ = 1.4524e+00, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    4, time  540.15 s: f = -2.468824623210, ‖∇f‖ = 1.2356e+00, α = 3.20e+00, m = 2, nfg = 3\n[ Info: LBFGS: iter    5, time  557.26 s: f = -2.531277644141, ‖∇f‖ = 1.6029e+00, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    6, time  573.35 s: f = -2.612553859919, ‖∇f‖ = 4.2867e-01, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    7, time  589.11 s: f = -2.622279660579, ‖∇f‖ = 1.9145e-01, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    8, time  603.99 s: f = -2.626484058783, ‖∇f‖ = 1.7329e-01, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    9, time  614.25 s: f = -2.631986947540, ‖∇f‖ = 1.8511e-01, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter   10, time  623.59 s: f = -2.639349412387, ‖∇f‖ = 1.9572e-01, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   11, time  632.73 s: f = -2.644232912048, ‖∇f‖ = 1.6746e-01, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   12, time  641.13 s: f = -2.646535544453, ‖∇f‖ = 6.8267e-02, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   13, time  649.63 s: f = -2.647359319818, ‖∇f‖ = 5.8837e-02, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   14, time  658.45 s: f = -2.648538593263, ‖∇f‖ = 6.8261e-02, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   15, time  667.16 s: f = -2.650130908354, ‖∇f‖ = 7.0878e-02, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   16, time  675.47 s: f = -2.651987522211, ‖∇f‖ = 8.2170e-02, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   17, time  682.87 s: f = -2.653758642111, ‖∇f‖ = 1.0420e-01, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   18, time  691.17 s: f = -2.655421985606, ‖∇f‖ = 1.3031e-01, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   19, time  699.68 s: f = -2.657803102660, ‖∇f‖ = 9.4755e-02, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   20, time  708.34 s: f = -2.659668183898, ‖∇f‖ = 7.3133e-02, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   21, time  716.68 s: f = -2.660316016122, ‖∇f‖ = 4.9501e-02, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   22, time  724.73 s: f = -2.661149682031, ‖∇f‖ = 6.8936e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, time  732.96 s: f = -2.662868297230, ‖∇f‖ = 1.1740e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, time  741.23 s: f = -2.664663245986, ‖∇f‖ = 1.3179e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, time  757.59 s: f = -2.665627671142, ‖∇f‖ = 1.0486e-01, α = 4.29e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   26, time  765.97 s: f = -2.666450510119, ‖∇f‖ = 4.5156e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, time  774.07 s: f = -2.666835911121, ‖∇f‖ = 4.8567e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, time  782.21 s: f = -2.667478452332, ‖∇f‖ = 7.2290e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, time  790.47 s: f = -2.668521250487, ‖∇f‖ = 8.5697e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, time  807.83 s: f = -2.669003677417, ‖∇f‖ = 9.9343e-02, α = 4.16e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   31, time  816.07 s: f = -2.669690963961, ‖∇f‖ = 4.0493e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, time  824.28 s: f = -2.669998638777, ‖∇f‖ = 3.1202e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, time  831.93 s: f = -2.670307400955, ‖∇f‖ = 4.9386e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, time  840.36 s: f = -2.670842812036, ‖∇f‖ = 6.0221e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, time  857.54 s: f = -2.671142652515, ‖∇f‖ = 7.1490e-02, α = 5.55e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   36, time  866.09 s: f = -2.671543536411, ‖∇f‖ = 3.6309e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, time  875.07 s: f = -2.671766796068, ‖∇f‖ = 2.8048e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, time  883.35 s: f = -2.671899292949, ‖∇f‖ = 3.5366e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, time  891.73 s: f = -2.672194986508, ‖∇f‖ = 4.5375e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, time  900.39 s: f = -2.672493817829, ‖∇f‖ = 5.5658e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, time  908.89 s: f = -2.672753505736, ‖∇f‖ = 2.0687e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, time  922.83 s: f = -2.672850238780, ‖∇f‖ = 2.0479e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, time  931.21 s: f = -2.672980643257, ‖∇f‖ = 2.3947e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, time  939.63 s: f = -2.673286900540, ‖∇f‖ = 3.0422e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, time  956.20 s: f = -2.673398343775, ‖∇f‖ = 3.5067e-02, α = 3.21e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   46, time  964.48 s: f = -2.673579922383, ‖∇f‖ = 2.0123e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, time  972.18 s: f = -2.673698834773, ‖∇f‖ = 1.8405e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, time  979.81 s: f = -2.673818459445, ‖∇f‖ = 2.4347e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, time  987.48 s: f = -2.673933525165, ‖∇f‖ = 1.8911e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, time  995.50 s: f = -2.674089997515, ‖∇f‖ = 2.3738e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   51, time 1010.77 s: f = -2.674158043027, ‖∇f‖ = 2.8417e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, time 1018.66 s: f = -2.674219511522, ‖∇f‖ = 1.3645e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, time 1032.56 s: f = -2.674261951986, ‖∇f‖ = 1.2275e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, time 1040.39 s: f = -2.674326093056, ‖∇f‖ = 1.7139e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, time 1048.26 s: f = -2.674419581548, ‖∇f‖ = 2.5006e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   56, time 1056.18 s: f = -2.674486565423, ‖∇f‖ = 2.2734e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, time 1064.48 s: f = -2.674541533348, ‖∇f‖ = 1.1543e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, time 1072.30 s: f = -2.674588014769, ‖∇f‖ = 1.2125e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, time 1086.30 s: f = -2.674627004117, ‖∇f‖ = 1.5452e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, time 1094.42 s: f = -2.674692190363, ‖∇f‖ = 2.3761e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, time 1108.21 s: f = -2.674747139489, ‖∇f‖ = 1.3175e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   62, time 1116.11 s: f = -2.674775151717, ‖∇f‖ = 1.0912e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, time 1130.04 s: f = -2.674811464235, ‖∇f‖ = 1.2577e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, time 1138.01 s: f = -2.674856898301, ‖∇f‖ = 1.9201e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   65, time 1146.50 s: f = -2.674909465713, ‖∇f‖ = 1.8198e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, time 1154.50 s: f = -2.674952274100, ‖∇f‖ = 1.0659e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, time 1162.87 s: f = -2.674984765700, ‖∇f‖ = 9.6416e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, time 1170.77 s: f = -2.675005125019, ‖∇f‖ = 1.2764e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, time 1179.63 s: f = -2.675038973771, ‖∇f‖ = 1.6162e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, time 1194.16 s: f = -2.675081913358, ‖∇f‖ = 1.6581e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, time 1223.54 s: f = -2.675119056919, ‖∇f‖ = 1.9355e-02, α = 5.42e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   72, time 1237.63 s: f = -2.675164711729, ‖∇f‖ = 8.9296e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, time 1252.02 s: f = -2.675185025614, ‖∇f‖ = 9.8394e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, time 1266.62 s: f = -2.675208703900, ‖∇f‖ = 8.9414e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, time 1281.08 s: f = -2.675245782533, ‖∇f‖ = 1.2526e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, time 1295.89 s: f = -2.675262164632, ‖∇f‖ = 1.7156e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, time 1310.31 s: f = -2.675283818451, ‖∇f‖ = 7.9273e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, time 1324.56 s: f = -2.675298865471, ‖∇f‖ = 6.1320e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, time 1339.42 s: f = -2.675312616160, ‖∇f‖ = 6.9124e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   80, time 1354.70 s: f = -2.675331281367, ‖∇f‖ = 1.0125e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   81, time 1369.67 s: f = -2.675340850961, ‖∇f‖ = 1.7155e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   82, time 1384.07 s: f = -2.675364134565, ‖∇f‖ = 6.2780e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   83, time 1398.77 s: f = -2.675373081794, ‖∇f‖ = 5.3437e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   84, time 1412.79 s: f = -2.675385605957, ‖∇f‖ = 7.6234e-03, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 85 iterations and time 1427.99 s: f = -2.675398713824, ‖∇f‖ = 1.1289e-02\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/lbfgs.jl:197\nE / prod(size(lattice)) = -0.66884967845596\n","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Note that for the specified parameters J = Delta = 1, we simulated the same Hamiltonian as in the Heisenberg example. In that example, with a non-symmetric D=2 PEPS simulation, we reached a ground-state energy per site of around E_textD=2 = -06625dots. Again comparing against Sandvik's accurate QMC estimate E_textref=06694421, we see that we already got closer to the reference energy.","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"","category":"page"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/lib/#PEPSKit.ALSTruncation","page":"Library","title":"PEPSKit.ALSTruncation","text":"struct ALSTruncation\n\nAlgorithm struct for the alternating least square (ALS) optimization of a bond. \n\nFields\n\ntrscheme::TensorKit.TruncationScheme\nmaxiter::Int64\ntol::Float64\ncheck_interval::Int64\n\nConstructors\n\nALSTruncation(; kwargs...)\n\nThe truncation algorithm can be constructed from the following keyword arguments:\n\ntrscheme::TruncationScheme: SVD truncation scheme when initilizing the truncated tensors connected by the bond.\nmaxiter::Int=50 : Maximal number of ALS iterations.\ntol::Float64=1e-15 : ALS converges when fidelity change between two FET iterations is smaller than tol.\ncheck_interval::Int=0 : Set number of iterations to print information. Output is suppressed when check_interval <= 0. \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGAlgorithm","page":"Library","title":"PEPSKit.CTMRGAlgorithm","text":"abstract type CTMRGAlgorithm\n\nAbstract super type for the corner transfer matrix renormalization group (CTMRG) algorithm for contracting infinite PEPS.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGAlgorithm-Tuple{}","page":"Library","title":"PEPSKit.CTMRGAlgorithm","text":"CTMRGAlgorithm(; kwargs...)\n\nKeyword argument parser returning the appropriate CTMRGAlgorithm algorithm struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv","page":"Library","title":"PEPSKit.CTMRGEnv","text":"struct CTMRGEnv{C, T}\n\nCorner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.\n\nGiven arrays of corners c and edges t, they connect to the network tensors P at site (r, c) in the unit cell as:\n\n   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]\n   |              |             |\n   t[4,r,c-1]-----P[r,c]--------t[2,r,c+1]\n   |              |             |\n   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]\n\nHere P represents an effective local constituent tensor. This can either be a single rank-4 tensor, a pair of PEPS tensors, or a stack of PEPS-PEPO-PEPS tensors depending on the network being contracted.\n\nFields\n\ncorners::Array{C, 3} where C: 4 x rows x cols array of corner tensors, where the first dimension specifies the spatial direction\nedges::Array{T, 3} where T: 4 x rows x cols array of edge tensors, where the first dimension specifies the spatial direction\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Tuple{Any, Any, InfiniteSquareNetwork, Vararg{Any}}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], network::InfiniteSquareNetwork, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:Union{AbstractMatrix{<:ElementarySpace}, ElementarySpace}}\n\nConstruct a CTMRG environment by specifying a corresponding InfiniteSquareNetwork, and the north, east, south and west virtual spaces of the environment. The virtual spaces can either be specified as matrices of ElementarySpaces, or as individual ElementarySpaces which are then filled to match the size of the unit cell. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{B}, Tuple{A}, Tuple{Any, Any, A, A, B}, Tuple{Any, Any, A, A, B, B}, Tuple{Any, Any, A, A, B, B, B}, Tuple{Any, Any, A, A, Vararg{B, 4}}} where {A<:(AbstractMatrix{<:TensorKit.ProductSpace}), B<:(AbstractMatrix{<:TensorKit.ElementarySpace})}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], Ds_north::A, Ds_east::A, chis_north::B, [chis_east::B], [chis_south::B], [chis_west::B]\n) where {A<:AbstractMatrix{<:VectorSpace}, B<:AbstractMatrix{<:ElementarySpace}}\n\nConstruct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding partition function and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\nEach entry of the Ds_north and Ds_east matrices corresponds to an effective local space of the partition function, and can be represented as an ElementarySpace (e.g. for the case of a partition function defined in terms of local rank-4 tensors) or a ProductSpace (e.g. for the case of a network representing overlaps of PEPSs and PEPOs).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{Any, Any, S, S, Vararg{Any}}} where S<:TensorKit.VectorSpace","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], D_north::P, D_east::P, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S];\n    unitcell::Tuple{Int,Int}=(1, 1),\n) where {P<:VectorSpace,S<:ElementarySpace}\n\nConstruct a CTMRG environment by specifying the north and east virtual spaces of the corresponding InfiniteSquareNetwork and the north, east, south and west virtual spaces of the environment. The network unit cell can be specified by the unitcell keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.EigSolver","page":"Library","title":"PEPSKit.EigSolver","text":"struct EigSolver{F} <: PEPSKit.GradMode{F}\n\nGradient mode wrapper around KrylovKit.KrylovAlgorithm for solving the gradient linear problem as an eigenvalue problem.\n\nFields\n\nsolver_alg::KrylovKit.KrylovAlgorithm\n\nConstructors\n\nEigSolver(; kwargs...)\n\nConstruct the EigSolver algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance of the eigen solver.\nmaxiter::Int=30 : Maximal number of solver iterations.\nverbosity::Int=-1 : Output information verbosity of the linear solver.\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\nsolver_alg::Union{KrylovKit.KrylovAlgorithm,NamedTuple}=(; alg=:arnoldi : Eigen solver algorithm which, if supplied directly as a KrylovKit.KrylovAlgorithm overrides the above specified tol, maxiter and verbosity. Alternatively, it can be supplied via a NamedTuple where alg can be one of the following:\n:arnoldi : Arnoldi Krylov algorithm, see KrylovKit.Arnoldi for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.EnlargedCorner","page":"Library","title":"PEPSKit.EnlargedCorner","text":"struct EnlargedCorner{TC, TE, TA}\n\nEnlarged CTMRG corner tensor storage.\n\nConstructors\n\nEnlargedCorner(network::InfiniteSquareNetwork, env, coordinates)\n\nConstruct an enlarged corner with the correct row and column indices based on the given coordinates which are of the form (dir, row, col).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedSVD","page":"Library","title":"PEPSKit.FixedSVD","text":"struct FixedSVD{Ut, St, Vt, Utf, Stf, Vtf}\n\nSVD struct containing a pre-computed decomposition or even multiple ones. Additionally, it can contain the untruncated full decomposition as well. The call to tsvd just returns the pre-computed U, S and V. In the reverse pass, the SVD adjoint is computed with these exact U, S, and V and, potentially, the full decompositions if the adjoints needs access to them.\n\nFields\n\nU::Any\nS::Any\nV::Any\nU_full::Any\nS_full::Any\nV_full::Any\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedSpaceTruncation","page":"Library","title":"PEPSKit.FixedSpaceTruncation","text":"struct FixedSpaceTruncation <: TensorKit.TruncationScheme\n\nCTMRG specific truncation scheme for tsvd which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from TruncationSpace.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullEnvTruncation","page":"Library","title":"PEPSKit.FullEnvTruncation","text":"struct FullEnvTruncation\n\nAlgorithm struct for the full environment truncation (FET).\n\nFields\n\ntrscheme::TensorKit.TruncationScheme\nmaxiter::Int64\ntol::Float64\ntrunc_init::Bool\ncheck_interval::Int64\n\nConstructors\n\nFullEnvTruncation(; kwargs...)\n\nThe truncation algorithm can be constructed from the following keyword arguments:\n\ntrscheme::TruncationScheme : SVD truncation scheme when optimizing the new bond matrix.\nmaxiter::Int=50 : Maximal number of FET iterations.\ntol::Float64=1e-15 : FET converges when fidelity change between two FET iterations is smaller than tol.\ntrunc_init::Bool=true : Controls whether the initialization of the new bond matrix is obtained from truncated SVD of the old bond matrix. \ncheck_interval::Int=0 : Set number of iterations to print information. Output is suppressed when check_interval <= 0. \n\nReferences\n\nGlen Evenbly, Phys. Rev. B 98, 085155 (2018). \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullInfiniteEnv","page":"Library","title":"PEPSKit.FullInfiniteEnv","text":"struct FullInfiniteEnv{TC, TE, TA}\n\nFull-infinite CTMRG environment tensor storage.\n\nFields\n\nC_1\nC_2\nC_3\nC_4\nE_1\nE_2\nE_3\nE_4\nE_5\nE_6\nE_7\nE_8\nA_1\nA_2\nA_3\nA_4\n\nConstructors\n\nFullInfiniteEnv(\n    quadrant1::E, quadrant2::E, quadrant3::E, quadrant4::E\n) where {E<:EnlargedCorner}\n\nConstruct sparse full-infinite environment based on four sparse enlarged corners (quadrants).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullInfiniteEnv-Tuple{Any, Val{false}}","page":"Library","title":"PEPSKit.FullInfiniteEnv","text":"(env::FullInfiniteEnv)(x, ::Val{false}) \n(env::FullInfiniteEnv)(x, ::Val{true})\n\nContract full-infinite environment with a vector x, such that the environment acts as a linear map or adjoint linear map on x if Val(true) or Val(false) is passed, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.FullInfiniteProjector","page":"Library","title":"PEPSKit.FullInfiniteProjector","text":"struct FullInfiniteProjector{S<:SVDAdjoint, T} <: PEPSKit.ProjectorAlgorithm\n\nProjector algorithm implementing projectors from SVDing the full 4x4 CTMRG environment.\n\nFields\n\nsvd_alg::SVDAdjoint\ntrscheme::Any\nverbosity::Int64\n\nConstructors\n\nFullInfiniteProjector(; kwargs...)\n\nConstruct the full-infinite projector algorithm based on the following keyword arguments:\n\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}=SVDAdjoint() : SVD algorithm including the reverse rule. See SVDAdjoint.\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nverbosity::Int=0 : Projector output verbosity which can be:\nSuppress output information\nPrint singular value degeneracy warnings\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullSVDReverseRule","page":"Library","title":"PEPSKit.FullSVDReverseRule","text":"struct FullSVDReverseRule\n\nSVD reverse-rule algorithm which uses a modified version of TensorKit's tsvd! reverse-rule allowing for Lorentzian broadening and output verbosity control.\n\nFields\n\nbroadening::Float64\nverbosity::Int64\n\nConstructors\n\nFullSVDReverseRule(; kwargs...)\n\nConstruct a FullSVDReverseRule algorithm struct from the following keyword arguments:\n\nbroadening::Float64=1.0e-13 : Lorentzian broadening amplitude for smoothing divergent term in SVD derivative in case of (pseudo) degenerate singular values.\nverbosity::Int=0 : Suppresses all output if ≤0, prints gauge dependency warnings if 1, and always prints gauge dependency if ≥2.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GeomSum","page":"Library","title":"PEPSKit.GeomSum","text":"struct GeomSum{F} <: PEPSKit.GradMode{F}\n\nGradient mode for CTMRG using explicit evaluation of the geometric sum.\n\nFields\n\ntol::Real\nmaxiter::Int64\nverbosity::Int64\n\nConstructors\n\nGeomSum(; kwargs...)\n\nConstruct the GeomSum algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance for the difference of norms of two consecutive summands in the geometric sum.\nmaxiter::Int=30 : Maximal number of gradient iterations.\nverbosity::Int=-1 : Output information verbosity that can be one of the following:\nSuppress output information\nPrint convergence warnings\nInformation at each gradient iteration\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GradMode-Tuple{}","page":"Library","title":"PEPSKit.GradMode","text":"GradMode(; kwargs...)\n\nKeyword argument parser returning the appropriate GradMode algorithm struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"struct HalfInfiniteEnv{TC, TE, TA}\n\nHalf-infinite CTMRG environment tensor storage.\n\nFields\n\nC_1\nC_2\nE_1\nE_2\nE_3\nE_4\nA_1\nA_2\n\nConstructors\n\nHalfInfiniteEnv(quadrant1::EnlargedCorner, quadrant2::EnlargedCorner)\n\nConstruct sparse half-infinite environment based on two sparse enlarged corners (quadrants).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv-Tuple{Any, Val{false}}","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"(env::HalfInfiniteEnv)(x, ::Val{false}) \n(env::HalfInfiniteEnv)(x, ::Val{true})\n\nContract half-infinite environment with a vector x, such that the environment acts as a linear map or adjoint linear map on x if Val(true) or Val(false) is passed, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.HalfInfiniteProjector","page":"Library","title":"PEPSKit.HalfInfiniteProjector","text":"struct HalfInfiniteProjector{S<:SVDAdjoint, T} <: PEPSKit.ProjectorAlgorithm\n\nProjector algorithm implementing projectors from SVDing the half-infinite CTMRG environment.\n\nFields\n\nsvd_alg::SVDAdjoint\ntrscheme::Any\nverbosity::Int64\n\nConstructors\n\nHalfInfiniteProjector(; kwargs...)\n\nConstruct the half-infinite projector algorithm based on the following keyword arguments:\n\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}=SVDAdjoint() : SVD algorithm including the reverse rule. See SVDAdjoint.\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nverbosity::Int=0 : Projector output verbosity which can be:\nSuppress output information\nPrint singular value degeneracy warnings\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO","page":"Library","title":"PEPSKit.InfinitePEPO","text":"struct InfinitePEPO{T<:PEPOTensor}\n\nRepresents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.\n\nFields\n\nA::Array{T, 3} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::PEPOTensor; unitcell=(1, 1, 1))\n\nCreate an InfinitePEPO by specifying a tensor which is repeated across the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::AbstractArray{T, 3})\n\nAllow users to pass in an array of tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A<:(AbstractArray{<:TensorKit.ElementarySpace, 3})","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO([f=randn, T=ComplexF64,] Pspaces, Nspaces, Espaces)\n\nAllow users to pass in arrays of spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO([f=randn, T=ComplexF64,] Pspace::S, Nspace::S, [Espace::S]; unitcell=(1,1,1)) where {S<:ElementarySpace}\n\nCreate an InfinitePEPO by specifying its spaces and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS","page":"Library","title":"PEPSKit.InfinitePEPS","text":"struct InfinitePEPS{T<:PEPSTensor}\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice.\n\nFields\n\nA::Matrix{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{AbstractMatrix{<:TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::AbstractMatrix{T})\n\nCreate an InfinitePEPS by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::PEPSTensor; unitcell=(1, 1))\n\nCreate an InfinitePEPS by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            ||         ||\n---T[r,c-1]=====AA[r,c]====AA[r,c+1]====\n   |            ||         ||\n---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==\n   |            ||         ||\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{M}, Tuple{Any, Type{<:Number}, M, M}, Tuple{Any, Type{<:Number}, M, M, M}} where M<:(AbstractMatrix{<:TensorKit.ElementarySpace})","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS([f=randn, T=ComplexF64,] Pspaces::A, Nspaces::A, [Espaces::A]) where {A<:AbstractMatrix{ElementarySpace}}\n\nCreate an InfinitePEPS by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{Any, Type{<:Number}, S, Vararg{Any}}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS([f=randn, T=ComplexF64,] Pspace, Nspace, [Espace]; unitcell=(1,1))\n\nCreate an InfinitePEPS by specifying its physical, north and east spaces and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"struct InfinitePartitionFunction{T<:PartitionFunctionTensor}\n\nRepresents an infinite partition function on a 2D square lattice.\n\nFields\n\nA::Matrix{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(A; unitcell=(1, 1))\n\nCreate an InfinitePartitionFunction by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if partition function tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            |          |\n---T[r,c-1]-----AA[r,c]----AA[r,c+1]----\n   |            |          |\n---T[r+1,c-1]---AA[r+1,c]--AA[r+1,c+1]--\n   |            |          |\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(A::AbstractMatrix{T})\n\nCreate an InfinitePartitionFunction by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{M}, Tuple{Any, Any, M}, Tuple{Any, Any, M, M}} where M<:(AbstractMatrix{<:TensorKit.ElementarySpace})","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(\n    [f=randn, T=ComplexF64,] Pspaces::A, Nspaces::A, [Espaces::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfinitePartitionFunction by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{S}, Tuple{Any, Any, S}, Tuple{Any, Any, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(\n    [f=randn, T=ComplexF64,] Pspace::S, Nspace::S, [Espace::S]; unitcell=(1,1)\n) where {S<:ElementarySpace}\n\nCreate an InfinitePartitionFunction by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via Int or via ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteSquare","page":"Library","title":"PEPSKit.InfiniteSquare","text":"struct InfiniteSquare <: MPSKitModels.AbstractLattice{2}\n\nInfinite square lattice with a unit cell of size (Nrows, Ncols).\n\nFields\n\nNrows::Int64\nNcols::Int64\n\nConstructor\n\nInfiniteSquare([Nrows=1, Ncols=1])\n\nBy default, an infinite square with a (1, 1)-unitcell is constructed.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteSquareNetwork","page":"Library","title":"PEPSKit.InfiniteSquareNetwork","text":"struct InfiniteSquareNetwork{O}\n\nContractible square network. Wraps a matrix of 'rank-4-tensor-like' objects.\n\nFields\n\nA::Matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO{H,T,O}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS{T}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS(T::InfinitePEPS, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.IterSVD","page":"Library","title":"PEPSKit.IterSVD","text":"struct IterSVD\n\nIterative SVD solver based on KrylovKit's GKL algorithm, adapted to (symmetric) tensors. The number of targeted singular values is set via the TruncationSpace in ProjectorAlg. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn't converge, the algorithm falls back to a dense SVD.\n\nFields\n\nalg::KrylovKit.GKL\nfallback_threshold::Float64\nstart_vector::Any\n\nConstructors\n\nIterSVD(; kwargs...)\n\nConstruct an IterSVD algorithm struct based on the following keyword arguments:\n\nalg::KrylovKit.GKL=KrylovKit.GKL(; tol=1e-14, krylovdim=25) : GKL algorithm struct for block-wise iterative SVD.\nfallback_threshold::Float64=Inf : Threshold for howmany / minimum(size(block)) above which (if the block is too small) the algorithm falls back to TensorKit's dense SVD.\nstart_vector=random_start_vector : Function providing the initial vector for the iterative SVD algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LinSolver","page":"Library","title":"PEPSKit.LinSolver","text":"struct LinSolver{F} <: PEPSKit.GradMode{F}\n\nGradient mode wrapper around KrylovKit.LinearSolver for solving the gradient linear problem using iterative solvers.\n\nFields\n\nsolver_alg::KrylovKit.LinearSolver\n\nConstructors\n\nLinSolver(; kwargs...)\n\nConstruct the LinSolver algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance of the linear solver.\nmaxiter::Int=30 : Maximal number of solver iterations.\nverbosity::Int=-1 : Output information verbosity of the linear solver.\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\nsolver_alg::Union{KrylovKit.LinearSolver,NamedTuple}=(; alg::Symbol=:bicgstab : Linear solver algorithm which, if supplied directly as a KrylovKit.LinearSolver overrides the above specified tol, maxiter and verbosity. Alternatively, it can be supplied via a NamedTuple where alg can be one of the following:\n:gmres : GMRES iterative linear solver, see KrylovKit.GMRES for details\n:bicgstab : BiCGStab iterative linear solver, see KrylovKit.BiCGStab for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LocalOperator","page":"Library","title":"PEPSKit.LocalOperator","text":"struct LocalOperator{T<:Tuple, S}\n\nA sum of local operators acting on a lattice. The lattice is stored as a matrix of vector spaces, and the terms are stored as a tuple of pairs of indices and operators.\n\nFields\n\nlattice::Matrix{S}: The lattice on which the operator acts.\nterms::T: The terms of the operator, stored as a tuple of pairs of indices and operators.\n\nConstructors\n\nLocalOperator(lattice::Matrix{S}, terms::Pair...)\nLocalOperator{T,S}(lattice::Matrix{S}, terms::T) where {T,S}\n\nExamples\n\nlattice = fill(ℂ^2, 1, 1) # single-site unitcell\nO1 = LocalOperator(lattice, ((1, 1),) => σx, ((1, 1), (1, 2)) => σx ⊗ σx, ((1, 1), (2, 1)) => σx ⊗ σx)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ManualIter","page":"Library","title":"PEPSKit.ManualIter","text":"struct ManualIter{F} <: PEPSKit.GradMode{F}\n\nGradient mode for CTMRG using manual iteration to solve the linear problem.\n\nFields\n\ntol::Real\nmaxiter::Int64\nverbosity::Int64\n\nConstructors\n\nManualIter(; kwargs...)\n\nConstruct the ManualIter algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance for the norm difference of two consecutive dx contributions.\nmaxiter::Int=30 : Maximal number of gradient iterations.\nverbosity::Int=-1 : Output information verbosity that can be one of the following:\nSuppress output information\nPrint convergence warnings\nInformation at each gradient iteration\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPO","page":"Library","title":"PEPSKit.MultilineTransferPEPO","text":"const MultilineTransferPEPO = MPSKit.Multiline{<:InfiniteTransferPEPO}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any}","page":"Library","title":"PEPSKit.MultilineTransferPEPO","text":"MultilineTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPS","page":"Library","title":"PEPSKit.MultilineTransferPEPS","text":"const MultilineTransferPEPS = MPSKit.Multiline{<:InfiniteTransferPEPS}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPS-Tuple{InfinitePEPS, Any}","page":"Library","title":"PEPSKit.MultilineTransferPEPS","text":"MultilineTransferPEPS(T::InfinitePEPS, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.PEPOTensor","page":"Library","title":"PEPSKit.PEPOTensor","text":"const PEPOTensor{S}\n\nDefault type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: T  P  P  N  E  S  W. Here, P and P denote the incoming and outgoing physical space respectively, encoding the physical mapping from P to P where P corresponds to a physical PEPS index. N, E, S and W denote the physics, north, east, south and west spaces, respectively.\n\n        P´ N\n        | ╱\n        |╱\n   W---- ----E\n       ╱|\n      ╱ |\n     S  P\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSOptimize","page":"Library","title":"PEPSKit.PEPSOptimize","text":"struct PEPSOptimize{G}\n\nAlgorithm struct for PEPS ground-state optimization using AD. See fixedpoint for details.\n\nFields\n\nboundary_alg::PEPSKit.CTMRGAlgorithm\ngradient_alg::Any\noptimizer_alg::OptimKit.OptimizationAlgorithm\nreuse_env::Bool\nsymmetrization::Union{Nothing, PEPSKit.SymmetrizationStyle}\n\nConstructors\n\nPEPSOptimize(; kwargs...)\n\nConstruct a PEPS optimization algorithm struct based on keyword arguments. For a full description, see fixedpoint. The supported keywords are:\n\nboundary_alg::Union{NamedTuple,<:CTMRGAlgorithm}\ngradient_alg::Union{NamedTuple,Nothing,<:GradMode}\noptimizer_alg::Union{NamedTuple,<:OptimKit.OptimizationAlgorithm}\nreuse_env::Bool=true\nsymmetrization::Union{Nothing,SymmetrizationStyle}=nothing\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor","page":"Library","title":"PEPSKit.PEPSTensor","text":"const PEPSTensor{S}\n\nDefault type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: T  P  N  E  S  W. Here, P denotes the physical space and N, E, S and W denote the north, east, south and west virtual spaces, respectively.\n\n           N\n          ╱\n         ╱\n   W---- ----E\n       ╱|\n      ╱ |\n     S  P\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.PEPSTensor","text":"PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,\n           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S<:Union{Int,ElementarySpace}}\n\nConstruct a PEPS tensor based on the physical, north, east, west and south spaces. Alternatively, only the space dimensions can be provided and ℂ is assumed as the field. The tensor elements are generated based on f and the element type is specified in T.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.PEPSWeight","page":"Library","title":"PEPSKit.PEPSWeight","text":"const PEPSWeight\n\nDefault type for PEPS bond weights with 2 virtual indices.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PartitionFunctionTensor","page":"Library","title":"PEPSKit.PartitionFunctionTensor","text":"const PartitionFunctionTensor{S}\n\nDefault type for partition function tensors with 4 virtual indices, conventionally ordered as: T  W  S  N  E. Here, N, E, S and W denote the north, east, south and west spaces, respectively.\n\n          N\n         ╱\n        ╱\n  W---- ----E\n      ╱\n     ╱\n    S \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ProjectorAlgorithm","page":"Library","title":"PEPSKit.ProjectorAlgorithm","text":"abstract type ProjectorAlgorithm\n\nAbstract super type for all CTMRG projector algorithms.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ProjectorAlgorithm-Tuple{}","page":"Library","title":"PEPSKit.ProjectorAlgorithm","text":"ProjectorAlgorithm(; kwargs...)\n\nKeyword argument parser returning the appropriate ProjectorAlgorithm algorithm struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ReflectDepth","page":"Library","title":"PEPSKit.ReflectDepth","text":"struct ReflectDepth <: PEPSKit.SymmetrizationStyle\n\nReflection symmmetrization along the horizontal axis, such that north and south are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectWidth","page":"Library","title":"PEPSKit.ReflectWidth","text":"struct ReflectWidth <: PEPSKit.SymmetrizationStyle\n\nReflection symmmetrization along the vertical axis, such that east and west are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.Rotate","page":"Library","title":"PEPSKit.Rotate","text":"struct Rotate <: PEPSKit.SymmetrizationStyle\n\nRotation symmmetrization leaving the object invariant under π/2 rotations.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.RotateReflect","page":"Library","title":"PEPSKit.RotateReflect","text":"struct RotateReflect <: PEPSKit.SymmetrizationStyle\n\nFull reflection and rotation symmmetrization, such that reflection along the horizontal and vertical axis as well as π/2 rotations leave the object invariant.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SUWeight","page":"Library","title":"PEPSKit.SUWeight","text":"struct SUWeight{E<:PEPSWeight}\n\nSchmidt bond weights used in simple/cluster update.  Weight elements are always real and non-negative. The domain and codomain of each weight matrix must be an un-dualed ElementarySpace.\n\nFor a square lattice InfinitePEPS, the weights are placed as\n\n        |\n    -T[r-1,c]-\n        |\n    wt[2,r,c]\n        |                   |\n    --T[r,c]--wt[1,r,c]--T[r,c+1]--\n        |                   |\n\nAxis order of each weight matrix is\n\n    x-weights:\n        1 ← x ← 2   or   2 → x → 1\n    \n    y-weights:\n        2           1\n        ↓           ↑  \n        y    or     y\n        ↓           ↑\n        1           2\n\nFields\n\ndata::Array{E, 3} where E<:(TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S})\n\nConstructors\n\nSUWeight(wts_mats::AbstractMatrix{E}...) where {E<:PEPSWeight}\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SUWeight-Tuple{InfinitePEPO}","page":"Library","title":"PEPSKit.SUWeight","text":"SUWeight(pepo::InfinitePEPO)\n\nCreate an SUWeight for a given one-layer InfinitePEPO. The weights are initialized as identity matrices of element type Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.SUWeight-Tuple{InfinitePEPS}","page":"Library","title":"PEPSKit.SUWeight","text":"SUWeight(peps::InfinitePEPS)\n\nCreate an SUWeight for a given InfinitePEPS.  The weights are initialized as identity matrices of element type Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.SUWeight-Union{Tuple{M}, Tuple{M, M}} where M<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.SUWeight","text":"SUWeight(Nspaces::M, [Espaces::M]) where {M<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an SUWeight by specifying the vertical (north) or horizontal (east) virtual bond spaces. Each individual space can be specified as either an Int or an ElementarySpace. The weights are initialized as identity matrices of element type Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.SUWeight-Union{Tuple{S}, Tuple{S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.SUWeight","text":"SUWeight(Nspace::S, Espace::S=Nspace; unitcell::Tuple{Int,Int}=(1, 1)) where {S<:ElementarySpace}\n\nCreate an SUWeight by specifying its vertical (north) and horizontal (east)  as ElementarySpaces) and unit cell size. The weights are initialized as identity matrices of element type Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.SVDAdjoint","page":"Library","title":"PEPSKit.SVDAdjoint","text":"struct SVDAdjoint{F, R}\n\nWrapper for a SVD algorithm fwd_alg with a defined reverse rule rrule_alg. If isnothing(rrule_alg), Zygote differentiates the forward call automatically.\n\nFields\n\nfwd_alg::Any\nrrule_alg::Any\n\nConstructors\n\nSVDAdjoint(; kwargs...)\n\nConstruct a SVDAdjoint algorithm struct based on the following keyword arguments:\n\nfwd_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=sdd): SVD algorithm of the forward pass which can either be passed as an Algorithm instance or a NamedTuple where alg is one of the following:\n:sdd : TensorKit's wrapper for LAPACK's _gesdd\n:svd : TensorKit's wrapper for LAPACK's _gesvd\n:iterative : Iterative SVD only computing the specifed number of singular values and vectors, see IterSVD\nrrule_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=full): Reverse-rule algorithm for differentiating the SVD. Can be supplied by an Algorithm instance directly or as a NamedTuple where alg is one of the following:\n:full: Uses a modified version of TensorKit's reverse-rule for tsvd which doesn't solve any linear problem and instead requires access to the full SVD, see FullSVDReverseRule.\n:gmres: GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab: BiCGStab iterative linear solver, see the KrylovKit docs for details\n:arnoldi: Arnoldi Krylov algorithm, see the KrylovKit docs for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SequentialCTMRG","page":"Library","title":"PEPSKit.SequentialCTMRG","text":"struct SequentialCTMRG <: CTMRGAlgorithm\n\nCTMRG algorithm where the expansions and renormalization is performed sequentially column-wise. This is implemented as a growing and projecting step to the left, followed by a clockwise rotation (performed four times).\n\nFields\n\ntol::Float64\nmaxiter::Int64\nminiter::Int64\nverbosity::Int64\nprojector_alg::PEPSKit.ProjectorAlgorithm\n\nConstructors\n\nSequentialCTMRG(; kwargs...)\n\nConstruct a sequential CTMRG algorithm struct based on keyword arguments. For a full description, see leading_boundary. The supported keywords are:\n\ntol::Real=1.0e-8\nmaxiter::Int=100\nminiter::Int=4\nverbosity::Int=2\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace)\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}\nprojector_alg::Symbol=:halfinfinite\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimpleUpdate","page":"Library","title":"PEPSKit.SimpleUpdate","text":"struct SimpleUpdate\n\nAlgorithm struct for simple update (SU) of infinite PEPS with bond weights. Each SU run is converged when the singular value difference becomes smaller than tol.\n\nFields\n\ndt::Number\ntol::Float64\nmaxiter::Int64\ntrscheme::TensorKit.TruncationScheme\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimultaneousCTMRG","page":"Library","title":"PEPSKit.SimultaneousCTMRG","text":"struct SimultaneousCTMRG{P<:PEPSKit.ProjectorAlgorithm} <: PEPSKit.CTMRGAlgorithm\n\nCTMRG algorithm where all sides are grown and renormalized at the same time. In particular, the projectors are applied to the corners from two sides simultaneously.\n\nFields\n\ntol::Float64\nmaxiter::Int64\nminiter::Int64\nverbosity::Int64\nprojector_alg::PEPSKit.ProjectorAlgorithm\n\nConstructors\n\nSimultaneousCTMRG(; kwargs...)\n\nConstruct a simultaneous CTMRG algorithm struct based on keyword arguments. For a full description, see leading_boundary. The supported keywords are:\n\ntol::Real=1.0e-8\nmaxiter::Int=100\nminiter::Int=4\nverbosity::Int=2\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace)\nsvd_alg::Union{<:SVDAdjoint,NamedTuple}\nprojector_alg::Symbol=:halfinfinite\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.EnlargedCorner}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(Q::EnlargedCorner)\n\nInstantiate enlarged corner as a TensorMap.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.FullInfiniteEnv}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(env::FullInfiniteEnv)\n\nInstantiate full-infinite environment as TensorMap explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.HalfInfiniteEnv}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(env::HalfInfiniteEnv)\n\nInstantiate half-infinite environment as TensorMap explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#FiniteDifferences.to_vec-Tuple{InfinitePEPS}","page":"Library","title":"FiniteDifferences.to_vec","text":"to_vec(A::InfinitePEPS) -> vec, state_from_vec\n\nVectorize an InfinitePEPS into a vector of real numbers. A vectorized infinite PEPS can retrieved again as an InfinitePEPS by application of the state_from_vec map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.add_physical_charge-Tuple{LocalOperator, AbstractMatrix{<:TensorKitSectors.Sector}}","page":"Library","title":"MPSKit.add_physical_charge","text":"add_physical_charge(H::LocalOperator, charges::AbstractMatrix{<:Sector})\n\nChange the spaces of a LocalOperator by fusing in an auxiliary charge into the domain of the operator on every site, according to a given matrix of 'auxiliary' physical charges.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.correlation_length-Tuple{Any, CTMRGEnv}","page":"Library","title":"MPSKit.correlation_length","text":"correlation_length(state, env::CTMRGEnv; num_vals=2, kwargs...)\n\nCompute the correlation length associated to state as contracted using the environment env, based on the spectrum of the horizontal and vertical transfer matrices associated to env. Additionally the (normalized) eigenvalue spectrum is returned. The number of computed eigenvalues can be specified using num_vals, and any remaining keyword arguments are passed through to MPSKit.transfer_spectrum (e.g. allowing to target the correlation length in a specific symmetry sector).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{Any, Any}","page":"Library","title":"MPSKit.expectation_value","text":"MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})\nMPSKit.expectation_value(st::MultilineMPS, op::Union{MultilineTransferPEPS,MultilineTransferPEPO})\n\nCompute expectation value of the transfer operator op for the state st for each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Union{InfinitePEPO, InfinitePEPS}, CTMRGEnv}","page":"Library","title":"MPSKit.expectation_value","text":"expectation_value(state, O::LocalOperator, env::CTMRGEnv)\nexpectation_value(bra, O::LocalOperator, ket, env::CTMRGEnv)\n\nCompute the expectation value ⟨bra|O|ket⟩ / ⟨bra|ket⟩ of a LocalOperator O. This can be done either for a PEPS, or alternatively for a density matrix PEPO. In the latter case the first signature corresponds to a single layer PEPO contraction, while the second signature yields a bilayer contraction instead.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Union{Tuple{S}, Tuple{T}, Tuple{InfinitePartitionFunction, Pair{CartesianIndex{2}, <:TensorKit.AbstractTensorMap{T, S, 2, 2}}, CTMRGEnv}} where {T, S}","page":"Library","title":"MPSKit.expectation_value","text":"expectation_value(pf::InfinitePartitionFunction, inds => O, env::CTMRGEnv)\n\nCompute the expectation value corresponding to inserting a local tensor(s) O at position inds in the partition function pf and contracting the chole using a given CTMRG environment env.\n\nHere inds can be specified as either a Tuple{Int,Int} or a CartesianIndex{2}, and O should be a rank-4 tensor conforming to the PartitionFunctionTensor indexing convention.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, Any, Any}","page":"Library","title":"MPSKit.leading_boundary","text":"leading_boundary(\n    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [env]\n)\nleading_boundary(\n    st::MPSMulitline, op::Union{MultilineTransferPEPS,MultilineTransferPEPO}, alg, [env]\n)\n\nApproximate the leading boundary MPS eigenvector for the transfer operator op using st as initial guess.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{CTMRGEnv, InfiniteSquareNetwork}","page":"Library","title":"MPSKit.leading_boundary","text":"leading_boundary(env₀, network; kwargs...) -> env, info\n# expert version:\nleading_boundary(env₀, network, alg::CTMRGAlgorithm)\n\nContract network using CTMRG and return the CTM environment. The algorithm can be supplied via the keyword arguments or directly as an CTMRGAlgorithm struct.\n\nKeyword arguments\n\nCTMRG iterations\n\ntol::Real=1.0e-8 : Stopping criterium for the CTMRG iterations. This is the norm convergence, as well as the distance in singular values of the corners and edges.\nminiter::Int=4 : Minimal number of CTMRG iterations.\nmaxiter::Int=100 : Maximal number of CTMRG iterations.\nverbosity::Int=2 : Output verbosity level, should be one of the following:\nSuppress all output\nOnly print warnings\nInitialization and convergence info\nIteration info\nDebug info\nalg::Symbol=:simultaneous : Variant of the CTMRG algorithm. See also CTMRGAlgorithm.\n:simultaneous: Simultaneous expansion and renormalization of all sides.\n:sequential: Sequential application of left moves and rotations.\n\nProjector algorithm\n\ntrscheme::Union{TruncationScheme,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nsvd_alg::Union{<:SVDAdjoint,NamedTuple} : SVD algorithm for computing projectors. See also SVDAdjoint. By default, a reverse-rule tolerance of tol=1e1tol where the krylovdim is adapted to the env₀ environment dimension.\nprojector_alg::Symbol=:halfinfinite : Variant of the projector algorithm. See also ProjectorAlgorithm.\n:halfinfinite : Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.\n:fullinfinite : Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.\n\nReturn values\n\nThe CTMRG routine returns the final CTMRG environment as well as an information NamedTuple containing the following fields:\n\ntruncation_error : Last (maximal) SVD truncation error of the CTMRG projectors.\ncondition_number : Last (maximal) condition number of the enlarged CTMRG environment.\nconvergence_error : Convergence error of the CTMRG algorithm at termination.\n\nIn case the alg is a SimultaneousCTMRG, the last SVD will also be returned:\n\nU : Last unit cell of left singular vectors.\nS : Last unit cell of singular values.\nV : Last unit cell of right singular vectors.\n\nIf, in addition, the specified SVD algorithm computes the full, untruncated SVD, the full set of vectors and values will be returned as well:\n\nU_full : Last unit cell of all left singular vectors.\nS_full : Last unit cell of all singular values.\nV_full : Last unit cell of all right singular vectors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.physicalspace-Tuple{LocalOperator}","page":"Library","title":"MPSKit.physicalspace","text":"physicalspace(O::LocalOperator)\n\nReturn lattice of physical spaces on which the LocalOperator is defined.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._apply_gate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.TruncationScheme}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._apply_gate","text":"_apply_gate(a, b, gate, trscheme)\n\n\nApply 2-site gate on the reduced matrices a, b\n\n    -1← a --- 3 --- b ← -4          -2         -3\n        ↓           ↓               ↓           ↓\n        1           2               |----gate---|\n        ↓           ↓       or      ↓           ↓\n        |----gate---|               1           2\n        ↓           ↓               ↓           ↓\n        -2         -3           -1← a --- 3 --- b ← -4\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._apply_gatempo!-Union{Tuple{T2}, Tuple{T1}, Tuple{Vector{T1}, Vector{T2}}} where {T1<:(TensorKit.AbstractTensorMap{T, var\"#s15\", 4, 1} where {var\"#s15\"<:TensorKit.ElementarySpace, T}), T2<:TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit._apply_gatempo!","text":"Apply the gate MPO gs on the cluster Ms. When gate_ax is 1 or 2, the gate acts from the physical codomain or domain side.\n\ne.g. Cluster in PEPS with gate_ax = 1:\n\n         ╱       ╱       ╱\n    --- M1 ---- M2 ---- M3 ---\n      ╱ |     ╱ |     ╱ |\n        ↓       ↓       ↓\n        g1 -←-- g2 -←-- g3\n        ↓       ↓       ↓\n\nIn the cluster, the axes of each tensor use the MPS order\n\n    PEPS:           PEPO:\n           3             3  4\n          ╱              | ╱\n    1 -- M -- 5     1 -- M -- 6\n       ╱ |             ╱ |\n      4  2            5  2\n    M[1 2 3 4; 5]  M[1 2 3 4 5; 6]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._cluster_truncate!-Union{Tuple{E}, Tuple{T}, Tuple{Vector{T}, Vector{E}, Vector{Bool}}} where {T<:(TensorKit.AbstractTensorMap{T, var\"#s61\", 4, 1} where {var\"#s61\"<:TensorKit.ElementarySpace, T}), E<:TensorKit.TruncationScheme}","page":"Library","title":"PEPSKit._cluster_truncate!","text":"Find projectors to truncate internal bonds of the cluster Ms.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._combine_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._combine_ab","text":"_combine_ab(a, b)\n\n\nContract the axis between a and b tensors\n\n    -- DX - a - D - b - DY --\n            ↓       ↓\n            da      db\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_corners-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_corners","text":"_contract_corners(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract all corners around the south-east at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_horizontal_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_horizontal_edges","text":"_contract_horizontal_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract the horizontal edges and corners around the south edge at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_site-Tuple{Tuple{Int64, Int64}, Any, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_site","text":"_contract_site(ind::Tuple{Int,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv)\n\nContract around a single site ind of a square network using a given CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_vertical_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_vertical_edges","text":"_contract_vertical_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract the vertical edges and corners around the east edge at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._dag-Union{Tuple{TensorKit.AbstractTensorMap{T, S, N, 1} where T}, Tuple{N}, Tuple{S}} where {S, N}","page":"Library","title":"PEPSKit._dag","text":"Adjoint of an MPS tensor, but permutes the physical spaces back into the codomain. Intuitively, this conjugates a tensor and then reinterprets its 'direction' as an MPS tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._fixgauge_benvXY-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensor{T, S, 4}, TensorKit.AbstractTensor{T, S, 4}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._fixgauge_benvXY","text":"When the (half) bond environment Z consists of two PEPSOrth tensors X, Y as\n\n    ┌---------------┐   ┌-------------------┐\n    |               | = |                   | ,\n    └---Z--       --┘   └--Z0---X--    --Y--┘\n        ↓                  ↓\n\napply the gauge transformation Linv, Rinv for Z to X, Y:\n\n        -1                                     -1\n         |                                      |\n    -4 - X - 1 - Rinv - -2      -4 - Linv - 1 - Y - -2\n         |                                      |\n        -3                                     -3\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._fuse_ids-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, NTuple{N, S}}} where {T, S, N}","page":"Library","title":"PEPSKit._fuse_ids","text":"_fuse_ids(op::AbstractTensorMap{T, S, N, N}, [Ps::NTuple{N, S}]) where {T, S, N}\n\nFuse identities on auxiliary physical spaces Ps into a given operator op. When Ps is not specified, it defaults to the domain spaces of op.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._get_allRLs-Union{Tuple{Vector{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{T, var\"#s183\", 4, 1} where {var\"#s183\"<:TensorKit.ElementarySpace, T})","page":"Library","title":"PEPSKit._get_allRLs","text":"Given a cluster Ms, find all R, L matrices on each internal bond\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._get_allprojs-Union{Tuple{E}, Tuple{Any, Any, Any, Vector{E}, Vector{Bool}}} where E<:TensorKit.TruncationScheme","page":"Library","title":"PEPSKit._get_allprojs","text":"Given a cluster Ms and the pre-calculated R, L bond matrices, find all projectors Pa, Pb and Schmidt weights wts on internal bonds.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._get_gatempo_se-Tuple{LocalOperator, Number, Int64, Int64}","page":"Library","title":"PEPSKit._get_gatempo_se","text":"Obtain the 3-site gate MPO on the southeast cluster at position [row, col]\n\n    r-1        g3\n                |\n                ↓\n    r   g1 -←- g2\n        c      c+1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._get_gatempos_se-Tuple{LocalOperator, Number}","page":"Library","title":"PEPSKit._get_gatempos_se","text":"Construct the 3-site gate MPOs on the southeast cluster  for 3-site simple update on square lattice.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._linearmap_twist!-Tuple{TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit._linearmap_twist!","text":"_linearmap_twist!(t)\n\n\nApply a twist to domain or codomain indices that correspond to dual spaces\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._proj_from_RL-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}}","page":"Library","title":"PEPSKit._proj_from_RL","text":"Given the tensors R, L on a bond, construct  the projectors Pa, Pb and the new bond weight s such that the contraction of Pa, s, Pb is identity when trunc = notrunc,\n\nThe arrows between Pa, s, Pb are\n\n    rev = false: - Pa --←-- Pb -\n                    1 ← s ← 2\n\n    rev = true:  - Pa --→-- Pb - \n                    2 → s → 1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._qr_bond-Union{Tuple{PT}, Tuple{PT, PT}} where PT<:Union{TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._qr_bond","text":"_qr_bond(A, B; gate_ax)\n\n\nUse QR decomposition on two tensors A, B connected by a bond to get the reduced tensors. When A, B are PEPSTensors,\n\n        2                   1                                   1\n        |                   |                                   |\n    5 -A/B- 3   ====>   4 - X ← 2   1 ← a - 3   1 - b → 3   4 → Y - 2\n        | ↘                 |            ↘           ↘          |\n        4   1               3             2           2         3\n\nWhen A, B are PEPOTensors, \n\nIf gate_ax = 1\n\n    2   3                1  2                                1  2\n      ↘ |                 ↘ |                                 ↘ |\n    6 -A/B- 4   ====>   5 - X ← 3   1 ← a - 3   1 - b → 3   5 → Y - 3\n        | ↘                 |            ↘           ↘          |\n        5   1               4             2           2         4\n\nIf gate_ax = 2\n\n    2   3                   2         2           2             2\n      ↘ |                   |          ↘           ↘            |\n    6 -A/B- 4   ====>   5 - X ← 3   1 ← a - 3   1 - b → 3   5 → Y - 3\n        | ↘                 | ↘                                 | ↘\n        5   1               4  1                                4  1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._qr_bond_undo-Tuple{TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit._qr_bond_undo","text":"_qr_bond_undo(X, a, b, Y)\n\n\nReconstruct the tensors connected by a bond from their _qr_bond results. For PEPSTensors,\n\n        -2                             -2\n        |                               |\n    -5- X - 1 - a - -3     -5 - b - 1 - Y - -3\n        |        ↘               ↘      |\n        -4        -1              -1   -4\n\nFor PEPOTensors\n\n    -2  -3                          -2  -3\n      ↘ |                             ↘ |\n    -6- X - 1 - a - -4     -6 - b - 1 - Y - -4\n        |        ↘               ↘      |\n        -5        -1              -1   -5\n\n        -3   -2              -2        -3\n        |      ↘               ↘        |\n    -6- X - 1 - a - -4     -6 - b - 1 - Y - -4\n        | ↘                             | ↘\n        -5 -1                          -5  -1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}","page":"Library","title":"PEPSKit._rrule","text":"_rrule(alg_rrule, config, f, args...; kwargs...) -> ∂f, ∂args...\n\nCustomize the pullback of a function f. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nwarning: Warning\nNo tangent is expected for the alg_rrule argument\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._simpleupdate2site-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, SimpleUpdate, SUWeight}","page":"Library","title":"PEPSKit._simpleupdate2site","text":"Perform simple update with Hamiltonian ham containing up to nearest neighbor interaction terms. \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._simpleupdate3site-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, SimpleUpdate, SUWeight}","page":"Library","title":"PEPSKit._simpleupdate3site","text":"Perform 3-site simple update for Hamiltonian ham.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._singular_value_distance-Tuple{Any}","page":"Library","title":"PEPSKit._singular_value_distance","text":"_singular_value_distance((S₁, S₂))\n\nCompute the singular value distance as an error measure, e.g. for CTMRG iterations. To that end, the singular values of the current iteration S₁ are compared with the previous one S₂. When the virtual spaces change, this comparison is not directly possible such that both tensors are projected into the smaller space and then subtracted.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._solve_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._solve_ab","text":"_solve_ab(Rx, Sx, x0)\n\n\nSolve the equations Rx x = Sx (x = a, b) with initial guess x0\n\n    ┌---------------------------┐\n    |   ┌----┐                  |\n    └---|    |--- 1 -- x -- 2 --┘\n        |    |         ↓\n        | Rx |        -3\n        |    |\n    ┌---|    |--- -1       -2 --┐\n    |   └----┘                  |\n    └---------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._su_xbond!-Union{Tuple{S}, Tuple{T}, Tuple{Union{InfinitePEPO, InfinitePEPS}, TensorKit.AbstractTensorMap{T, S, 2, 2}, SUWeight, Int64, Int64, TensorKit.TruncationScheme}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._su_xbond!","text":"_su_xbond!(state, gate, env, row, col, trscheme; gate_ax)\n\n\nSimple update of the x-bond between [r,c] and [r,c+1].\n\n        |           |\n    -- T[r,c] -- T[r,c+1] --\n        |           |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._su_ybond!-Union{Tuple{S}, Tuple{T}, Tuple{Union{InfinitePEPO, InfinitePEPS}, TensorKit.AbstractTensorMap{T, S, 2, 2}, SUWeight, Int64, Int64, TensorKit.TruncationScheme}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._su_ybond!","text":"Simple update of the y-bond between [r,c] and [r-1,c].\n\n        |\n    --T[r-1,c] --\n        |\n    -- T[r,c] ---\n        |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Ra-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Ra","text":"_tensor_Ra(benv, b)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0     Db0 - b -- DY0 -┘\n        |    |                ↓\n        |benv|                db\n        |    |                ↓\n    ┌---|    |- DX1     Db1 - b† - DY1 -┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Rb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Rb","text":"_tensor_Rb(benv, a)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 - a -- Da0     DY0 -┘\n        |    |        ↓\n        |benv|        da\n        |    |        ↓\n    ┌---|    |- DX1 - a† - Da1     DY1 -┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Sa-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Sa","text":"_tensor_Sa(benv, b, a2b2)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 -- (a2 b2) -- DY0 --┘\n        |    |         ↓     ↓\n        |benv|         da    db\n        |    |               ↓\n    ┌---|    |- DX1   Db1 -- b† - DY1 --┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Sb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Sb","text":"_tensor_Sb(benv, a, a2b2)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 -- (a2 b2) -- DY0 --┘\n        |    |         ↓     ↓\n        |benv|         da    db\n        |    |         ↓\n    ┌---|    |- DX1 -- a† - Da1   DY1 --┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_s-Tuple{TensorKit.AbstractTensorMap, TensorKit.DiagonalTensorMap, TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit.absorb_s","text":"absorb_s(U::AbstractTensorMap, S::DiagonalTensorMap, V::AbstractTensorMap)\n\nGiven tsvd result U, S and V, absorb singular values S into U and V by:\n\n    U -> U * sqrt(S), V -> sqrt(S) * V\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_weight-Tuple{Union{TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace}, SUWeight, Int64, Int64, Int64}","page":"Library","title":"PEPSKit.absorb_weight","text":"absorb_weight(t::Union{PEPSTensor, PEPOTensor}, weights::SUWeight, row::Int, col::Int, ax::Int; inv::Bool = false)\nabsorb_weight(t::Union{PEPSTensor, PEPOTensor}, weights::SUWeight, row::Int, col::Int, ax::NTuple{N, Int}; inv::Bool = false)\n\nAbsorb or remove environment weight on an axis of tensor t known to be located at position (row, col) in the unit cell of an InfinitePEPS or InfinitePEPO.  Weights around the tensor at (row, col) are\n\n                    |\n                [2,r,c]\n                    |\n    - [1,r,c-1] - T[r,c] - [1,r,c] -\n                    |\n                [1,r+1,c]\n                    |\n\nArguments\n\nt::PT : PEPSTensor or PEPOTensor to which the weight will be absorbed. \nweights::SUWeight : All simple update weights.\nrow::Int : The row index specifying the position in the tensor network.\ncol::Int : The column index specifying the position in the tensor network.\nax::Int : The axis into which the weight is absorbed, taking values from 1 to 4, standing for north, east, south, west respectively.\n\nKeyword arguments\n\ninv::Bool=false : If true, the inverse square root of the weight is absorbed.\n\nExamples\n\n# Absorb the weight into the north axis of tensor at position (2, 3)\nabsorb_weight(t, weights, 2, 3, 1)\n\n# Absorb the inverse of (i.e. remove) the weight into the east axis\nabsorb_weight(t, weights, 2, 3, 2; inv=true)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.bond_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, ALSTruncation}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.bond_truncate","text":"bond_truncate(a::AbstractTensorMap{T,S,2,1}, b::AbstractTensorMap{T,S,1,2}, benv::BondEnv{T,S}, alg) -> U, S, V, info\n\nAfter time-evolving the reduced tensors a and b connected by a bond,  truncate the bond dimension using the bond environment tensor benv.\n\n    ┌-----------------------┐\n    |   ┌----┐              |\n    └---|    |-- a === b ---┘\n        |benv|   ↓     ↓\n    ┌---|    |-- a† == b† --┐\n    |   └----┘              |\n    └-----------------------┘\n\nThe truncation algorithm alg can be either FullEnvTruncation or ALSTruncation.  The index order of a or b is\n\n    1 -a/b- 3\n        ↓       a[1 2; 3]\n        2       b[1; 2 3]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.bondenv_fu-Tuple{Int64, Int64, TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}, TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}, CTMRGEnv}","page":"Library","title":"PEPSKit.bondenv_fu","text":"Construct the environment (norm) tensor\n\n    C1---T1---------T1---C2   r-1\n    |    ‖          ‖    |\n    T4===XX==     ==YY===T2    r\n    |    ‖          ‖    |\n    C4---T3---------T3---C3   r+1\n    c-1  c         c+1  c+2\n\nwhere XX = X' X and YY = Y' Y (stacked together).\n\nAxis order: [DX1 DY1; DX0 DY0], as in\n\n    ┌---------------------┐\n    | ┌----┐              |\n    └-|    |---DX0  DY0---┘\n      |benv|\n    ┌-|    |---DX1  DY1---┐\n    | └----┘              |\n    └---------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_convergence-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.calc_convergence","text":"calc_convergence(env, CS_old, TS_old)\ncalc_convergence(env_new, env_old)\n\nGiven a new environment env, compute the maximal singular value distance. This determined either from the previous corner and edge singular values CS_old and TS_old, or alternatively, directly from the old environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}","page":"Library","title":"PEPSKit.calc_elementwise_convergence","text":"calc_elementwise_convergence(envfinal, envfix; atol=1e-6)\n\nCheck if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below atol and return the maximal difference.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.checklattice-Tuple","page":"Library","title":"PEPSKit.checklattice","text":"checklattice(Bool, args...)\nchecklattice(args...)\n\nHelper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.compute_projector-Tuple{Any, Any, HalfInfiniteProjector}","page":"Library","title":"PEPSKit.compute_projector","text":"compute_projector(enlarged_corners, coordinate, alg::ProjectorAlgorithm)\n\nDetermine left and right projectors at the bond given determined by the enlarged corners and the given coordinate using the specified alg.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_norm-Union{Tuple{N}, Tuple{NTuple{N, CartesianIndex{2}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N","page":"Library","title":"PEPSKit.contract_local_norm","text":"contract_local_norm(inds, ket, bra, env)\n\n\nContract a local norm of the PEPS peps around indices inds.\n\nThis works analogously to contract_local_operator by generating the contraction on a rectangular patch based on inds but replacing the operator with an identity such that the PEPS norm is computed. (Note that this is not the physical norm of the state.)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_operator-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{T, S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {T, S, N}","page":"Library","title":"PEPSKit.contract_local_operator","text":"contract_local_operator(inds, O, ket, bra, env)\n\n\nContract a local operator O on the PEPS peps at the indices inds using the environment env.\n\nThis works by generating the appropriate contraction on a rectangular patch with its corners specified by inds. The peps is contracted with O from above and below, and the PEPS-operator sandwich is surrounded with the appropriate environment tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_tensor-Tuple{Tuple{Int64, Int64, Int64}, TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace, InfiniteSquareNetwork{<:Tuple{T, T, Vararg{P, N}} where {N, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), P<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}}, CTMRGEnv}","page":"Library","title":"PEPSKit.contract_local_tensor","text":"contract_local_tensor(inds, O::PEPOTensor, network, env)\n\nContract a local tensor O inserted into the PEPO of a given network at position inds, using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_tensor-Union{Tuple{C}, Tuple{Tuple{Int64, Int64}, TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace, CTMRGEnv{C, <:TensorKit.AbstractTensorMap{T, S, 2, 1} where {T, S}}}} where C","page":"Library","title":"PEPSKit.contract_local_tensor","text":"contract_local_tensor(inds, O::PFTensor, env)\n\nContract a local tensor O inserted into a partition function pf at position inds, using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_projectors-NTuple{5, Any}","page":"Library","title":"PEPSKit.contract_projectors","text":"contract_projectors(U, S, V, Q, Q_next)\n\n\nCompute projectors based on a SVD of Q * Q_next, where the inverse square root isqS of the singular values is computed.\n\nLeft projector:\n\n    -- |~~~~~~| -- |~~|\n       |Q_next|    |V'| -- isqS --\n    == |~~~~~~| == |~~|\n\nRight projector:\n\n               |~~| -- |~~~| --\n    -- isqS -- |U'|    | Q |\n               |~~| == |~~~| ==\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.cost_function-Tuple{InfinitePEPS, CTMRGEnv, LocalOperator}","page":"Library","title":"PEPSKit.cost_function","text":"cost_function(peps::InfinitePEPS, env::CTMRGEnv, O::LocalOperator)\n\nReal part of expectation value of O. Prints a warning if the expectation value yields a finite imaginary part (up to a tolerance).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.cost_function_als-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.cost_function_als","text":"cost_function_als(benv, a1b1, a2b2)\n\n\nCalculate the cost function\n\n    f(a,b)  = ‖ |a1,b1⟩ - |a2,b2⟩ ‖^2\n    = ⟨a1,b1|a1,b1⟩ - 2 Re⟨a1,b1|a2,b2⟩ + ⟨a2,b2|a2,b2⟩\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_iteration-Tuple{Any, Any, PEPSKit.CTMRGAlgorithm}","page":"Library","title":"PEPSKit.ctmrg_iteration","text":"ctmrg_iteration(network, env, alg::CTMRGAlgorithm) -> env′, info\n\nPerform a single CTMRG iteration in which all directions are being grown and renormalized.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_leftmove-Tuple{Int64, Any, CTMRGEnv, SequentialCTMRG}","page":"Library","title":"PEPSKit.ctmrg_leftmove","text":"ctmrg_leftmove(col::Int, network, env::CTMRGEnv, alg::SequentialCTMRG)\n\nPerform sequential CTMRG left move on the col-th column.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.dtmap-Tuple","page":"Library","title":"PEPSKit.dtmap","text":"dtmap(args...; kwargs...)\n\nDifferentiable wrapper around [OhMyThreads.tmap].\n\nAll calls of dtmap inside of PEPSKit use the threading scheduler stored inside Defaults.scheduler which can be modified using set_scheduler!.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.eachcoordinate","page":"Library","title":"PEPSKit.eachcoordinate","text":"eachcoordinate(x, [dirs=1:4])\n\nEnumerate all (dir, row, col) pairs.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_northeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_northeast_corner","text":"enlarge_northeast_corner(E_north, C_northeast, E_east, A)\n\n\nContract the enlarged northeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n    -- E_north -- C_northeast\n          |             |\n    --    A    --    E_east\n          |             |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_northwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_northwest_corner","text":"enlarge_northwest_corner(E_west, C_northwest, E_north, A)\n\n\nContract the enlarged northwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n    C_northwest -- E_north --\n         |            |\n      E_west    --    A    --\n         |            |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_southeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_southeast_corner","text":"enlarge_southeast_corner(E_east, C_southeast, E_south, A)\n\n\nContract the enlarged southeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n          |             |\n    --    A    --    E_east\n          |             |\n    -- E_south -- C_southeast\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_southwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_southwest_corner","text":"enlarge_southwest_corner(E_south, C_southwest, E_west, A)\n\n\nContract the enlarged southwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n          |           |\n       E_west   --    A    --\n          |           |\n    C_southwest -- E_south --\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fidelity","text":"fidelity(benv, b1, b2)\n\n\nGiven the bond environment benv, calculate the fidelity between two states specified by the bond matrices b1, b2\n\n    F(b1, b2) = (⟨b1|b2⟩ ⟨b2|b1⟩) / (⟨b1|b1⟩ ⟨b2|b2⟩)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fidelity","text":"fidelity(benv, a1b1, a2b2)\n\n\nCalculate the fidelity between two evolution steps\n\n        |⟨a1,b1|a2,b2⟩|^2\n    --------------------------\n    ⟨a1,b1|a1,b1⟩⟨a2,b2|a2,b2⟩\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}","page":"Library","title":"PEPSKit.fix_gauge_corner","text":"fix_gauge_corner(corner, σ_in, σ_out)\n\n\nMultiply corner tensor with incoming and outgoing gauge signs.\n\n    corner -- σ_out --\n      |\n     σ_in\n      |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_edge","text":"fix_gauge_east_edge(, env, signs)\n\n\nApply fix_gauge_edge to the east edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_left_vecs","text":"fix_gauge_east_left_vecs(, U, signs)\n\n\nMultiply east left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_right_vecs","text":"fix_gauge_east_right_vecs(, V, signs)\n\n\nMultiply east right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_edge-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}} where {T, S, N}","page":"Library","title":"PEPSKit.fix_gauge_edge","text":"fix_gauge_edge(edge, σ_in, σ_out)\n\n\nMultiply edge tensor with incoming and outgoing gauge signs.\n\n    -- σ_in -- edge -- σ_out --\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_edge","text":"fix_gauge_north_edge(, env, signs)\n\n\nApply fix_gauge_edge to the north edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_left_vecs","text":"fix_gauge_north_left_vecs(, U, signs)\n\n\nMultiply north left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_right_vecs","text":"fix_gauge_north_right_vecs(, V, signs)\n\n\nMultiply north right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northeast_corner","text":"fix_gauge_northeast_corner(, env, signs)\n\n\nApply fix_gauge_corner to the northeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northwest_corner","text":"fix_gauge_northwest_corner(, env, signs)\n\n\nApply fix_gauge_corner to the northwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_edge","text":"fix_gauge_south_edge(, env, signs)\n\n\nApply fix_gauge_edge to the south edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_left_vecs","text":"fix_gauge_south_left_vecs(, U, signs)\n\n\nMultiply south left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_right_vecs","text":"fix_gauge_south_right_vecs(, V, signs)\n\n\nMultiply south right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southeast_corner","text":"fix_gauge_southeast_corner(, env, signs)\n\n\nApply fix_gauge_corner to the southeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southwest_corner","text":"fix_gauge_southwest_corner(, env, signs)\n\n\nApply fix_gauge_corner to the southwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_edge","text":"fix_gauge_west_edge(, env, signs)\n\n\nApply fix_gauge_edge to the west edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_left_vecs","text":"fix_gauge_west_left_vecs(, U, signs)\n\n\nMultiply west left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_right_vecs","text":"fix_gauge_west_right_vecs(, V, signs)\n\n\nMultiply west right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_global_phases-Tuple{CTMRGEnv, CTMRGEnv}","page":"Library","title":"PEPSKit.fix_global_phases","text":"fix_global_phases(envprev, envfix)\n\n\nFix global multiplicative phase of the environment tensors. To that end, the dot products between all corners and all edges are computed to obtain the global phase which is then divided out.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fixedpoint-Tuple{Any, InfinitePEPS, CTMRGEnv}","page":"Library","title":"PEPSKit.fixedpoint","text":"fixedpoint(operator, peps₀::InfinitePEPS, env₀::CTMRGEnv; kwargs...) -> peps_final, env_final, cost_final, info\n# expert version:\nfixedpoint(operator, peps₀::InfinitePEPS, env₀::CTMRGEnv, alg::PEPSOptimize; finalize!=OptimKit._finalize!)\n\nFind the fixed point of operator (i.e. the ground state) starting from peps₀ according to the supplied optimization parameters. The initial environment env₀ serves as an initial guess for the first CTMRG run. By default, a random initial environment is used.\n\nThe optimization parameters can be supplied via the keyword arguments or directly as a PEPSOptimize struct. The following keyword arguments are supported:\n\nKeyword arguments\n\nGeneral settings\n\ntol::Real=0.0001 : Overall tolerance for gradient norm convergence of the optimizer. Sets related tolerance such as the boundary and boundary-gradient tolerances to sensible defaults unless they are explictly specified.\nverbosity::Int=1 : Overall output information verbosity level, should be one of the following:\nSuppress all output\nOnly print warnings\nInitialization and convergence info\nIteration info\nDebug info including AD outputs\nreuse_env::Bool=true : If true, the current optimization step is initialized on the previous environment, otherwise a random environment is used.\nsymmetrization::Union{Nothing,SymmetrizationStyle}=nothing : Accepts nothing or a SymmetrizationStyle, in which case the PEPS and PEPS gradient are symmetrized after each optimization iteration.\n(finalize!)=OptimKit._finalize! : Inserts a finalize! function call after each optimization step by utilizing the finalize! kwarg of OptimKit.optimize. The function maps (peps, env), f, g = finalize!((peps, env), f, g, numiter).\n\nBoundary algorithm\n\nSupply boundary algorithm parameters via boundary_alg::Union{NamedTuple,<:CTMRGAlgorithm} using either a NamedTuple of keyword arguments or a CTMRGAlgorithm directly. See leading_boundary for a description of all possible keyword arguments. By default, a CTMRG tolerance of tol=1e-4tol and is used.\n\nGradient algorithm\n\nSupply gradient algorithm parameters via gradient_alg::Union{NamedTuple,Nothing,<:GradMode} using either a NamedTuple of keyword arguments, nothing, or a GradMode struct directly. Pass nothing to fully differentiate the CTMRG run, meaning that all iterations will be taken into account, instead of differentiating the fixed point. The supported NamedTuple keyword arguments are:\n\ntol::Real=1e-2tol : Convergence tolerance for the fixed-point gradient iteration.\nmaxiter::Int=30 : Maximal number of gradient problem iterations.\nalg::Symbol=:eigsolver : Gradient algorithm variant, can be one of the following:\n:geomsum : Compute gradient directly from the geometric sum, see GeomSum\n:manualiter : Iterate gradient geometric sum manually, see ManualIter\n:linsolver : Solve fixed-point gradient linear problem using iterative solver, see LinSolver\n:eigsolver : Determine gradient via eigenvalue formulation of its Sylvester equation, see EigSolver\nverbosity::Int : Gradient output verbosity, ≤0 by default to disable too verbose printing. Should only be >0 for debug purposes.\niterscheme::Symbol=:fixed : CTMRG iteration scheme determining mode of differentiation. This can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\nOptimizer settings\n\nSupply the optimizer algorithm via optimizer_alg::Union{NamedTuple,<:OptimKit.OptimizationAlgorithm} using either a NamedTuple of keyword arguments or a OptimKit.OptimizationAlgorithm directly. By default, OptimKit.LBFGS is used in combination with a HagerZhangLineSearch. The supported keyword arguments are:\n\nalg::Symbol=:lbfgs : Optimizer algorithm, can be one of the following:\n:gradientdescent : Gradient descent algorithm, see the OptimKit README\n:conjugategradient : Conjugate gradient algorithm, see the OptimKit README\n:lbfgs : L-BFGS algorithm, see the OptimKit README\ntol::Real=tol : Gradient norm tolerance of the optimizer.\nmaxiter::Int=100 : Maximal number of optimization steps.\nverbosity::Int=3 : Optimizer output verbosity.\nls_maxiter::Int=10 : Maximal number of linesearch iterations.\nls_maxfg::Int=20 : Maximal number of function-gradient evaluations during linesearch.\nlbfgs_memory::Int=20 : Size of limited memory representation of BFGS Hessian matrix.\n\nReturn values\n\nThe function returns the final PEPS, CTMRG environment and cost value, as well as an information NamedTuple which contains the following entries:\n\nlast_gradient : Last gradient of the cost function.\nfg_evaluations : Number of evaluations of the cost and gradient function.\ncosts : History of cost values.\ngradnorms : History of gradient norms.\ntruncation_errors : History of maximal truncation errors of the boundary algorithm.\ncondition_numbers : History of maximal condition numbers of the CTMRG environments.\ngradnorms_unitcell : History of gradient norms for each respective unit cell entry.\ntimes : History of optimization step execution times.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fixgauge_benv-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fixgauge_benv","text":"Use QR decomposition to fix gauge of the half bond environment Z. The reduced bond tensors a, b and Z are arranged as\n\n    ┌---------------┐\n    |               |\n    └---Z---a---b---┘\n        |   ↓   ↓\n        ↓\n\nReference: \n\nPhysical Review B 90, 064425 (2014)\nPhysical Review B 92, 035142 (2015)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.flip_svd-Tuple{TensorKit.AbstractTensorMap, TensorKit.DiagonalTensorMap, TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit.flip_svd","text":"flip_svd(u::AbstractTensorMap, s::DiagonalTensorMap, vh::AbstractTensorMap)\n\nGiven tsvd result u ← s ← vh, flip the arrow between the three tensors  to u2 → s2 → vh2 such that\n\n    u * s * vh = (@tensor t2[-1, ...; -2, ...] := u2[-1, ...; 2] * s2[1; 2] * vh2[1; -2, ...])\n\nThe axis orders for s, s2 are\n\n    1 ← s ← 2   2 → s2 → 1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fpgrad","page":"Library","title":"PEPSKit.fpgrad","text":"fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)\n\nCompute the gradient of the CTMRG fixed point by solving the following equation:\n\ndx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA\n\nwhere ∂F∂x is the gradient of the cost function with respect to the PEPS tensors, ∂f∂x is the partial gradient of the CTMRG iteration with respect to the environment tensors, ∂f∂A is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and y0 is the initial guess for the fixed-point iteration. The function returns the gradient dx of the fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.full_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, NTuple{4, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}","page":"Library","title":"PEPSKit.full_infinite_environment","text":"full_infinite_environment(quadrant1, quadrant2, quadrant3, quadrant4)\nfull_infinite_environment(half1, half2)\nfull_infinite_environment(C_1, C_2, C_3, C_4, E_1, E_2, E_3, E_4, E_5, E_6, E_7, E_8, A_1, A_2, A_3, A_4)\nfull_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x, A_1, A_2, A_3, A_4)\nfull_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2, A_3, A_4)\n\nContract four quadrants (enlarged corners) to form a full-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n      |     |        |     |\n                     |     |\n      |     |        |     |\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant4|    |quadrant3|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n\nIn the same manner two halfs can be used to contract the full-infinite environment.\n\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n    |         half1          |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n      |     |        |     |\n                     |     |\n      |     |        |     |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n    |         half2          |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n\nThe environment can also be contracted directly from all its constituent tensors.\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      |\n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n                   |      |\n     |      |      |      |\n    E_8 -- A_4 -- A_3 -- E_5\n     |      |      |      |\n    C_4 -- E_7 -- E_6 -- C_3\n\nAlternatively, contract the environment with a vector x acting on it\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      |\n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n                   |      |\n    [~~~~x~~~]     |      |\n     |      |      |      |\n    E_8 -- A_4 -- A_3 -- E_5\n     |      |      |      |\n    C_4 -- E_7 -- E_6 -- C_3\n\n\nor contract the adjoint environment with x, e.g. as needed for iterative solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fullenv_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}, FullEnvTruncation}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fullenv_truncate","text":"fullenv_truncate(benv::BondEnv{T,S}, b0::AbstractTensorMap{T,S,1,1}, alg::FullEnvTruncation) -> U, S, V, info\n\nPerform full environment truncation algorithm from Phys. Rev. B 98, 085155 (2018) on benv.\n\nGiven a fixed state |b0⟩ with bond matrix b0 and the corresponding positive-definite bond environment benv,  find the state |b⟩ with truncated bond matrix b = u s v† that maximizes the fidelity (not normalized by ⟨b0|b0⟩)\n\n    F(b) = ⟨b|b0⟩⟨b0|b⟩ / ⟨b|b⟩\n\n            ┌----------------------┐  ┌-----------------------┐\n            |   ┌----┐             |  |   ┌----┐              |\n            └---|    |---- b0 -----┘  └---|    |- u ← s ← v† -┘\n                |benv|                    |benv|\n            ┌---|    |-u† → s → v -┐  ┌---|    |----- b0† ----┐\n            |   └----┘             |  |   └----┘              |\n            └----------------------┘  └-----------------------┘\n        = ───────────────────────────────────────────────────────\n                        ┌-----------------------┐\n                        |   ┌----┐              |\n                        └---|    |- u ← s ← v† -┘\n                            |benv|\n                        ┌---|    |- u† → s → v -┐\n                        |   └----┘              |\n                        └-----------------------┘\n\nThe singular value spectrum s is truncated to desired dimension,  and normalized such that the maximum is 1. Note that benv is contracted to b0 using @tensor,  instead of acting on b0 as a linear map.\n\nThe algorithm iteratively optimizes the vectors l, r\n\n    --- l -←-  =  --- u ← s -←-  ,  -←- r ---  =  -←- s ← v† ---\n\nOptimization of r\n\nDefine the vector p and the positive map B as\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-←   --┘   └---|    |- u ←      ---┘\n            | p†|         =     |benv|\n        ┌---|   |-------┐   ┌---|    |----- b0† ----┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-←   --┘   └---|    |- u ←      ---┘\n            | B |         =     |benv|\n        ┌---|   |-→   --┐   ┌---|    |- u†→      ---┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\nThen (each index corresponds to a pair of fused indices)\n\n    F(r,r†) = |p† r|² / (r† B r)\n            = (r† p) (p† r) / (r† B r)\n\nwhich is maximized when\n\n    ∂F/∂r̄ * (r† B r)²\n    = p (p† r) (r† B r) - |p† r|² (B r) = 0\n\nNote that B is positive (consequently B† = B).  Then the solution for the vector r is\n\n    r = B⁻¹ p\n\nWe can verify that (using B† = B)\n\n    ∂F/∂r̄ * (r† B r)²\n    = p (p† B⁻¹ p) (p† B⁻¹ B B⁻¹ p) - |p† B⁻¹ p|² (B B⁻¹ p) \n    = 0\n\nThen the bond matrix u s v† is updated by truncated SVD:\n\n    - u ← r -    ==>    - u ← s ← v† -\n\nOptimization of l\n\nThe process is entirely similar.  Define the vector p and the positive map B as\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-  ←-o-┘   └---|    |--   ←-o- v† -┘\n            | p†|         =     |benv|\n        ┌---|   |-------┐   ┌---|    |----- b0† ----┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-  ←-o-┘   └---|    |--    ←-o- v†-┘\n            | B |         =     |benv|\n        ┌---|   |-  →-o-┐   ┌---|    |--    →-o- v -┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\nHere o is the parity tensor (twist) necessary for fermions.  Then (each index corresponds to a pair of fused indices)\n\n    F(l,l†) = |p† l|² / (l† B l)\n\nwhich is maximized when\n\n    l = B⁻¹ p\n\nThen the bond matrix u s v† is updated by SVD:\n\n    - l ← v† -   ==>    - u ← s ← v† -\n\nReturn values\n\nReturns the SVD result of the new bond matrix U, S, V, as well as an information NamedTuple containing the following fields:\n\nfid : Last fidelity.\nΔfid : Last fidelity difference.\nΔs : Last singular value difference.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fuse_physicalspaces-Tuple{TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fuse_physicalspaces","text":"fuse_physicalspaces(O)\n\n\nFuse the physical indices of a PEPO tensor, obtaining a PEPS tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.gate_to_mpo3-Union{Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, Any}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.gate_to_mpo3","text":"Convert a 3-site gate to MPO form by SVD,  in which the axes are ordered as\n\n    2               3               3\n    ↓               ↓               ↓\n    g1 ←- 3    1 ←- g2 ←- 4    1 ←- g3\n    ↓               ↓               ↓\n    1               2               2\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(envprev, envfinal)\n\n\nFix the gauge of envfinal based on the previous environment envprev. This assumes that the envfinal is the result of one CTMRG iteration on envprev. Given that the CTMRG run is converged, the returned environment will be element-wise converged to envprev.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_3site_se-Tuple{Union{InfinitePEPO, InfinitePEPS}, SUWeight, Int64, Int64}","page":"Library","title":"PEPSKit.get_3site_se","text":"Obtain the 3-site cluster in the \"southeast corner\" of a square plaquette.\n\n    r-1         M3\n                |\n                ↓\n    r   M1 -←- M2\n        c      c+1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_expham-Tuple{LocalOperator, Number}","page":"Library","title":"PEPSKit.get_expham","text":"get_expham(H::LocalOperator, dt::Number)\n\nCompute exp(-dt * op) for each term op in H, and combine them into a new LocalOperator. Each op in H must be a single TensorMap.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_gateterm-Tuple{LocalOperator, Tuple{CartesianIndex{2}, CartesianIndex{2}}}","page":"Library","title":"PEPSKit.get_gateterm","text":"get_gateterm(gate::LocalOperator, bond::NTuple{2,CartesianIndex{2}})\n\nGet the term of a 2-site gate acting on a certain bond. Input gate should only include one term for each nearest neighbor bond.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.half_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}","page":"Library","title":"PEPSKit.half_infinite_environment","text":"half_infinite_environment(quadrant1, quadrant2)\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2)\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x, A_1, A_2)\nhalf_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2)\n\nContract two quadrants (enlarged corners) to form a half-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n      |     |        |     |\n\nThe environment can also be contracted directly from all its constituent tensors.\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      |\n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n\nAlternatively, contract the environment with a vector x acting on it\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      |\n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n                  [~~~x~~~~]\n\nor contract the adjoint environment with x, e.g. as needed for iterative solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}","page":"Library","title":"PEPSKit.hook_pullback","text":"hook_pullback(f, args...; alg_rrule=nothing, kwargs...)\n\nWrapper function to customize the pullback of a function f. This function is equivalent to f(args...; kwargs...), but the pullback can be customized by implementing the following function:\n\n_rrule(alg_rrule, config, f, args...; kwargs...) -> NoTangent(), ∂f, ∂args...\n\nThis function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nSee also _rrule.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.initialize_mps-Tuple{Union{MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), O<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}, MPSKit.MultilineMPO{<:MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), O<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}}}, Any}","page":"Library","title":"PEPSKit.initialize_mps","text":"initialize_mps(\n    f=randn,\n    T=scalartype(O),\n    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,1}\n)\ninitialize_mps(\n    f=randn,\n    T=scalartype(O),\n    O::Union{MultilineTransferPEPS,MultilineTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,2}\n)\n\nInialize a boundary MPS for the transfer operator O by specifying an array of virtual spaces consistent with the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.inner_prod","text":"inner_prod(benv, b1, b2)\n\n\nGiven the bond environment benv, calculate the inner product between two states specified by the bond matrices b1, b2\n\n            ┌--------------------┐\n            |   ┌----┐           |\n            └---|    |---- b2 ---┘\n    ⟨b1|b2⟩ =   |benv|\n            ┌---|    |---- b1†---┐\n            |   └----┘           |\n            └--------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.inner_prod","text":"inner_prod(benv, a1b1, a2b2)\n\n\nCalculate the inner product <a1,b1|a2,b2>\n\n    ┌--------------------------------┐\n    |   ┌----┐                       |\n    └---|    |- DX0 - (a2 b2) - DY0 -┘\n        |    |        ↓    ↓\n        |benv|        da   db\n        |    |        ↓    ↓\n    ┌---|    |- DX1 - (a1 b1)†- DY1 -┐\n    |   └----┘                       |\n    └--------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.is_equivalent_bond-Tuple{Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{Int64, Int64}}","page":"Library","title":"PEPSKit.is_equivalent_bond","text":"is_equivalent_bond(bond1::NTuple{2,CartesianIndex{2}}, bond2::NTuple{2,CartesianIndex{2}}, (Nrow, Ncol)::NTuple{2,Int})\n\nCheck if two 2-site bonds are related by a (periodic) lattice translation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.is_nearest_neighbour-Tuple{LocalOperator}","page":"Library","title":"PEPSKit.is_nearest_neighbour","text":"is_nearest_neighbour(H::LocalOperator)\n\nCheck if an operator H contains only nearest neighbor terms.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.j1_j2_model-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.j1_j2_model","text":"j1_j2_model([elt::Type{T}, symm::Type{S},] lattice::InfiniteSquare;\n            J1=1.0, J2=1.0, spin=1//2, sublattice=true)\n\nSquare lattice J_1text-J_2 model, defined by the Hamiltonian\n\nH = J_1 sum_langle ij rangle vecS_i cdot vecS_j\n+ J_2 sum_langlelangle ij ranglerangle vecS_i cdot vecS_j\n\nwhere vecS_i = (S_i^x S_i^y S_i^z). We denote the nearest and next-nearest neighbor terms using langle ij rangle and langlelangle ij ranglerangle, respectively. The sublattice kwarg enables a single-site unit cell ground state via a unitary sublattice rotation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.left_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.left_projector","text":"left_projector(E_1, C, E_2, V, isqS, A)\n\n\nContract the CTMRG left projector with the higher-dimensional subspace facing to the left.\n\n     C  --  E_2    -- |~~|\n     |       |        |V'| -- isqS --\n    E_1 --   A     -- |~~|\n     |       |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.lq_through-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{T, S, 4, 1} where T, TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.lq_through","text":"Perform LQ decomposition through a tensor\n\n             ╱           ╱\n    --L0-*--Q---  ←  ---M--*-L1--\n          ╱ |         ╱ |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.nearest_neighbour_hamiltonian-Union{Tuple{T}, Tuple{S}, Tuple{Matrix{S}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {S, T}","page":"Library","title":"PEPSKit.nearest_neighbour_hamiltonian","text":"nearest_neighbour_hamiltonian(lattice::Matrix{S}, h::AbstractTensorMap{T,S,2,2}) where {S,T}\n\nCreate a nearest neighbor LocalOperator by specifying the 2-site interaction term h which acts both in horizontal and vertical direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.network_value-Tuple{InfiniteSquareNetwork, CTMRGEnv}","page":"Library","title":"PEPSKit.network_value","text":"network_value(network::InfiniteSquareNetwork, env::CTMRGEnv)\n\nReturn the value (per unit cell) of a given contractible network contracted using a given CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.norm_preserving_retract-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.norm_preserving_retract","text":"norm_preserving_retract(A, η, α)\n\n\nPerforms a norm-preserving retraction of vector A along the direction η with step size α, giving a new vector A´,\n\nA  cos ( α η  A ) A + sin ( α η  A ) A η  η\n\nand corresponding directional derivative ξ,\n\nξ = cos ( α η  A ) η - sin ( α η  A ) η A  A\n\nsuch that  A ξ  = 0 and A = A.\n\nnote: Note\nThe vectors A and η should satisfy the interface specified by VectorInterface.jl\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.norm_preserving_transport!-NTuple{5, Any}","page":"Library","title":"PEPSKit.norm_preserving_transport!","text":"norm_preserving_transport!(ξ, A, η, α, A´)\n\n\nTransports a direction ξ at A to a valid direction at A´ corresponding to the norm-preserving retraction of A along η with step size α. In particular, starting from a direction η of the form\n\nξ =  η  η ξ  η  η + Δξ\n\nwhere  Δξ A  =  Δξ η  = 0, it returns\n\nξ(α) =  η  η ξ  ( cos ( α η  A ) η  η - sin ( α η  A ) A  A ) + Δξ\n\nsuch that ξ(α) = ξ  A ξ(α)  = 0.\n\nnote: Note\nThe vectors A and η should satisfy the interface specified by VectorInterface.jl\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.peps_normalize-Tuple{InfinitePEPS}","page":"Library","title":"PEPSKit.peps_normalize","text":"peps_normalize(A::InfinitePEPS)\n\nNormalize the individual tensors in the unit cell of an InfinitePEPS such that they each have unit Euclidean norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.peps_retract-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.peps_retract","text":"peps_retract(x, η, α)\n\n\nPerforms a norm-preserving retraction of an infinite PEPS A = x[1] along η with step size α, giving a new PEPS A´,\n\nA  cos ( α η  A ) A + sin ( α η  A ) A η  η\n\nand corresponding directional derivative ξ,\n\nξ = cos ( α η  A ) η - sin ( α η  A ) η A  A\n\nsuch that  A ξ  = 0 and A = A.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.peps_transport!-NTuple{5, Any}","page":"Library","title":"PEPSKit.peps_transport!","text":"peps_transport!(ξ, x, η, α, x´)\n\n\nTransports a direction at A = x[1] to a valid direction at A´ = x´[1] corresponding to the norm-preserving retraction of A along η with step size α. In particular, starting from a direction η of the form\n\nξ =  η  η ξ  η  η + Δξ\n\nwhere  Δξ A  =  Δξ η  = 0, it returns\n\nξ(α) =  η  η ξ  ( cos ( α η  A ) η  η - sin( α η  A ) A  A ) + Δξ\n\nsuch that ξ(α) = ξ  A ξ(α)  = 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.positive_approx-Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2} where {T<:Number, S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit.positive_approx","text":"Replace bond environment benv by its positive approximant Z† Z (returns the \"half environment\" Z)\n\n    ┌-----------------┐     ┌---------------┐\n    | ┌----┐          |     |               |\n    └-|    |-- 3  4 --┘     └-- Z -- 3  4 --┘\n      |benv|            =       ↓\n    ┌-|    |-- 1  2 --┐     ┌-- Z†-- 1  2 --┐\n    | └----┘          |     |               |\n    └-----------------┘     └---------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.product_peps-Tuple","page":"Library","title":"PEPSKit.product_peps","text":"product_peps(peps_args...; unitcell=(1, 1), noise_amp=1e-2, state_vector=nothing)\n\nInitialize a normalized random product PEPS with noise. The given arguments are passed on to the InfinitePEPS constructor.\n\nThe noise intensity can be tuned with noise_amp. The product state coefficients can be specified using the state_vector kwarg in the form of a matrix of size unitcell containing vectors that match the PEPS physical dimensions. If nothing is provided, random Gaussian coefficients are used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.pwave_superconductor-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.pwave_superconductor","text":"pwave_superconductor([T=ComplexF64,] lattice::InfiniteSquare; t=1, μ=2, Δ=1)\n\nSquare lattice p-wave superconductor model, defined by the Hamiltonian\n\n    H = -sum_langle ij rangle left( t c_i^dagger c_j +\n    Delta c_i c_j + texthc right) - mu sum_i n_i\n\nwhere t is the hopping amplitude, Delta specifies the superconducting gap, mu is the chemical potential, and n_i = c_i^dagger c_i is the fermionic number operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.qr_through-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}, TensorKit.AbstractTensorMap{T, S, 4, 1} where T}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.qr_through","text":"Perform QR decomposition through a PEPS tensor\n\n             ╱           ╱\n    --R0----M---  →  ---Q--*-R1--\n          ╱ |         ╱ |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.reduced_densitymatrix","page":"Library","title":"PEPSKit.reduced_densitymatrix","text":"Construct the reduced density matrix ρ of PEPS or PEPO (representing PEPS with ancilla legs) ket, bra with open indices inds using the environment env. Alternatively, construct the reduced density matrix ρ of a mixed state specified by the density matrix PEPO state with open indices inds using the environment env.\n\nThis works by generating the appropriate contraction on a rectangular patch with its corners specified by inds. The result is normalized such that tr(ρ) = 1. \n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.renormalize_bottom_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_bottom_corner","text":"renormalize_bottom_corner((r, c), env, projectors)\nrenormalize_bottom_corner(C_southwest, E_south, P_bottom)\n\nApply bottom projector to southwest corner and south edge.\n\n        |\n    [P_bottom]\n     |     |\n     C --  E -- in\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_corner-Union{Tuple{N}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, N, N}, TensorKit.AbstractTensorMap{<:Any, S, N, 1}, TensorKit.AbstractTensorMap{<:Any, S, 1, N}}} where {S, N}","page":"Library","title":"PEPSKit.renormalize_corner","text":"renormalize_corner(quadrant, P_left, P_right)\n\n\nApply projectors to each side of a quadrant.\n\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --\n    |~~~~~~~~| -- |~~~~~~|\n     |     |\n    [P_right]\n        |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_east_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_east_edge","text":"renormalize_east_edge((row, col), env, P_top, P_bottom, network::InfiniteSquareNetwork{P})\nrenormalize_east_edge(E_east, P_top, P_bottom, A::P)\n\nAbsorb a blocal effective tensor into the east edge using the given projectors and environment tensors.\n\n           |\n     [~~P_top~~~]\n      |        |\n   -- A  --  E_east\n      |        |\n     [~P_bottom~]\n           |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_north_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_north_edge","text":"renormalize_north_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_north_edge(E_north, P_left, P_right, A::P)\n\nAbsorb a local effective tensor A into the north edge using the given projectors and environment tensors.\n\n       |~~~~~~| -- E_north -- |~~~~~~~|\n    -- |P_left|       |       |P_right| --\n       |~~~~~~| --    A    -- |~~~~~~~|\n                      |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northeast_corner","text":"renormalize_northeast_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_northeast_corner(quadrant, P_left, P_right)\nrenormalize_northeast_corner(E_north, C_northeast, E_east, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged northeast corner.\n\n       |~~~~~~~| -- |~~~~~~~~|\n    -- |P_right|    |quadrant|\n       |~~~~~~~| -- |~~~~~~~~|\n                      |    |\n                     [P_left]\n                         |\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n       |~~~~~~~| -- E_north -- C_northeast\n    -- |P_right|       |            |\n       |~~~~~~~| --    A    --    E_east\n                       |            |\n                     [~~~~~P_left~~~~~]\n                              |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northwest_corner","text":"renormalize_northwest_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_northwest_corner(quadrant, P_left, P_right)\nrenormalize_northwest_corner(E_west, C_northwest, E_north, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged northwest corner.\n\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --\n    |~~~~~~~~| -- |~~~~~~|\n     |     |\n    [P_right]\n        |\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n    C_northwest -- E_north -- |~~~~~~|\n         |           |        |P_left| --\n      E_west    --   A     -- |~~~~~~|\n         |           |\n      [~~~~~P_right~~~~]\n               |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_sequentially-Tuple{Int64, Any, Any, Any}","page":"Library","title":"PEPSKit.renormalize_sequentially","text":"renormalize_sequentially(col::Int, projectors, network, env)\n\nRenormalize one column of the CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_simultaneously-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_simultaneously","text":"renormalize_simultaneously(\n    enlarged_corners,\n    projectors,\n    network,\n    env\n)\n\n\nRenormalize all enlarged corners and edges simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_south_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_south_edge","text":"renormalize_south_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_south_edge(E_south, P_left, P_right, A::P)\n\nAbsorb a local effective tensor into the south edge using the given projectors and environment tensors.\n\n                       |\n       |~~~~~~~| --    A    -- |~~~~~~|\n    -- |P_right|       |       |P_left| --\n       |~~~~~~~| -- E_south -- |~~~~~~|\n                       |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southeast_corner","text":"renormalize_southeast_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_southeast_corner(quadrant, P_left, P_right)\nrenormalize_southeast_corner(E_east, C_southeast, E_south, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged southeast corner.\n\n                        |\n                    [P_right]\n                      |   |\n       |~~~~~~| -- |~~~~~~~~|\n    -- |P_left|    |quadrant|\n       |~~~~~~| -- |~~~~~~~~|\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n                            |\n                    [~~~~P_right~~~~]\n                      |           |\n       |~~~~~~| --    A    --   E_east\n    -- |P_left|       |           |\n       |~~~~~~| -- E_south -- C_southeast\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southwest_corner","text":"renormalize_southwest_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_southwest_corner(quadrant, P_left, P_right)\nrenormalize_southwest_corner(E_south, C_southwest, E_west, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged southwest corner.\n\n         |\n     [P_left]\n      |    |\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --\n    |~~~~~~~~| -- |~~~~~~|\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n               |\n       [~~~~~P_left~~~~~]\n         |            |\n       E_west   --    A    -- |~~~~~~~|\n         |            |       |P_right| --\n    C_southwest -- E_south -- |~~~~~~~|\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_top_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_top_corner","text":"renormalize_top_corner((row, col), env, projectors)\nrenormalize_top_corner(C_northwest, E_north, P_top)\n\nApply top projector to northwest corner and north edge.\n\n     C -- E --\n     |    |\n    [~P_top~]\n        |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_west_edge-Union{Tuple{Pb}, Tuple{Pt}, Tuple{Any, CTMRGEnv, Array{Pt, 3}, Array{Pb, 3}, InfiniteSquareNetwork}} where {Pt, Pb}","page":"Library","title":"PEPSKit.renormalize_west_edge","text":"renormalize_west_edge((row, col), env, P_top, P_bottom, network::InfiniteSquareNetwork{P})\nrenormalize_west_edge(E_west, P_top, P_bottom, A::P)\n\nAbsorb a local effective tensor into the west edge using the given projectors and environment tensors.\n\n           |\n     [~P_bottom~]\n      |        |\n    E_west --  A --\n      |        |\n     [~~P_top~~~]\n           |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.right_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.right_projector","text":"right_projector(E_1, C, E_2, U, isqS, A)\n\n\nContract the CTMRG right projector with the higher-dimensional subspace facing to the right.\n\n               |~~| --   E_2   --  C\n    -- isqS -- |U'|      |         |\n               |~~| --   A     -- E_1\n                         |         |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.rotate_north-Tuple{Any, Any}","page":"Library","title":"PEPSKit.rotate_north","text":"rotate_north(t, dir)\n\n\nRotate the dir direction of t to face north by successive applications of rotl90.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.sdiag_pow-Tuple{TensorKit.DiagonalTensorMap, Real}","page":"Library","title":"PEPSKit.sdiag_pow","text":"sdiag_pow(s, pow::Real; tol::Real=eps(scalartype(s))^(3 / 4))\n\nCompute s^pow for a diagonal matrix s.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.select_algorithm","page":"Library","title":"PEPSKit.select_algorithm","text":"select_algorithm(func_or_alg, args...; kwargs...) -> Algorithm\n\nParse arguments and keyword arguments to the algorithm struct corresponding to func_or_alg and return an algorithm instance. To that end, we use a general interface where all keyword arguments that can be algorithm themselves can be specified using\n\nalg::Algorithm : an instance of the algorithm struct or\n(; alg::Symbol, alg_kwargs...) : a NamedTuple where the algorithm is specified by a Symbol and the algorithm keyword arguments \n\nA full description of the keyword argument can be found in the respective function or algorithm struct docstrings.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.sequential_projectors-Tuple{Int64, Any, CTMRGEnv, PEPSKit.ProjectorAlgorithm}","page":"Library","title":"PEPSKit.sequential_projectors","text":"sequential_projectors(col::Int, network, env::CTMRGEnv, alg::ProjectorAlgorithm)\nsequential_projectors(coordinate::NTuple{3,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :sequential scheme either for an entire column col or for a specific coordinate (where dir=WEST is already implied in the :sequential scheme).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.simpleupdate-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, SimpleUpdate, SUWeight}","page":"Library","title":"PEPSKit.simpleupdate","text":"simpleupdate(\n    state::InfinitePEPS, ham::LocalOperator, alg::SimpleUpdate, env::SUWeight;\n    bipartite::Bool = false, force_3site::Bool = false, check_interval::Int = 500\n)\nsimpleupdate(\n    densitymatrix::InfinitePEPO, ham::LocalOperator, alg::SimpleUpdate, env::SUWeight;\n    gate_bothsides::Bool = true, force_3site::Bool = false, check_interval::Int = 500\n)\n\nPerform a simple update on an InfinitePEPS state or an InfinitePEPO densitymatrix using the Hamiltonian ham, which can contain up to next-nearest-neighbor interaction terms.\n\nKeyword Arguments\n\nbipartite::Bool=false: If true, enforces the bipartite structure of the PEPS. \ngate_bothsides::Bool=true: (Effective only for PEPO evolution) If true, apply the Trotter gate to both side of the PEPO. Otherwise, the gate is only applied to the physical codomain legs. \nforce_3site::Bool=false: Forces the use of the 3-site simple update algorithm, even if the Hamiltonian contains only nearest-neighbor terms.\ncheck_interval::Int=500: Specifies the number of evolution steps between printing progress information.\n\nNotes\n\nSetting bipartite = true is allowed only for PEPS evolution with up to next-nearest neighbor terms, and requires the input peps to have a unit cell size of (2, 2). \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.simultaneous_projectors-Union{Tuple{E}, Tuple{Array{E, 3}, CTMRGEnv, PEPSKit.ProjectorAlgorithm}} where E","page":"Library","title":"PEPSKit.simultaneous_projectors","text":"simultaneous_projectors(enlarged_corners::Array{E,3}, env::CTMRGEnv, alg::ProjectorAlgorithm)\nsimultaneous_projectors(coordinate, enlarged_corners::Array{E,3}, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :simultaneous scheme either for all provided enlarged corners or on a specific coordinate.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.str-Tuple{TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit.str","text":"str(t)\n\nFermionic supertrace by using @tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.su3site_iter-Union{Tuple{G}, Tuple{Union{InfinitePEPO, InfinitePEPS}, Vector{G}, SimpleUpdate, SUWeight}} where G<:(AbstractMatrix)","page":"Library","title":"PEPSKit.su3site_iter","text":"su3site_iter(state::InfinitePEPS, gatempos, alg::SimpleUpdate, env::SUWeight)\nsu3site_iter(densitymatrix::InfinitePEPO, gatempos, alg::SimpleUpdate, env::SUWeight; gate_bothsides::Bool = true)\n\nOne round of 3-site simple update, which applies the Trotter gate MPOs gatempos on an InfinitePEPS state or InfinitePEPO densitymatrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.su_iter-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, SimpleUpdate, SUWeight}","page":"Library","title":"PEPSKit.su_iter","text":"su_iter(state::InfinitePEPS, gate::LocalOperator, alg::SimpleUpdate, env::SUWeight; bipartite::Bool = false)\nsu_iter(densitymatrix::InfinitePEPO, gate::LocalOperator, alg::SimpleUpdate, env::SUWeight; gate_bothsides::Bool = true)\n\nOne round of simple update, which applies the nearest neighbor gate on an InfinitePEPS state or InfinitePEPO densitymatrix. When the input state has a unit cell size of (2, 2), one can set bipartite = true to enforce the bipartite structure. \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}","page":"Library","title":"PEPSKit.symmetrize!","text":"symmetrize!(peps::InfinitePEPS, ::SymmetrizationStyle)\n\nSymmetrize a PEPS using the given SymmetrizationStyle in-place.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize_retract_and_finalize!","page":"Library","title":"PEPSKit.symmetrize_retract_and_finalize!","text":"symmetrize_retract_and_finalize!(symm::SymmetrizationStyle, [retract, finalize!])\n\nReturn the retract and finalize! function for symmetrizing the peps and grad tensors.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.trace_physicalspaces-Tuple{TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.trace_physicalspaces","text":"trace_physicalspaces(O)\n\n\nTrace out the physical indices of a PEPO tensor, obtaining a partition function tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.trmul-Union{Tuple{N}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, N, N}, TensorKit.AbstractTensorMap{<:Any, S, N, N}}} where {S, N}","page":"Library","title":"PEPSKit.trmul","text":"trmul(H, ρ)\n\nCompute tr(H * ρ) without forming H * ρ.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.twistdual!-Tuple{TensorKit.AbstractTensorMap, Int64}","page":"Library","title":"PEPSKit.twistdual!","text":"twistdual(t::AbstractTensorMap, i)\ntwistdual!(t::AbstractTensorMap, i)\n\nTwist the i-th leg of a tensor t if it represents a dual space.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.tsvd-Tuple{Any, Any}","page":"Library","title":"TensorKit.tsvd","text":"PEPSKit.tsvd(t, alg::SVDAdjoint; trunc=notrunc(), p=2)\n\nWrapper around TensorKit.tsvd which dispatches on the alg argument. This is needed since a custom adjoint for PEPSKit.tsvd may be defined, depending on the algorithm. E.g., for IterSVD the adjoint for a truncated SVD from KrylovKit.svdsolve is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.@autoopt-Tuple{Any}","page":"Library","title":"PEPSKit.@autoopt","text":"autoopt(ex)\n\nPreprocessor macro for @tensor which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with d, D, or χ are automatically inserted with the corresponding costs.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@fwdthreads-Tuple{Any}","page":"Library","title":"PEPSKit.@fwdthreads","text":"@fwdthreads(ex)\n\nApply Threads.@threads only in the forward pass of the program.\n\nIt works by wrapping the for-loop expression in an if statement where in the forward pass the loop in computed in parallel using Threads.@threads, whereas in the backwards pass the Threads.@threads is omitted in order to make the expression differentiable.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@showtypeofgrad-Tuple{Any}","page":"Library","title":"PEPSKit.@showtypeofgrad","text":"@showtypeofgrad(x)\n\nMacro utility to show to type of the gradient that is about to accumulate for x.\n\nSee also Zygote.@showgrad.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.Defaults","page":"Library","title":"PEPSKit.Defaults","text":"module Defaults\n\nModule containing default algorithm parameter values and arguments.\n\nCTMRG\n\nctmrg_tol=1.0e-8 : Tolerance checking singular value and norm convergence.\nctmrg_maxiter=100 : Maximal number of CTMRG iterations per run.\nctmrg_miniter=4 : Minimal number of CTMRG carried out.\nctmrg_alg=:simultaneous : Default CTMRG algorithm variant.\n:simultaneous: Simultaneous expansion and renormalization of all sides.\n:sequential: Sequential application of left moves and rotations.\nctmrg_verbosity=2 : CTMRG output information verbosity\n\nSVD forward & reverse\n\ntrscheme=:fixedspace : Truncation scheme for SVDs and other decompositions.\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerr : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncdim : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:truncbelow : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nsvd_fwd_alg=:sdd : SVD algorithm that is used in the forward pass.\n:sdd: TensorKit's wrapper for LAPACK's _gesdd\n:svd: TensorKit's wrapper for LAPACK's _gesvd\n:iterative: Iterative SVD only computing the specifed number of singular values and vectors, see IterSVD\nsvd_rrule_tol=1.0e-8 : Accuracy of SVD reverse-rule.\nsvd_rrule_min_krylovdim=48 : Minimal Krylov dimension of the reverse-rule algorithm (if it is a Krylov algorithm).\nsvd_rrule_verbosity=-1 : SVD gradient output verbosity.\nsvd_rrule_alg=:full : Reverse-rule algorithm for the SVD gradient.\n:full: Uses a modified version of TensorKit's reverse-rule for tsvd which doesn't solve any linear problem and instead requires access to the full SVD, see PEPSKit.FullSVDReverseRule.\n:gmres: GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab: BiCGStab iterative linear solver, see the KrylovKit docs for details\n:arnoldi: Arnoldi Krylov algorithm, see the KrylovKit docs for details\nsvd_rrule_broadening=1.0e-13 : Lorentzian broadening amplitude which smoothens the divergent term in the SVD adjoint in case of (pseudo) degenerate singular values\n\nProjectors\n\nprojector_alg=:halfinfinite : Default variant of the CTMRG projector algorithm.\n:halfinfinite: Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.\n:fullinfinite: Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.\nprojector_verbosity=0 : Projector output information verbosity.\n\nFixed-point gradient\n\ngradient_tol=1.0e-6 : Convergence tolerance for the fixed-point gradient iteration.\ngradient_maxiter=30 : Maximal number of iterations for computing the CTMRG fixed-point gradient.\ngradient_verbosity=-1 : Gradient output information verbosity.\ngradient_linsolver=:bicgstab : Default linear solver for the LinSolver gradient algorithm.\n:gmres : GMRES iterative linear solver, see KrylovKit.GMRES for details\n:bicgstab : BiCGStab iterative linear solver, see KrylovKit.BiCGStab for details\ngradient_eigsolver=:arnoldi : Default eigensolver for the EigSolver gradient algorithm.\n:arnoldi : Arnoldi Krylov algorithm, see KrylovKit.Arnoldi for details\ngradient_eigsolver_eager=true : Enables EigSolver algorithm to finish before the full Krylov dimension is reached.\ngradient_iterscheme=:fixed : Scheme for differentiating one CTMRG iteration.\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\ngradient_alg=:eigsolver : Algorithm variant for computing the gradient fixed-point.\n\nOptimization\n\nreuse_env=true : If true, the current optimization step is initialized on the previous environment, otherwise a random environment is used.\noptimizer_tol=0.0001 : Gradient norm tolerance of the optimizer.\noptimizer_maxiter=100 : Maximal number of optimization steps.\noptimizer_verbosity=3 : Optimizer output information verbosity.\noptimizer_alg=:lbfgs : Default OptimKit.OptimizerAlgorithm for PEPS optimization.\n:gradientdescent : Gradient descent algorithm, see the OptimKit README\n:conjugategradient : Conjugate gradient algorithm, see the OptimKit README\n:lbfgs : L-BFGS algorithm, see the OptimKit README\nls_maxiter=10 : Maximum number of iterations for the line search in each step of the optimization.\nls_maxfg=20 : Maximum number of function evaluations for the line search in each step of the optimization.\nlbfgs_memory=20 : Size of limited memory representation of BFGS Hessian matrix.\n\nOhMyThreads scheduler\n\nscheduler=Ref{Scheduler}(...) : Multithreading scheduler which can be accessed via set_scheduler!.\n\n\n\n\n\n","category":"module"},{"location":"lib/lib/#PEPSKit.Defaults.set_scheduler!","page":"Library","title":"PEPSKit.Defaults.set_scheduler!","text":"set_scheduler!([scheduler]; kwargs...)\n\nSet OhMyThreads multithreading scheduler parameters.\n\nThe function either accepts a scheduler as an OhMyThreads.Scheduler or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via\n\nset_scheduler!(StaticScheduler(; ntasks=4, chunking=true))\n\nor equivalently with \n\nset_scheduler!(:static; ntasks=4, chunking=true)\n\nFor a detailed description of all schedulers and their keyword arguments consult the OhMyThreads documentation.\n\nIf no scheduler is passed and only kwargs are provided, the DynamicScheduler constructor is used with the provided kwargs.\n\nTo reset the scheduler to its default value, one calls set_scheduler! without passing arguments which then uses the default DynamicScheduler(). If the number of used threads is just one it falls back to SerialScheduler().\n\n\n\n\n\n","category":"function"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/fermi_hubbard/#Fermi-Hubbard-model-with-f\\mathbb{Z}_2-\\boxtimes-U(1)-symmetry,-at-large-U-and-half-filling","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"","category":"section"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"In this example, we will demonstrate how to handle fermionic PEPS tensors and how to optimize them. To that end, we consider the two-dimensional Hubbard model","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"H = -t sum_langle ij rangle sum_sigma left( c_isigma^+ c_jsigma^- -\nc_isigma^- c_jsigma^+ right) + U sum_i n_iuparrown_idownarrow - mu sum_i n_i","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"where sigma in uparrowdownarrow and n_isigma = c_isigma^+ c_isigma^- is the fermionic number operator. As in previous examples, using fermionic degrees of freedom is a matter of creating tensors with the right symmetry sectors - the rest of the simulation workflow remains the same.","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"First though, we make the example deterministic by seeding the RNG, and we make our imports:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"using Random\nusing TensorKit, PEPSKit\nusing MPSKit: add_physical_charge\nRandom.seed!(2928528937);","category":"page"},{"location":"examples/fermi_hubbard/#Defining-the-fermionic-Hamiltonian","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Defining the fermionic Hamiltonian","text":"","category":"section"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"Let us start by fixing the parameters of the Hubbard model. We're going to use a hopping of t=1 and a large U=8 on a 2 times 2 unit cell:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"t = 1.0\nU = 8.0\nlattice = InfiniteSquare(2, 2);","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"In order to create fermionic tensors, one needs to define symmetry sectors using TensorKit's FermionParity. Not only do we want use fermion parity but we also want our particles to exploit the global U(1) symmetry. The combined product sector can be obtained using the Deligne product, called through ⊠ which is obtained by typing \\boxtimes+TAB. We will not impose any extra spin symmetry, so we have:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"fermion = fℤ₂\nparticle_symmetry = U1Irrep\nspin_symmetry = Trivial\nS = fermion ⊠ particle_symmetry","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"TensorKitSectors.ProductSector{Tuple{TensorKitSectors.FermionParity, TensorKitSectors.U1Irrep}}","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"The next step is defining graded virtual PEPS and environment spaces using S. Here we also use the symmetry sector to impose half-filling. That is all we need to define the Hubbard Hamiltonian:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"D, χ = 1, 1\nV_peps = Vect[S]((0, 0) => 2 * D, (1, 1) => D, (1, -1) => D)\nV_env = Vect[S](\n    (0, 0) => 4 * χ, (1, -1) => 2 * χ, (1, 1) => 2 * χ, (0, 2) => χ, (0, -2) => χ\n)\nS_aux = S((1, 1))\nH₀ = hubbard_model(ComplexF64, particle_symmetry, spin_symmetry, lattice; t, U)\nH = add_physical_charge(H₀, fill(S_aux, size(H₀.lattice)...));","category":"page"},{"location":"examples/fermi_hubbard/#Finding-the-ground-state","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Finding the ground state","text":"","category":"section"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"Again, the procedure of ground state optimization is very similar to before. First, we define all algorithmic parameters:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"boundary_alg = (; tol = 1.0e-8, alg = :simultaneous, trscheme = (; alg = :fixedspace))\ngradient_alg = (; tol = 1.0e-6, alg = :eigsolver, maxiter = 10, iterscheme = :diffgauge)\noptimizer_alg = (; tol = 1.0e-4, alg = :lbfgs, maxiter = 80, ls_maxiter = 3, ls_maxfg = 3)","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"(tol = 0.0001, alg = :lbfgs, maxiter = 80, ls_maxiter = 3, ls_maxfg = 3)","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"Second, we initialize a PEPS state and environment (which we converge) constructed from symmetric physical and virtual spaces:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"physical_spaces = physicalspace(H)\nvirtual_spaces = fill(V_peps, size(lattice)...)\npeps₀ = InfinitePEPS(randn, ComplexF64, physical_spaces, virtual_spaces)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, V_env), peps₀; boundary_alg...);","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"[ Info: CTMRG init:\tobj = +5.484842275412e+04 +4.469243203539e+04im\terr = 1.0000e+00\n[ Info: CTMRG conv 26:\tobj = +8.371681846538e+04 -3.789700713241e-07im\terr = 7.4963851544e-09\ttime = 14.25 sec\n","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"And third, we start the ground state search (this does take quite long):","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"peps, env, E, info = fixedpoint(\n    H, peps₀, env₀; boundary_alg, gradient_alg, optimizer_alg, verbosity = 3\n)\n@show E;","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"[ Info: LBFGS: initializing with f = 6.680719803101, ‖∇f‖ = 9.5849e+00\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -1.49e-01, ϕ - ϕ₀ = -2.88e+00\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    1, time  874.29 s: f = 3.801380487744, ‖∇f‖ = 2.3456e+01, α = 2.50e+01, m = 0, nfg = 4\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -5.73e-03, ϕ - ϕ₀ = -3.81e+00\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/linesearches.jl:148\n[ Info: LBFGS: iter    2, time  963.43 s: f = -0.009727650286, ‖∇f‖ = 3.2049e+00, α = 2.50e+01, m = 0, nfg = 4\n[ Info: LBFGS: iter    3, time  977.14 s: f = -0.115210826428, ‖∇f‖ = 2.7846e+00, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    4, time  990.71 s: f = -0.616412169228, ‖∇f‖ = 2.3680e+00, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    5, time 1003.13 s: f = -0.817801148604, ‖∇f‖ = 1.9111e+00, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    6, time 1015.30 s: f = -0.990286615265, ‖∇f‖ = 2.3790e+00, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    7, time 1026.31 s: f = -1.142787566798, ‖∇f‖ = 1.5680e+00, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    8, time 1036.16 s: f = -1.238274330219, ‖∇f‖ = 3.5015e+00, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    9, time 1046.93 s: f = -1.438136282421, ‖∇f‖ = 1.3366e+00, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter   10, time 1056.67 s: f = -1.523107107396, ‖∇f‖ = 1.3496e+00, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   11, time 1077.81 s: f = -1.619305193101, ‖∇f‖ = 1.1951e+00, α = 1.72e-01, m = 9, nfg = 2\n[ Info: LBFGS: iter   12, time 1097.26 s: f = -1.681451834691, ‖∇f‖ = 9.4848e-01, α = 2.37e-01, m = 10, nfg = 2\n[ Info: LBFGS: iter   13, time 1107.99 s: f = -1.720734533825, ‖∇f‖ = 1.4216e+00, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   14, time 1117.66 s: f = -1.770831967062, ‖∇f‖ = 6.2747e-01, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   15, time 1127.31 s: f = -1.807572162185, ‖∇f‖ = 5.1320e-01, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   16, time 1138.09 s: f = -1.859768355558, ‖∇f‖ = 7.1320e-01, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   17, time 1147.68 s: f = -1.893160382125, ‖∇f‖ = 6.7323e-01, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   18, time 1157.44 s: f = -1.923092489408, ‖∇f‖ = 5.5419e-01, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   19, time 1168.12 s: f = -1.948142544093, ‖∇f‖ = 4.7661e-01, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   20, time 1177.91 s: f = -1.969512080077, ‖∇f‖ = 4.1608e-01, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   21, time 1187.87 s: f = -1.982557838199, ‖∇f‖ = 4.5138e-01, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   22, time 1198.67 s: f = -1.994007805763, ‖∇f‖ = 3.1538e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, time 1208.61 s: f = -2.002836016203, ‖∇f‖ = 3.0511e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, time 1218.59 s: f = -2.014062852739, ‖∇f‖ = 3.3491e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, time 1229.70 s: f = -2.022023251661, ‖∇f‖ = 4.3758e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, time 1239.66 s: f = -2.030112566345, ‖∇f‖ = 2.0509e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, time 1249.67 s: f = -2.035073683394, ‖∇f‖ = 1.6307e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, time 1261.85 s: f = -2.038663850455, ‖∇f‖ = 1.6880e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, time 1271.84 s: f = -2.041323592429, ‖∇f‖ = 2.4114e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, time 1281.66 s: f = -2.044997390530, ‖∇f‖ = 1.2115e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, time 1292.49 s: f = -2.046747469529, ‖∇f‖ = 9.5108e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, time 1302.32 s: f = -2.048741416292, ‖∇f‖ = 1.0509e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, time 1312.17 s: f = -2.049793769908, ‖∇f‖ = 1.7378e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, time 1323.04 s: f = -2.051022900848, ‖∇f‖ = 6.4055e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, time 1332.89 s: f = -2.051499900828, ‖∇f‖ = 4.9307e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, time 1342.73 s: f = -2.051918795787, ‖∇f‖ = 6.2013e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, time 1353.60 s: f = -2.052357188363, ‖∇f‖ = 9.4494e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, time 1363.45 s: f = -2.052855317283, ‖∇f‖ = 4.8219e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, time 1373.40 s: f = -2.053138284528, ‖∇f‖ = 3.5599e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, time 1384.12 s: f = -2.053404037719, ‖∇f‖ = 4.1844e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, time 1393.97 s: f = -2.053605747242, ‖∇f‖ = 5.7514e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, time 1403.69 s: f = -2.053822345457, ‖∇f‖ = 3.1996e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, time 1414.45 s: f = -2.054015631924, ‖∇f‖ = 3.1314e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, time 1424.21 s: f = -2.054206835742, ‖∇f‖ = 4.1588e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, time 1434.10 s: f = -2.054349141892, ‖∇f‖ = 6.7905e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   46, time 1444.85 s: f = -2.054531571463, ‖∇f‖ = 2.9227e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, time 1454.61 s: f = -2.054628027248, ‖∇f‖ = 2.5100e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, time 1464.37 s: f = -2.054735541814, ‖∇f‖ = 3.1538e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, time 1475.16 s: f = -2.054896782689, ‖∇f‖ = 3.4823e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, time 1494.75 s: f = -2.055018285181, ‖∇f‖ = 5.2680e-02, α = 5.17e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   51, time 1505.51 s: f = -2.055214629205, ‖∇f‖ = 3.0513e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, time 1515.33 s: f = -2.055401907932, ‖∇f‖ = 2.8740e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, time 1525.32 s: f = -2.055643036846, ‖∇f‖ = 4.1540e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, time 1536.28 s: f = -2.055979753449, ‖∇f‖ = 6.0310e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, time 1546.19 s: f = -2.056292876566, ‖∇f‖ = 6.4503e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   56, time 1556.12 s: f = -2.056764405334, ‖∇f‖ = 4.5709e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, time 1567.05 s: f = -2.057301128966, ‖∇f‖ = 5.8535e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, time 1577.08 s: f = -2.057684443651, ‖∇f‖ = 7.0407e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, time 1587.05 s: f = -2.058273607978, ‖∇f‖ = 6.4287e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, time 1598.01 s: f = -2.058991887288, ‖∇f‖ = 8.8941e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, time 1607.94 s: f = -2.059459011130, ‖∇f‖ = 1.1553e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   62, time 1617.89 s: f = -2.060066395726, ‖∇f‖ = 6.9440e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, time 1628.87 s: f = -2.060520108822, ‖∇f‖ = 8.4931e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, time 1648.98 s: f = -2.060815447626, ‖∇f‖ = 1.2115e-01, α = 5.26e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   65, time 1669.96 s: f = -2.060925751714, ‖∇f‖ = 8.3903e-02, α = 5.47e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   66, time 1679.97 s: f = -2.061209735729, ‖∇f‖ = 5.4010e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, time 1690.95 s: f = -2.061580165208, ‖∇f‖ = 5.5975e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, time 1701.12 s: f = -2.062036980891, ‖∇f‖ = 7.8898e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, time 1711.14 s: f = -2.062251708572, ‖∇f‖ = 1.1537e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, time 1722.19 s: f = -2.062519628412, ‖∇f‖ = 1.2953e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, time 1732.19 s: f = -2.063059957021, ‖∇f‖ = 7.2868e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, time 1742.20 s: f = -2.063313168886, ‖∇f‖ = 5.2530e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, time 1753.23 s: f = -2.063715484908, ‖∇f‖ = 5.0261e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, time 1763.31 s: f = -2.064332647622, ‖∇f‖ = 7.7210e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, time 1773.36 s: f = -2.064773364480, ‖∇f‖ = 1.2451e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, time 1784.47 s: f = -2.065371916869, ‖∇f‖ = 6.8015e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, time 1794.59 s: f = -2.065945928950, ‖∇f‖ = 7.6664e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, time 1804.62 s: f = -2.066640737009, ‖∇f‖ = 1.1191e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, time 1815.78 s: f = -2.067648349055, ‖∇f‖ = 2.3836e-01, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 80 iterations and time 1826.00 s: f = -2.069253135434, ‖∇f‖ = 2.0413e-01\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/lbfgs.jl:197\nE = -2.069253135433506\n","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"Finally, let's compare the obtained energy against a reference energy from a QMC study by Qin et al.. With the parameters specified above, they obtain an energy of E_textref approx 4 times -05244140625 = -209765625 (the factor 4 comes from the 2 times 2 unit cell that we use here). Thus, we find:","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"E_ref = -2.09765625\n@show (E - E_ref) / E_ref;","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"(E - E_ref) / E_ref = -0.013540404709539051\n","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"","category":"page"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/symmetries/#Symmetric-and-fermionic-tensors","page":"Symmetric and fermionic tensors","title":"Symmetric and fermionic tensors","text":"","category":"section"},{"location":"man/symmetries/","page":"Symmetric and fermionic tensors","title":"Symmetric and fermionic tensors","text":"note: Note\nThis section is still under construction.","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/heisenberg_su/#Simple-update-for-the-Heisenberg-model","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"","category":"section"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"In this example, we will use SimpleUpdate imaginary time evolution to treat the two-dimensional Heisenberg model once again:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"H = sum_langle ij rangle J_x S^x_i S^x_j + J_y S^y_i S^y_j + J_z S^z_i S^z_j","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"In order to simulate the antiferromagnetic order of the Hamiltonian on a single-site unit cell one typically applies a unitary sublattice rotation. Here, we will instead use a 2 times 2 unit cell and set J_x = J_y = J_z = 1.","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"Let's get started by seeding the RNG and importing all required modules:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"using Random\nimport Statistics: mean\nusing TensorKit, PEPSKit\nimport MPSKitModels: S_x, S_y, S_z, S_exchange\nRandom.seed!(0);","category":"page"},{"location":"examples/heisenberg_su/#Defining-the-Hamiltonian","page":"Simple update for the Heisenberg model","title":"Defining the Hamiltonian","text":"","category":"section"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"To construct the Heisenberg Hamiltonian as just discussed, we'll use heisenberg_XYZ and, in addition, make it real (real and imag works for LocalOperators) since we want to use PEPS and environments with real entries. We can either initialize the Hamiltonian with no internal symmetries (symm = Trivial) or use the global spin U(1) symmetry (symm = U1Irrep):","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"symm = Trivial ## ∈ {Trivial, U1Irrep}\nNr, Nc = 2, 2\nH = real(heisenberg_XYZ(ComplexF64, symm, InfiniteSquare(Nr, Nc); Jx = 1, Jy = 1, Jz = 1));","category":"page"},{"location":"examples/heisenberg_su/#Simple-updating","page":"Simple update for the Heisenberg model","title":"Simple updating","text":"","category":"section"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"We proceed by initializing a random PEPS that will be evolved. The weights used for simple update are initialized as identity matrices. First though, we need to define the appropriate (symmetric) spaces:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"Dbond = 4\nχenv = 16\nif symm == Trivial\n    physical_space = ℂ^2\n    bond_space = ℂ^Dbond\n    env_space = ℂ^χenv\nelseif symm == U1Irrep\n    physical_space = ℂ[U1Irrep](1 // 2 => 1, -1 // 2 => 1)\n    bond_space = ℂ[U1Irrep](0 => Dbond ÷ 2, 1 // 2 => Dbond ÷ 4, -1 // 2 => Dbond ÷ 4)\n    env_space = ℂ[U1Irrep](0 => χenv ÷ 2, 1 // 2 => χenv ÷ 4, -1 // 2 => χenv ÷ 4)\nelse\n    error(\"not implemented\")\nend\n\npeps = InfinitePEPS(rand, Float64, physical_space, bond_space; unitcell = (Nr, Nc));\nwts = SUWeight(peps);","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"Next, we can start the SimpleUpdate routine, successively decreasing the time intervals and singular value convergence tolerances. Note that TensorKit allows to combine SVD truncation schemes, which we use here to set a maximal bond dimension and at the same time fix a truncation error (if that can be reached by remaining below Dbond):","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"dts = [1.0e-2, 1.0e-3, 4.0e-4]\ntols = [1.0e-6, 1.0e-8, 1.0e-8]\nmaxiter = 10000\ntrscheme_peps = truncerr(1.0e-10) & truncdim(Dbond)\n\nfor (dt, tol) in zip(dts, tols)\n    alg = SimpleUpdate(dt, tol, maxiter, trscheme_peps)\n    global peps, wts, = simpleupdate(peps, H, alg, wts; bipartite = true)\nend","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 1.731e+00,  time = 16.560 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU conv 323    :  dt = 1e-02,  weight diff = 9.986e-07,  time = 21.354 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1      :  dt = 1e-03,  weight diff = 2.187e-03,  time = 0.004 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 500    :  dt = 1e-03,  weight diff = 2.420e-07,  time = 0.004 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1000   :  dt = 1e-03,  weight diff = 1.665e-08,  time = 0.004 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU conv 1098   :  dt = 1e-03,  weight diff = 9.958e-09,  time = 4.536 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1      :  dt = 4e-04,  weight diff = 1.442e-04,  time = 0.004 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 500    :  dt = 4e-04,  weight diff = 3.551e-08,  time = 0.004 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1000   :  dt = 4e-04,  weight diff = 1.159e-08,  time = 0.004 sec\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU conv 1068   :  dt = 4e-04,  weight diff = 9.987e-09,  time = 4.404 sec\n","category":"page"},{"location":"examples/heisenberg_su/#Computing-the-ground-state-energy-and-magnetizations","page":"Simple update for the Heisenberg model","title":"Computing the ground-state energy and magnetizations","text":"","category":"section"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"In order to compute observable expectation values, we need to converge a CTMRG environment on the evolved PEPS. Let's do so:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"normalize!.(peps.A, Inf)\nenv₀ = CTMRGEnv(rand, Float64, peps, env_space)\ntrscheme_env = truncerr(1.0e-10) & truncdim(χenv)\nenv, = leading_boundary(\n    env₀,\n    peps;\n    alg = :sequential,\n    projector_alg = :fullinfinite,\n    tol = 1.0e-10,\n    trscheme = trscheme_env,\n);","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"[ Info: CTMRG init:\tobj = +1.188518474239e-04\terr = 1.0000e+00\n[ Info: CTMRG conv 14:\tobj = +1.298574138984e+00\terr = 8.6101675686e-11\ttime = 5.39 sec\n","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"Finally, we'll measure the energy and different magnetizations. For the magnetizations, the plan is to compute the expectation values unit cell entry-wise in different spin directions:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"function compute_mags(peps::InfinitePEPS, env::CTMRGEnv)\n    lattice = collect(space(t, 1) for t in peps.A)\n\n    # detect symmetry on physical axis\n    symm = sectortype(space(peps.A[1, 1]))\n    if symm == Trivial\n        S_ops = real.([S_x(symm), im * S_y(symm), S_z(symm)])\n    elseif symm == U1Irrep\n        S_ops = real.([S_z(symm)]) ## only Sz preserves <Sz>\n    end\n\n    return map(Iterators.product(axes(peps, 1), axes(peps, 2), S_ops)) do (r, c, S)\n        expectation_value(peps, LocalOperator(lattice, (CartesianIndex(r, c),) => S), env)\n    end\nend\n\nE = expectation_value(peps, H, env) / (Nr * Nc)\nMs = compute_mags(peps, env)\nM_norms = map(\n    rc -> norm(Ms[rc[1], rc[2], :]), Iterators.product(axes(peps, 1), axes(peps, 2))\n)\n@show E Ms M_norms;","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"E = -0.6674725905835921\nMs = [0.028455537297763654 -0.026889489648298712; -0.026889489681467996 0.028455537252025265;;; 1.060553381226903e-11 -4.813673765147186e-12; -9.758601912657205e-12 3.9884293784320235e-12;;; 0.37587672522461946 -0.3759920019289313; -0.3759920019256273 0.3758767252290504]\nM_norms = [0.37695229163448324 0.37695229163393; 0.3769522916330006 0.37695229163544886]\n","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"To assess the results, we will benchmark against data from Corboz, which use manual gradients to perform a variational optimization of the Heisenberg model. In particular, for the energy and magnetization they find E_textref = -06675 and M_textref = 03767. Looking at the relative errors, we find general agreement, although the accuracy is limited by the methodological limitations of the simple update algorithm as well as finite bond dimension effects and a lacking extrapolation:","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"E_ref = -0.6675\nM_ref = 0.3767\n@show (E - E_ref) / abs(E_ref)\n@show (mean(M_norms) - M_ref) / M_ref;","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"(E - E_ref) / abs(E_ref) = 4.106279611668376e-5\n(mean(M_norms) - M_ref) / M_ref = 0.0006697415296408165\n","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"","category":"page"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/heisenberg/#examples_heisenberg","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"In this example we want to provide a basic rundown of PEPSKit's optimization workflow for PEPS. To that end, we will consider the two-dimensional Heisenberg model on a square lattice","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"H = sum_langle ij rangle left ( J_x S^x_i S^x_j + J_y S^y_i S^y_j + J_z S^z_i S^z_j right )","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Here, we want to set J_x = J_y = J_z = 1 where the Heisenberg model is in the antiferromagnetic regime. Due to the bipartite sublattice structure of antiferromagnetic order one needs a PEPS ansatz with a 2 times 2 unit cell. This can be circumvented by performing a unitary sublattice rotation on all B-sites resulting in a change of parameters to (J_x J_y J_z)=(-1 1 -1). This gives us a unitarily equivalent Hamiltonian (with the same spectrum) with a ground state on a single-site unit cell.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Let us get started by fixing the random seed of this example to make it deterministic:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"using Random\nRandom.seed!(123456789);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"We're going to need only two packages: TensorKit, since we use that for all the underlying tensor operations, and PEPSKit itself. So let us import these:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"using TensorKit, PEPSKit","category":"page"},{"location":"examples/heisenberg/#Defining-the-Heisenberg-Hamiltonian","page":"Optimizing the 2D Heisenberg model","title":"Defining the Heisenberg Hamiltonian","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"To create the sublattice rotated Heisenberg Hamiltonian on an infinite square lattice, we use the heisenberg_XYZ method from MPSKitModels which is redefined for the InfiniteSquare and reexported in PEPSKit:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"H = heisenberg_XYZ(InfiniteSquare(); Jx = -1, Jy = 1, Jz = -1)","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"LocalOperator{Tuple{Pair{Tuple{CartesianIndex{2}, CartesianIndex{2}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}, Pair{Tuple{CartesianIndex{2}, CartesianIndex{2}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}}, TensorKit.ComplexSpace}(TensorKit.ComplexSpace[ℂ^2;;], ((CartesianIndex(1, 1), CartesianIndex(1, 2)) => TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):\n[:, :, 1, 1] =\n -0.25 + 0.0im   0.0 + 0.0im\n   0.0 + 0.0im  -0.5 + 0.0im\n\n[:, :, 2, 1] =\n  0.0 + 0.0im  0.0 + 0.0im\n 0.25 + 0.0im  0.0 + 0.0im\n\n[:, :, 1, 2] =\n 0.0 + 0.0im  0.25 + 0.0im\n 0.0 + 0.0im   0.0 + 0.0im\n\n[:, :, 2, 2] =\n -0.5 + 0.0im    0.0 + 0.0im\n  0.0 + 0.0im  -0.25 + 0.0im\n, (CartesianIndex(1, 1), CartesianIndex(2, 1)) => TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):\n[:, :, 1, 1] =\n -0.25 + 0.0im   0.0 + 0.0im\n   0.0 + 0.0im  -0.5 + 0.0im\n\n[:, :, 2, 1] =\n  0.0 + 0.0im  0.0 + 0.0im\n 0.25 + 0.0im  0.0 + 0.0im\n\n[:, :, 1, 2] =\n 0.0 + 0.0im  0.25 + 0.0im\n 0.0 + 0.0im   0.0 + 0.0im\n\n[:, :, 2, 2] =\n -0.5 + 0.0im    0.0 + 0.0im\n  0.0 + 0.0im  -0.25 + 0.0im\n))","category":"page"},{"location":"examples/heisenberg/#Setting-up-the-algorithms-and-initial-guesses","page":"Optimizing the 2D Heisenberg model","title":"Setting up the algorithms and initial guesses","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Next, we set the simulation parameters. During optimization, the PEPS will be contracted using CTMRG and the PEPS gradient will be computed by differentiating through the CTMRG routine using AD. Since the algorithmic stack that implements this is rather elaborate, the amount of settings one can configure is also quite large. To reduce this complexity, PEPSKit defaults to (presumably) reasonable settings which also dynamically adapts to the user-specified parameters.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"First, we set the bond dimension Dbond of the virtual PEPS indices and the environment dimension χenv of the virtual corner and transfer matrix indices.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Dbond = 2\nχenv = 16;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"To configure the CTMRG algorithm, we create a NamedTuple containing different keyword arguments. To see a description of all arguments, see the docstring of leading_boundary. Here, we want to converge the CTMRG environments up to a specific tolerance and during the CTMRG run keep all index dimensions fixed:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"boundary_alg = (; tol = 1.0e-10, trscheme = (; alg = :fixedspace));","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Let us also configure the optimizer algorithm. We are going to optimize the PEPS using the L-BFGS optimizer from OptimKit. Again, we specify the convergence tolerance (for the gradient norm) as well as the maximal number of iterations and the BFGS memory size (which is used to approximate the Hessian):","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"optimizer_alg = (; alg = :lbfgs, tol = 1.0e-4, maxiter = 100, lbfgs_memory = 16);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Additionally, during optimization, we want to reuse the previous CTMRG environment to initialize the CTMRG run of the current optimization step using the reuse_env argument. And to control the output information, we set the verbosity:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"reuse_env = true\nverbosity = 3;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Next, we initialize a random PEPS which will be used as an initial guess for the optimization. To get a PEPS with physical dimension 2 (since we have a spin-1/2 Hamiltonian) with complex-valued random Gaussian entries, we set:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"peps₀ = InfinitePEPS(randn, ComplexF64, 2, Dbond)","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}[TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')):\n[:, :, 1, 1, 1] =\n 0.07382174258286094 + 0.12820373667088403im   0.7897519397510839 + 0.9113654266438473im\n  0.2553716885006697 - 0.4358399804354269im   -1.0272416446076236 - 0.12635062198157215im\n\n[:, :, 2, 1, 1] =\n 0.16833628450178303 - 0.10088950122180829im  -0.9702030532300809 + 0.010730752411986726im\n -1.6804460553576506 + 0.29081053879369084im   0.6844811667615024 + 0.09101537356941222im\n\n[:, :, 1, 2, 1] =\n  0.5085938050744258 + 0.3786892551842583im   1.0020057959636561 - 1.4704891009758718im\n -0.6153328223084331 + 0.10417896606055738im  0.6024931811537675 - 1.0348374874397468im\n\n[:, :, 2, 2, 1] =\n -0.027201695938305456 + 0.5778042099380925im  0.09232089635078945 + 0.6143070126937361im\n    1.0707115218777772 - 0.5747168579241235im  -0.5819741818511422 - 0.9842624134267605im\n\n[:, :, 1, 1, 2] =\n 1.2332543810053822 - 1.7783531996396438im  0.8887723728085348 + 0.7809798723615474im\n 1.2251189302516847 - 0.6853683793073324im  1.5333834584675397 - 0.13856216581406375im\n\n[:, :, 2, 1, 2] =\n 0.1406381347783769 + 0.6630243440357264im   -0.7294596235434386 + 0.40327909254711103im\n 0.7212056487788236 + 0.24320971945037498im   0.9991347929322827 + 0.0017902515981375842im\n\n[:, :, 1, 2, 2] =\n 0.34282910982693904 - 0.4865238029567361im   0.9380949844871762 - 0.6985342237892025im\n -0.7437083517319159 - 0.6895708849529253im  -0.8981092940164176 + 0.9720706252141459im\n\n[:, :, 2, 2, 2] =\n -0.8897079923413616 - 0.7145412189457411im  0.07771261045117502 - 0.6400190994609709im\n -1.6099412157243007 + 0.8855200965611144im   0.7357380595021633 + 0.4626916850143416im\n;;])","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"The last thing we need before we can start the optimization is an initial CTMRG environment. Typically, a random environment which we converge on peps₀ serves as a good starting point. To contract a PEPS starting from an environment using CTMRG, we call leading_boundary:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"env_random = CTMRGEnv(randn, ComplexF64, peps₀, ℂ^χenv);\nenv₀, info_ctmrg = leading_boundary(env_random, peps₀; boundary_alg...);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"[ Info: CTMRG init:\tobj = -2.749614463601e+00 +3.639628057806e+00im\terr = 1.0000e+00\n[ Info: CTMRG conv 27:\tobj = +9.727103564786e+00\terr = 2.6201801020e-11\ttime = 0.22 sec\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Besides the converged environment, leading_boundary also returns a NamedTuple of informational quantities such as the last maximal truncation error - that is, the SVD approximation error incurred in the last CTMRG iteration, maximized over all spatial directions and unit cell entries:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"@show info_ctmrg.truncation_error;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"info_ctmrg.truncation_error = 0.000807633282421865\n","category":"page"},{"location":"examples/heisenberg/#Ground-state-search","page":"Optimizing the 2D Heisenberg model","title":"Ground state search","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Finally, we can start the optimization by calling fixedpoint on H with our settings for the boundary (CTMRG) algorithm and the optimizer. This might take a while (especially the precompilation of AD code in this case):","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"peps, env, E, info_opt = fixedpoint(\n    H, peps₀, env₀; boundary_alg, optimizer_alg, reuse_env, verbosity\n);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"[ Info: LBFGS: initializing with f = 0.000601645310, ‖∇f‖ = 9.3547e-01\n[ Info: LBFGS: iter    1, time  653.26 s: f = -0.489780489234, ‖∇f‖ = 6.0028e-01, α = 5.94e+01, m = 0, nfg = 5\n[ Info: LBFGS: iter    2, time  654.02 s: f = -0.501969351328, ‖∇f‖ = 5.3739e-01, α = 2.80e-01, m = 1, nfg = 2\n[ Info: LBFGS: iter    3, time  654.40 s: f = -0.523150649702, ‖∇f‖ = 3.9920e-01, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, time  655.20 s: f = -0.538654553217, ‖∇f‖ = 4.1550e-01, α = 2.29e-01, m = 3, nfg = 2\n[ Info: LBFGS: iter    5, time  657.28 s: f = -0.549895529711, ‖∇f‖ = 4.4023e-01, α = 6.96e-02, m = 4, nfg = 4\n[ Info: LBFGS: iter    6, time  658.20 s: f = -0.568903885964, ‖∇f‖ = 4.8252e-01, α = 2.23e-01, m = 5, nfg = 2\n[ Info: LBFGS: iter    7, time  658.58 s: f = -0.586868365051, ‖∇f‖ = 4.2836e-01, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    8, time  658.96 s: f = -0.599839175727, ‖∇f‖ = 2.2069e-01, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter    9, time  659.33 s: f = -0.606610941341, ‖∇f‖ = 1.9251e-01, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   10, time  659.69 s: f = -0.624864467621, ‖∇f‖ = 2.9516e-01, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, time  660.04 s: f = -0.638376467572, ‖∇f‖ = 2.3674e-01, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, time  660.39 s: f = -0.644410588164, ‖∇f‖ = 3.2330e-01, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, time  660.71 s: f = -0.651444381192, ‖∇f‖ = 1.3176e-01, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, time  661.05 s: f = -0.654528265227, ‖∇f‖ = 6.6190e-02, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, time  661.39 s: f = -0.655971175652, ‖∇f‖ = 5.1869e-02, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, time  661.72 s: f = -0.657229077727, ‖∇f‖ = 5.8976e-02, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, time  662.06 s: f = -0.658532053807, ‖∇f‖ = 5.5534e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, time  662.40 s: f = -0.659295183671, ‖∇f‖ = 3.0535e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   19, time  662.73 s: f = -0.659542164961, ‖∇f‖ = 2.2302e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   20, time  663.05 s: f = -0.659738061987, ‖∇f‖ = 2.7531e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   21, time  663.38 s: f = -0.659907342873, ‖∇f‖ = 1.9373e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   22, time  663.73 s: f = -0.660097470227, ‖∇f‖ = 1.4408e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   23, time  664.05 s: f = -0.660262757053, ‖∇f‖ = 1.2375e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   24, time  664.39 s: f = -0.660393125905, ‖∇f‖ = 1.9300e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   25, time  664.72 s: f = -0.660497546366, ‖∇f‖ = 1.3215e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   26, time  665.04 s: f = -0.660574185878, ‖∇f‖ = 1.2473e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   27, time  665.39 s: f = -0.660741803152, ‖∇f‖ = 1.6340e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   28, time  665.75 s: f = -0.660903655648, ‖∇f‖ = 1.8796e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   29, time  666.10 s: f = -0.661017363978, ‖∇f‖ = 1.3066e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   30, time  666.45 s: f = -0.661073166057, ‖∇f‖ = 8.0202e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   31, time  666.80 s: f = -0.661117738290, ‖∇f‖ = 7.9517e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   32, time  667.99 s: f = -0.661172741238, ‖∇f‖ = 9.8830e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   33, time  668.32 s: f = -0.661193956739, ‖∇f‖ = 1.5397e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   34, time  668.72 s: f = -0.661227726765, ‖∇f‖ = 5.4743e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   35, time  669.07 s: f = -0.661241731905, ‖∇f‖ = 4.7251e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   36, time  669.42 s: f = -0.661255581390, ‖∇f‖ = 5.4063e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   37, time  669.74 s: f = -0.661264752007, ‖∇f‖ = 1.3807e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   38, time  670.08 s: f = -0.661283616258, ‖∇f‖ = 5.9652e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   39, time  670.40 s: f = -0.661291824999, ‖∇f‖ = 4.3576e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   40, time  670.74 s: f = -0.661304230051, ‖∇f‖ = 6.0191e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   41, time  671.08 s: f = -0.661331508375, ‖∇f‖ = 1.1163e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   42, time  671.43 s: f = -0.661376470938, ‖∇f‖ = 1.2657e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   43, time  671.79 s: f = -0.661468673389, ‖∇f‖ = 2.1031e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   44, time  672.15 s: f = -0.661514982560, ‖∇f‖ = 3.2277e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   45, time  672.52 s: f = -0.661747546318, ‖∇f‖ = 2.1689e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   46, time  672.87 s: f = -0.661905953148, ‖∇f‖ = 1.6677e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   47, time  673.23 s: f = -0.662062528550, ‖∇f‖ = 1.6193e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   48, time  673.58 s: f = -0.662213957905, ‖∇f‖ = 2.0197e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   49, time  673.95 s: f = -0.662326044624, ‖∇f‖ = 1.8366e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   50, time  674.32 s: f = -0.662393005733, ‖∇f‖ = 1.1551e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   51, time  674.68 s: f = -0.662429954725, ‖∇f‖ = 1.0083e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   52, time  675.04 s: f = -0.662449363090, ‖∇f‖ = 1.3903e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   53, time  675.40 s: f = -0.662477942405, ‖∇f‖ = 6.7608e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   54, time  675.76 s: f = -0.662486360536, ‖∇f‖ = 3.8704e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   55, time  676.11 s: f = -0.662492546495, ‖∇f‖ = 3.5233e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   56, time  676.45 s: f = -0.662497882956, ‖∇f‖ = 6.1259e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   57, time  676.81 s: f = -0.662502369825, ‖∇f‖ = 2.9147e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   58, time  677.17 s: f = -0.662504348191, ‖∇f‖ = 2.1731e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   59, time  677.52 s: f = -0.662507141108, ‖∇f‖ = 1.8340e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   60, time  677.87 s: f = -0.662508298294, ‖∇f‖ = 4.6222e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   61, time  678.24 s: f = -0.662510158234, ‖∇f‖ = 1.5689e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   62, time  678.57 s: f = -0.662510768904, ‖∇f‖ = 9.6230e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   63, time  678.93 s: f = -0.662511246489, ‖∇f‖ = 8.8002e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   64, time  679.26 s: f = -0.662511761487, ‖∇f‖ = 1.6668e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   65, time  679.59 s: f = -0.662512148273, ‖∇f‖ = 7.9766e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   66, time  679.92 s: f = -0.662512357751, ‖∇f‖ = 6.8594e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   67, time  680.26 s: f = -0.662512976280, ‖∇f‖ = 7.1623e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   68, time  680.93 s: f = -0.662513222472, ‖∇f‖ = 1.0991e-03, α = 4.99e-01, m = 16, nfg = 2\n[ Info: LBFGS: iter   69, time  681.26 s: f = -0.662513507229, ‖∇f‖ = 5.7699e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   70, time  681.60 s: f = -0.662513689584, ‖∇f‖ = 4.2137e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   71, time  681.94 s: f = -0.662513825899, ‖∇f‖ = 6.8079e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   72, time  682.27 s: f = -0.662513929736, ‖∇f‖ = 4.8212e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   73, time  682.60 s: f = -0.662514019314, ‖∇f‖ = 3.6338e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   74, time  682.94 s: f = -0.662514148429, ‖∇f‖ = 3.7588e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   75, time  683.59 s: f = -0.662514184144, ‖∇f‖ = 4.0858e-04, α = 3.36e-01, m = 16, nfg = 2\n[ Info: LBFGS: iter   76, time  683.94 s: f = -0.662514214340, ‖∇f‖ = 2.6812e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   77, time  684.27 s: f = -0.662514236095, ‖∇f‖ = 1.7703e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   78, time  684.60 s: f = -0.662514249499, ‖∇f‖ = 1.8355e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   79, time  684.92 s: f = -0.662514261393, ‖∇f‖ = 1.2213e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   80, time  685.25 s: f = -0.662514269951, ‖∇f‖ = 2.1828e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   81, time  685.59 s: f = -0.662514275813, ‖∇f‖ = 1.6011e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: converged after 82 iterations and time 685.90 s: f = -0.662514279390, ‖∇f‖ = 9.7855e-05\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Note that fixedpoint returns the final optimized PEPS, the last converged environment, the final energy estimate as well as a NamedTuple of diagnostics. This allows us to, e.g., analyze the number of cost function calls or the history of gradient norms to evaluate the convergence rate:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"@show info_opt.fg_evaluations info_opt.gradnorms[1:10:end];","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"info_opt.fg_evaluations = 95\ninfo_opt.gradnorms[1:10:end] = [0.9354703925772283, 0.29515809534278165, 0.02753139081589741, 0.008020152153989112, 0.0060190768119257575, 0.011551265856046971, 0.004622157491340677, 0.00042136817837828673, 0.00021828441953116996]\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Let's now compare the optimized energy against an accurate Quantum Monte Carlo estimate by Sandvik, where the energy per site was found to be E_textref=06694421. From our simple optimization we find:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"@show E;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"E = -0.6625142793898271\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"While this energy is in the right ballpark, there is still quite some deviation from the accurate reference energy. This, however, can be attributed to the small bond dimension - an optimization with larger bond dimension would approach this value much more closely.","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"A more reasonable comparison would be against another finite bond dimension PEPS simulation. For example, Juraj Hasik's data from J_1text-J_2 PEPS simulations yields E_D=2chi=16=-0660231dots which is more in line with what we find here.","category":"page"},{"location":"examples/heisenberg/#Compute-the-correlation-lengths-and-transfer-matrix-spectra","page":"Optimizing the 2D Heisenberg model","title":"Compute the correlation lengths and transfer matrix spectra","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"In practice, in order to obtain an accurate and variational energy estimate, one would need to compute multiple energies at different environment dimensions and extrapolate in, e.g., the correlation length or the second gap of the transfer matrix spectrum. For that, we would need the correlation_length function, which computes the horizontal and vertical correlation lengths and transfer matrix spectra for all unit cell coordinates:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"ξ_h, ξ_v, λ_h, λ_v = correlation_length(peps, env)\n@show ξ_h ξ_v;","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"ξ_h = [1.0343546234867007]\nξ_v = [1.024223131377083]\n","category":"page"},{"location":"examples/heisenberg/#Computing-observables","page":"Optimizing the 2D Heisenberg model","title":"Computing observables","text":"","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"As a last thing, we want to see how we can compute expectation values of observables, given the optimized PEPS and its CTMRG environment. To compute, e.g., the magnetization, we first need to define the observable as a TensorMap:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"σ_z = TensorMap([1.0 0.0; 0.0 -1.0], ℂ^2, ℂ^2)","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"TensorMap(ℂ^2 ← ℂ^2):\n 1.0   0.0\n 0.0  -1.0\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"In order to be able to contract it with the PEPS and environment, we define need to define a LocalOperator and specify on which physical spaces and sites the observable acts. That way, the PEPS-environment-operator contraction gets automatically generated (also works for multi-site operators!). See the LocalOperator docstring for more details. The magnetization is just a single-site observable, so we have:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"M = LocalOperator(fill(ℂ^2, 1, 1), (CartesianIndex(1, 1),) => σ_z)","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"LocalOperator{Tuple{Pair{Tuple{CartesianIndex{2}}, TensorKit.TensorMap{Float64, TensorKit.ComplexSpace, 1, 1, Vector{Float64}}}}, TensorKit.ComplexSpace}(TensorKit.ComplexSpace[ℂ^2;;], ((CartesianIndex(1, 1),) => TensorMap(ℂ^2 ← ℂ^2):\n 1.0   0.0\n 0.0  -1.0\n,))","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"Finally, to evaluate the expecation value on the LocalOperator, we call:","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"@show expectation_value(peps, M, env);","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"expectation_value(peps, M, env) = -0.755066246984657 - 1.0408340855860843e-16im\n","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"","category":"page"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/environments/#Environments","page":"Environments","title":"Environments","text":"","category":"section"},{"location":"man/environments/","page":"Environments","title":"Environments","text":"note: Note\nThis section is still under construction.","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/2d_ising_partition_function/#e_2d_ising","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"","category":"section"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"While PEPSKit has a lot of use in quantum systems, describing states using InfinitePEPS that can be contracted via CTMRG or boundary MPS techniques, here we shift our focus to classical physics. We consider the 2D classical Ising model and compute its partition function defined as:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"mathcalZ(beta) = sum_s exp(-beta H(s)) text with  H(s) = -J sum_langle i j rangle s_i s_j ","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"where the classical spins s_i in +1 -1 are located on the vertices i of a 2D square lattice. The idea is to encode the partition function as an infinite square network consisting of local rank-4 tensors, which can then be contracted using CTMRG. An infinite square network of these rank-4 tensors can be represented as an InfinitePartitionFunction object, as we will see.","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"But first, let's seed the RNG and import all required modules:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"using Random, LinearAlgebra\nusing TensorKit, PEPSKit\nusing QuadGK\nRandom.seed!(234923);","category":"page"},{"location":"examples/2d_ising_partition_function/#Defining-the-partition-function","page":"The 2D classical Ising model using CTMRG","title":"Defining the partition function","text":"","category":"section"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"The first step is to define the rank-4 tensor that, when contracted on a square lattice, evaluates to the partition function value at a given beta. This is done through a fairly generic procedure where the interaction weights are distributed among vertex tensors in an appropriate way. Concretely, here we first define a 'link' matrix containing the Boltzmann weights associated to all possible spin configurations across a given link on the lattice. Next, we define site tensors as delta-tensors that ensiure that the spin value on all adjacent links is the same. Since we only want tensors on the sites in the end, we can symmetrically absorb the link weight tensors into the site tensors, which gives us exactly the kind of network we're looking for. Since we later want to compute the magnetization and energy to check our results, we define the appropriate rank-4 tensors here as well while we're at it.","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"function classical_ising(; beta = log(1 + sqrt(2)) / 2, J = 1.0)\n    K = beta * J\n\n    # Boltzmann weights\n    t = ComplexF64[exp(K) exp(-K); exp(-K) exp(K)]\n    r = eigen(t)\n    nt = r.vectors * sqrt(Diagonal(r.values)) * r.vectors\n\n    # local partition function tensor\n    O = zeros(2, 2, 2, 2)\n    O[1, 1, 1, 1] = 1\n    O[2, 2, 2, 2] = 1\n    @tensor o[-1 -2; -3 -4] := O[3 4; 2 1] * nt[-3; 3] * nt[-4; 4] * nt[-2; 2] * nt[-1; 1]\n\n    # magnetization tensor\n    M = copy(O)\n    M[2, 2, 2, 2] *= -1\n    @tensor m[-1 -2; -3 -4] := M[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * nt[-3; 3] * nt[-4; 4]\n\n    # bond interaction tensor and energy-per-site tensor\n    e = ComplexF64[-J J; J -J] .* nt\n    @tensor e_hor[-1 -2; -3 -4] :=\n        O[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * nt[-3; 3] * e[-4; 4]\n    @tensor e_vert[-1 -2; -3 -4] :=\n        O[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * e[-3; 3] * nt[-4; 4]\n    e = e_hor + e_vert\n\n    # fixed tensor map space for all three\n    TMS = ℂ^2 ⊗ ℂ^2 ← ℂ^2 ⊗ ℂ^2\n\n    return TensorMap(o, TMS), TensorMap(m, TMS), TensorMap(e, TMS)\nend;","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"So let's initialize these tensors at inverse temperature beta=06, check that they are indeed rank-4 and construct the corresponding InfinitePartitionFunction:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"beta = 0.6\nO, M, E = classical_ising(; beta)\n@show space(O)\nZ = InfinitePartitionFunction(O)","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"InfinitePartitionFunction{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}[TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):\n[:, :, 1, 1] =\n  3.169519816780443 + 0.0im  0.4999999999999995 + 0.0im\n 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im\n\n[:, :, 2, 1] =\n 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im\n 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im\n\n[:, :, 1, 2] =\n 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im\n 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im\n\n[:, :, 2, 2] =\n 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im\n 0.4999999999999995 + 0.0im   3.169519816780443 + 0.0im\n;;])","category":"page"},{"location":"examples/2d_ising_partition_function/#Contracting-the-partition-function","page":"The 2D classical Ising model using CTMRG","title":"Contracting the partition function","text":"","category":"section"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"Next, we can contract the partition function as per usual by constructing a CTMRGEnv with a specified environment virtual space and calling leading_boundary with appropriate settings:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"Venv = ℂ^20\nenv₀ = CTMRGEnv(Z, Venv)\nenv, = leading_boundary(env₀, Z; tol = 1.0e-8, maxiter = 500);","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"[ Info: CTMRG init:\tobj = +1.784252138312e+00 -1.557258880375e+00im\terr = 1.0000e+00\n[ Info: CTMRG conv 63:\tobj = +3.353928644031e+00\terr = 4.6032264022e-09\ttime = 5.74 sec\n","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"Note that CTMRG environments for partition functions differ from the PEPS environments only by the edge tensors. Instead of two legs connecting the edges and the PEPS-PEPS sandwich, there is only one leg connecting the edges and the partition function tensor, meaning that the edge tensors are now rank-3:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"space.(env.edges)","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"4×1×1 Array{TensorKit.TensorMapSpace{TensorKit.ComplexSpace, 2, 1}, 3}:\n[:, :, 1] =\n (ℂ^20 ⊗ ℂ^2) ← ℂ^20\n (ℂ^20 ⊗ ℂ^2) ← ℂ^20\n (ℂ^20 ⊗ (ℂ^2)') ← ℂ^20\n (ℂ^20 ⊗ (ℂ^2)') ← ℂ^20","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"To compute the value of the partition function, we have to contract Z with the converged environment using network_value. Additionally, we will compute the magnetization and energy (per site), again using expectation_value but this time also specifying the index in the unit cell where we want to insert the local tensor:","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"λ = network_value(Z, env)\nm = expectation_value(Z, (1, 1) => M, env)\ne = expectation_value(Z, (1, 1) => E, env)\n@show λ m e;","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"λ = 3.353928644031378 + 7.047583922370844e-16im\nm = 0.9736086674403002 + 0.0im\ne = -1.8637796145082448 + 1.4610281815259345e-16im\n","category":"page"},{"location":"examples/2d_ising_partition_function/#Comparing-against-the-exact-Onsager-solution","page":"The 2D classical Ising model using CTMRG","title":"Comparing against the exact Onsager solution","text":"","category":"section"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"In order to assess our results, we will compare against the exact Onsager solution of the 2D classical Ising model. To that end, we compute the exact free energy, magnetization and energy per site (where we use quadgk to perform integrals of an auxiliary variable from 0 to pi2):","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"function classical_ising_exact(; beta = log(1 + sqrt(2)) / 2, J = 1.0)\n    K = beta * J\n\n    k = 1 / sinh(2 * K)^2\n    F = quadgk(\n        theta -> log(cosh(2 * K)^2 + 1 / k * sqrt(1 + k^2 - 2 * k * cos(2 * theta))), 0, pi\n    )[1]\n    f = -1 / beta * (log(2) / 2 + 1 / (2 * pi) * F)\n\n    m = 1 - (sinh(2 * K))^(-4) > 0 ? (1 - (sinh(2 * K))^(-4))^(1 / 8) : 0\n\n    E = quadgk(theta -> 1 / sqrt(1 - (4 * k) * (1 + k)^(-2) * sin(theta)^2), 0, pi / 2)[1]\n    e = -J * cosh(2 * K) / sinh(2 * K) * (1 + 2 / pi * (2 * tanh(2 * K)^2 - 1) * E)\n\n    return f, m, e\nend\n\nf_exact, m_exact, e_exact = classical_ising_exact(; beta);","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"And indeed, we do find agreement between the exact and CTMRG values (keeping in mind that energy accuracy is limited by the environment dimension and the lack of proper extrapolation):","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"@show (-log(λ) / beta - f_exact) / f_exact\n@show (abs(m) - abs(m_exact)) / abs(m_exact)\n@show (e - e_exact) / e_exact;","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"(-(log(λ)) / beta - f_exact) / f_exact = -8.807417386354037e-16 + 1.736415096112634e-16im\n(abs(m) - abs(m_exact)) / abs(m_exact) = -3.420952570843561e-16\n(e - e_exact) / e_exact = -0.02373206809908996 - 7.653023727290916e-17im\n","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"","category":"page"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/multithreading/#Multithreading","page":"Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"man/multithreading/","page":"Multithreading","title":"Multithreading","text":"Before detailing the multithreading capabilities of PEPSKit, there are some general remarks to be made about parallelism in Julia. In particular, it is important to know the interaction of Julia threads and BLAS threads, and that the BLAS thread behavior is inconsistent among different vendors. Since these details have been explained many times elsewhere, we here want to point towards the MPSKit docs, which provide a good rundown of the threading behavior and what to be aware of.","category":"page"},{"location":"man/multithreading/","page":"Multithreading","title":"Multithreading","text":"PEPSKit's multithreading features are provided through OhMyThreads.jl. In addition, we also supply a differentiable parallel map, which parallelizes not only the forward pass but also the reverse pass of the map application, see PEPSKit.dtmap. The threading behaviour can be specified through a global scheduler that is interfaced through the set_scheduler! function:","category":"page"},{"location":"man/multithreading/#PEPSKit.Defaults.set_scheduler!","page":"Multithreading","title":"PEPSKit.Defaults.set_scheduler!","text":"set_scheduler!([scheduler]; kwargs...)\n\nSet OhMyThreads multithreading scheduler parameters.\n\nThe function either accepts a scheduler as an OhMyThreads.Scheduler or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via\n\nset_scheduler!(StaticScheduler(; ntasks=4, chunking=true))\n\nor equivalently with \n\nset_scheduler!(:static; ntasks=4, chunking=true)\n\nFor a detailed description of all schedulers and their keyword arguments consult the OhMyThreads documentation.\n\nIf no scheduler is passed and only kwargs are provided, the DynamicScheduler constructor is used with the provided kwargs.\n\nTo reset the scheduler to its default value, one calls set_scheduler! without passing arguments which then uses the default DynamicScheduler(). If the number of used threads is just one it falls back to SerialScheduler().\n\n\n\n\n\n","category":"function"},{"location":"man/multithreading/","page":"Multithreading","title":"Multithreading","text":"By default, the OhMyThreads machinery will be used to parallelize certain parts of the code, if Julia started with multiple threads. Cases where PEPSKit can leverage parallel threads are:","category":"page"},{"location":"man/multithreading/","page":"Multithreading","title":"Multithreading","text":"CTMRG steps using the :simultaneous scheme, where we parallelize over all unit cell coordinates and spatial directions\nThe reverse pass of these parallelized CTMRG steps\nEvaluating expectation values of observables, where we parallelize over the terms contained in the LocalOperator","category":"page"},{"location":"examples/#e_overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Here we provide a number of commented example pages that serve as short tutorials on how to use PEPSKit in various situations. Applications span from two-dimensional quantum models, including fermionic Hamiltonians, to classical three-dimensional statistical mechanics:","category":"page"},{"location":"examples/#Optimization","page":"Overview","title":"Optimization","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Pages = Main.examples_optimization\nDepth = 1","category":"page"},{"location":"examples/#Time-Evolution","page":"Overview","title":"Time Evolution","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Pages = Main.examples_time_evolution\nDepth = 1","category":"page"},{"location":"examples/#Partition-Functions","page":"Overview","title":"Partition Functions","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Pages = Main.examples_partition_functions\nDepth = 1","category":"page"},{"location":"examples/#Boundary-MPS","page":"Overview","title":"Boundary MPS","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Pages = Main.examples_boundary_mps\nDepth = 1","category":"page"},{"location":"man/precompilation/#Precompilation-using-PrecompileTools.jl","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"","category":"section"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"For certain PEPSKit applications, the \"time to first execution\" (TTFX) can be quite long. If frequent recompilation is required this can become a significant time sink. Especially in simulations involving AD code, the precompilation times of Zygote tend to be particularly bad.","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"Fortunately, there is an easy way out using PrecompileTools. By writing a precompilation script that executes and precompiles a toy problem which is suited to one's personal problem, one can cut down significantly on the TTFX. To see how that works in the context of PEPSKit, we will closely follow the PrecompileTools docs.","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"Let's say we have a project where we want to speed up the TTFX, located in a project environment called YourProject. Inside that project folder, we generate a Startup module which will contain the toy problem that we want to precompile:","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"(YourProject) pkg> generate Startup\n  Generating  project Startup:\n    Startup/Project.toml\n    Startup/src/Startup.jl\n\n(YourProject) pkg> dev ./Startup\n   Resolving package versions...\n    Updating `/YourProject/Project.toml`\n  [e9c42744] + Startup v0.1.0 `Startup`\n    Updating `/tmp/Project1/Manifest.toml`\n  [e9c42744] + Startup v0.1.0 `Startup`\n\n(YourProject) pkg> activate Startup/\n  Activating project at `/YourProject/Startup`\n\n(Startup) pkg> add PrecompileTools YourPackages...","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"The Startup module should depend on PrecompileTools as well as all the packages (YourPackages...) that are required to run the precompilation toy problem. Next, we edit the Startup/src/Startup.jl file and add to it all the code which we want PrecompileTools to compile. We will here provide a basic example featuring Zygote AD code on various algorithmic combinations:","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"module Startup\n\nusing Random\nusing TensorKit, KrylovKit, OptimKit\nusing ChainRulesCore, Zygote\nusing MPSKit, MPSKitModels\nusing PEPSKit\nusing PrecompileTools\n\n@setup_workload begin\n    t₀ = time_ns()\n    Random.seed!(20918352394)\n\n    # Hyperparameters\n    Dbond = 2\n    χenv = 4\n    gradtol = 1e-3\n    maxiter = 4\n    verbosity = -1\n    H = heisenberg_XYZ(InfiniteSquare())\n\n    # Algorithmic settings\n    ctmrg_algs = [\n        SimultaneousCTMRG(; maxiter, projector_alg=:halfinfinite, verbosity),\n        SequentialCTMRG(; maxiter, projector_alg=:halfinfinite, verbosity),\n    ]\n    gradient_algs = [\n        LinSolver(; solver_alg=BiCGStab(; tol=gradtol), iterscheme=:fixed),\n        LinSolver(; solver_alg=BiCGStab(; tol=gradtol), iterscheme=:diffgauge),\n        EigSolver(; solver_alg=Arnoldi(; tol=gradtol, eager=true), iterscheme=:fixed),\n    ]\n\n    # Initialize OhMyThreads scheduler (precompilation occurs before __init__ call)\n    set_scheduler!()\n\n    @compile_workload begin\n        # Initialize PEPS and environments with different unit cells, number types and symmetries\n        @info \"Precompiling workload: initializing PEPSs and environments\"\n        peps = InfinitePEPS(randn, ComplexF64, ComplexSpace(Dbond), ComplexSpace(Dbond))\n\n        env, = leading_boundary(CTMRGEnv(peps, ComplexSpace(χenv)), peps; verbosity)\n\n        # CTMRG\n        @info \"Precompiling workload: CTMRG leading_boundary\"\n        for ctmrg_alg in ctmrg_algs\n            leading_boundary(env, peps, ctmrg_alg)\n        end\n\n        # Differentiate CTMRG leading_boundary\n        @info \"Precompiling workload: backpropagation of leading_boundary\"\n        for alg_rrule in gradient_algs\n            Zygote.withgradient(peps) do ψ\n                env′, = PEPSKit.hook_pullback(\n                    leading_boundary, env, ψ, SimultaneousCTMRG(; verbosity); alg_rrule\n                )\n                return cost_function(ψ, env′, H)\n            end\n        end\n\n        # Optimize via fixedpoint using LBFGS\n        @info \"Precompiling workload: LBFGS fixedpoint optimization\"\n        fixedpoint(H, peps, env, opt_alg; tol=gradtol, maxiter, verbosity)\n\n        # Compute correlation length\n        @info \"Precompiling workload: correlation_length\"\n        correlation_length(peps, env)\n    end\n\n    duration = round((time_ns() - t₀) * 1e-9 / 60; digits=2) # minutes\n    @info \"Precompiling workload: finished after $duration min\"\nend\n\nend","category":"page"},{"location":"man/precompilation/","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"Finally, activate YourProject again - where we want to benefit from the shortened execution times - and run using Startup. That way, all packages will be loaded with their precompiled code. Of course, we may also have multiple start-up routines where the precompiled code is tailored towards the needs of the respective projects.","category":"page"},{"location":"man/states/#States","page":"States","title":"States","text":"","category":"section"},{"location":"man/states/","page":"States","title":"States","text":"note: Note\nThis section is still under construction.","category":"page"},{"location":"man/peps_optimization/#PEPS-optimization","page":"PEPS optimization","title":"PEPS optimization","text":"","category":"section"},{"location":"man/peps_optimization/","page":"PEPS optimization","title":"PEPS optimization","text":"note: Note\nThis section is still under construction.","category":"page"},{"location":"man/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"man/models/","page":"Models","title":"Models","text":"PEPSKit implements physical models through the MPSKitModels.jl package as PEPSKit.LocalOperator structs. Here, we want to explain how users can define their own Hamiltonians and provide a list of already implemented models.","category":"page"},{"location":"man/models/#Implementing-custom-models","page":"Models","title":"Implementing custom models","text":"","category":"section"},{"location":"man/models/","page":"Models","title":"Models","text":"In order to define custom Hamiltonians, we leverage several of the useful tools provided in MPSKitModels. In particular, we use many of the pre-defined operators, which is especially useful when defining models with symmetric and fermionic tensors, since most of these operators can take a symmetry as an argument, returning the appropriate symmetric TensorMap. In order to specify the lattice on which the Hamiltonian is defined, we construct two-dimensional lattices as subtypes of MPSKitModels.AbstractLattice. Note that so far, all models are defined on infinite square lattices, see InfiniteSquare, but in the future, we plan to support other lattice geometries as well. In order to specify tensors acting on particular lattice sites, there are a couple of handy methods that we want to point to: see vertices, nearest_neighbors and next_nearest_neighbors defined here.","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"For a simple example on how to implement a custom model, let's look at the implementation of the MPSKitModels.transverse_field_ising model:","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"function MPSKitModels.transverse_field_ising(\n    T::Type{<:Number},\n    S::Union{Type{Trivial},Type{Z2Irrep}},\n    lattice::InfiniteSquare;\n    J=1.0,\n    g=1.0,\n)\n    ZZ = rmul!(σᶻᶻ(T, S), -J)\n    X = rmul!(σˣ(T, S), g * -J)\n    spaces = fill(domain(X)[1], (lattice.Nrows, lattice.Ncols))\n    return LocalOperator(\n        spaces,\n        (neighbor => ZZ for neighbor in nearest_neighbours(lattice))...,\n        ((idx,) => X for idx in vertices(lattice))...,\n    )\nend","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"This provides a good recipe for defining a model:","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"Define the locally-acting tensors as TensorMaps.\nConstruct a matrix of the physical spaces these TensorMaps act on based on the lattice geometry.\nReturn a LocalOperator where we specify on which sites (e.g. on-site, nearest neighbor, etc.) the local tensors act.","category":"page"},{"location":"man/models/","page":"Models","title":"Models","text":"For more model implementations, check the PEPSKit repository.","category":"page"},{"location":"man/models/#Implemented-models","page":"Models","title":"Implemented models","text":"","category":"section"},{"location":"man/models/","page":"Models","title":"Models","text":"While PEPSKit provides an interface for specifying custom Hamiltonians, it also provides a number of pre-defined models. Some of these are models already defined in MPSKitModels, which are overloaded for two-dimensional lattices and re-exported, but there are new additions as well. The following models are provided:","category":"page"},{"location":"man/models/#MPSKitModels.jl-models","page":"Models","title":"MPSKitModels.jl models","text":"","category":"section"},{"location":"man/models/#MPSKitModels.transverse_field_ising","page":"Models","title":"MPSKitModels.transverse_field_ising","text":"transverse_field_ising([elt::Type{<:Number}], [symmetry::Type{<:Sector}],\n                       [lattice::AbstractLattice]; J=1.0, g=1.0)\n\nMPO for the hamiltonian of the one-dimensional Transverse-field Ising model, as defined by\n\nH = -Jleft(sum_langle ij rangle sigma^z_i sigma^z_j + g sum_i sigma^x_i right)\n\nwhere the sigma^i are the spin-1/2 Pauli operators. Possible values for the symmetry are Trivial, Z2Irrep or FermionParity.\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, with Trivial symmetry and with ComplexF64 entries of the tensors.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.heisenberg_XYZ","page":"Models","title":"MPSKitModels.heisenberg_XYZ","text":"heisenberg_XYZ([elt::Type{<:Number}], [lattice::AbstractLattice];\n    Jx=1.0, Jy=1.0, Jz=1.0, spin=1)\n\nMPO for the hamiltonian of the XYZ Heisenberg model, defined by\n\nH = sum_langle ij rangle left( J^x S_i^x S_j^x + J^y S_i^y S_j^y + J^z S_i^z S_j^z right)\n\nBy default, the model is defined on an infinite chain with unit lattice spacing and with ComplexF64 entries of the tensors.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.heisenberg_XXZ","page":"Models","title":"MPSKitModels.heisenberg_XXZ","text":"heisenberg_XXZ([elt::Type{<:Number}], [symmetry::Type{<:Sector}],\n               [lattice::AbstractLattice]; J=1.0, Delta=1.0, spin=1)\n\nMPO for the hamiltonian of the XXZ Heisenberg model, as defined by\n\nH = J left( sum_langle ij rangle S_i^x S_j^x + S_i^y S_j^y + Delta S_i^z S_j^z right)\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, without any symmetries and with ComplexF64 entries of the tensors.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.hubbard_model","page":"Models","title":"MPSKitModels.hubbard_model","text":"hubbard_model([elt::Type{<:Number}], [particle_symmetry::Type{<:Sector}],\n              [spin_symmetry::Type{<:Sector}], [lattice::AbstractLattice];\n              t, U, mu, n)\n\nMPO for the hamiltonian of the Hubbard model, as defined by\n\nH = -t sum_langle ij rangle sum_sigma left( e_isigma^+ e_jsigma^- + c_isigma^- c_jsigma^+ right) + U sum_i n_iuparrown_idownarrow - sum_i mu n_i\n\nwhere sigma is a spin index that can take the values uparrow or downarrow and n is the fermionic number operator e_number.\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, without any symmetries and with ComplexF64 entries of the tensors. If the particle_symmetry is not Trivial, a fixed particle number density n can be imposed.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.bose_hubbard_model","page":"Models","title":"MPSKitModels.bose_hubbard_model","text":"bose_hubbard_model([elt::Type{<:Number}], [symmetry::Type{<:Sector}],\n                   [lattice::AbstractLattice];\n                   cutoff, t, U, mu, n)\n\nMPO for the hamiltonian of the Bose-Hubbard model, as defined by\n\nH = -t sum_langle ij rangle left( a_i^+ a_j^- + a_i^- a_j^+ right) - mu sum_i N_i + fracU2 sum_i N_i(N_i - 1)\n\nwhere N is the bosonic number operator a_number.\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, without any symmetries and with ComplexF64 entries of the tensors. The Hilbert space is truncated such that at maximum of cutoff bosons can be at a single site. If the symmetry is not Trivial, a fixed (halfinteger) particle number density n can be imposed.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.tj_model","page":"Models","title":"MPSKitModels.tj_model","text":"tj_model([elt::Type{<:Number}], [particle_symmetry::Type{<:Sector}],\n              [spin_symmetry::Type{<:Sector}], [lattice::AbstractLattice];\n              t, J, mu, slave_fermion::Bool=false)\n\nMPO for the hamiltonian of the t-J model, as defined by\n\nH = -t sum_langle ij rangle sigma\n    (tildee^dagger_isigma tildee_jsigma + hc)\n    + J sum_langle ij rangle(mathbfS_i cdot mathbfS_j - frac14 n_i n_j)\n    - mu sum_i n_i\n\nwhere tildee_isigma is the electron operator with spin sigma restrict to the no-double-occupancy subspace. \n\n\n\n\n\n","category":"function"},{"location":"man/models/#PEPSKit.jl-models","page":"Models","title":"PEPSKit.jl models","text":"","category":"section"},{"location":"man/models/#PEPSKit.j1_j2_model","page":"Models","title":"PEPSKit.j1_j2_model","text":"j1_j2_model([elt::Type{T}, symm::Type{S},] lattice::InfiniteSquare;\n            J1=1.0, J2=1.0, spin=1//2, sublattice=true)\n\nSquare lattice J_1text-J_2 model, defined by the Hamiltonian\n\nH = J_1 sum_langle ij rangle vecS_i cdot vecS_j\n+ J_2 sum_langlelangle ij ranglerangle vecS_i cdot vecS_j\n\nwhere vecS_i = (S_i^x S_i^y S_i^z). We denote the nearest and next-nearest neighbor terms using langle ij rangle and langlelangle ij ranglerangle, respectively. The sublattice kwarg enables a single-site unit cell ground state via a unitary sublattice rotation.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#PEPSKit.pwave_superconductor","page":"Models","title":"PEPSKit.pwave_superconductor","text":"pwave_superconductor([T=ComplexF64,] lattice::InfiniteSquare; t=1, μ=2, Δ=1)\n\nSquare lattice p-wave superconductor model, defined by the Hamiltonian\n\n    H = -sum_langle ij rangle left( t c_i^dagger c_j +\n    Delta c_i c_j + texthc right) - mu sum_i n_i\n\nwhere t is the hopping amplitude, Delta specifies the superconducting gap, mu is the chemical potential, and n_i = c_i^dagger c_i is the fermionic number operator.\n\n\n\n\n\n","category":"function"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/3d_ising_partition_function/#e_3d_ising","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"In this example, we will showcase how one can use PEPSKit to study 3D classical statistical mechanics models. In particular, we will consider a specific case of the 3D classical Ising model, but the same techniques can be applied to other 3D classical models as well.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"As compared to simulations of 2D partition functions, the workflow presented in this example is a bit more experimental and less 'black-box'. Therefore, it also serves as a demonstration of some of the more internal functionality of PEPSKit, and how one can adapt it to less 'standard' kinds of problems.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Let us consider the partition function of the classical Ising model,","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"mathcalZ(beta) = sum_s exp(-beta H(s)) text with  H(s) = -J sum_langle i j rangle s_i s_j ","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"where the classical spins s_i in +1 -1 are located on the vertices i of a 3D cubic lattice. The partition function of this model can be represented as a 3D tensor network with a rank-6 tensor at each vertex of the lattice. Such a network can be contracted by finding the fixed point of the corresponding transfer operator, in exactly the same spirit as the boundary MPS methods demonstrated in another example.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Let's start by making the example deterministic and importing the required packages:","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"using Random\nusing LinearAlgebra\nusing PEPSKit, TensorKit\nusing KrylovKit, OptimKit, Zygote\n\nRandom.seed!(81812781144);","category":"page"},{"location":"examples/3d_ising_partition_function/#Defining-the-partition-function","page":"The 3D classical Ising model","title":"Defining the partition function","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Just as in the 2D case, the first step is to define the partition function as a tensor network. The procedure is exactly the same as before, the only difference being that now every spin participates in interactions associated to six links adjacent to that site. This means that the partition function can be written as an infinite 3D network with a single constituent rank-6 PEPSKit.PEPOTensor O located at each site of the cubic lattice. To verify our example we will check the magnetization and energy, so we also define the corresponding rank-6 tensors M and E while we're at it.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"function three_dimensional_classical_ising(; beta, J = 1.0)\n    K = beta * J\n\n    # Boltzmann weights\n    t = ComplexF64[exp(K) exp(-K); exp(-K) exp(K)]\n    r = eigen(t)\n    q = r.vectors * sqrt(LinearAlgebra.Diagonal(r.values)) * r.vectors\n\n    # local partition function tensor\n    O = zeros(2, 2, 2, 2, 2, 2)\n    O[1, 1, 1, 1, 1, 1] = 1\n    O[2, 2, 2, 2, 2, 2] = 1\n    @tensor o[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n\n    # magnetization tensor\n    M = copy(O)\n    M[2, 2, 2, 2, 2, 2] *= -1\n    @tensor m[-1 -2; -3 -4 -5 -6] :=\n        M[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n\n    # bond interaction tensor and energy-per-site tensor\n    e = ComplexF64[-J J; J -J] .* q\n    @tensor e_x[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * e[-4; 4] * q[-5; 5] * q[-6; 6]\n    @tensor e_y[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * e[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n    @tensor e_z[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * e[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n    e = e_x + e_y + e_z\n\n    # fixed tensor map space for all three\n    TMS = ℂ^2 ⊗ (ℂ^2)' ← ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)'\n\n    return TensorMap(o, TMS), TensorMap(m, TMS), TensorMap(e, TMS)\nend;","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Let's initialize these tensors at inverse temperature beta=02391, which corresponds to a slightly lower temperature than the critical value beta_c=02216544","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"beta = 0.2391\nO, M, E = three_dimensional_classical_ising(; beta)\nO isa PEPSKit.PEPOTensor","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"true","category":"page"},{"location":"examples/3d_ising_partition_function/#Contracting-the-partition-function","page":"The 3D classical Ising model","title":"Contracting the partition function","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"To contract our infinite 3D partition function, we first reinterpret it as an infinite power of a slice-to-slice transfer operator mathbbT, where mathbbT can be seen as an infinite 2D projected entangled-pair operator (PEPO) which consists of the rank-6 tensor O at each site of an infinite 2D square lattice,","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"<center>\n<img src=\"../../assets/figures/pepo.svg\" alt=\"pepo\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"To contract the original infinite network, all we need to do is to find the leading eigenvector of the PEPO mathbbT, The fixed point of such a PEPO can be parametrized as a PEPS psi, which should then satisfy the eigenvalue equation mathbbT psirangle = Lambda psirangle, or diagrammatically:","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"<center>\n<img src=\"../../assets/figures/pepo_fixedpoint_equation.svg\" alt=\"pepo fixedpoint equation\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"For a Hermitian transfer operator mathbbT we can characterize the fixed point PEPS psirangle which satisfies the eigenvalue equation mathbbT psirangle = Lambda psirangle corresponding to the largest magnitude eigenvalue Lambda as the solution of a variational problem","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"psirangle = textargmin_psirangle left ( lim_N to  - frac1N log left( fraclangle psi  mathbbT  psi ranglelangle psi  psi rangle right) right ) ","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"where N is the diverging number of sites of the 2D transfer operator mathbbT. The function minimized in this expression is exactly the free energy per site of the partition function. This means we can directly find the fixed-point PEPS by variationally minimizing the free energy.","category":"page"},{"location":"examples/3d_ising_partition_function/#Defining-the-cost-function","page":"The 3D classical Ising model","title":"Defining the cost function","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Using PEPSKit.jl, this cost function and its gradient can be computed, after which we can use OptimKit.jl to actually optimize it. We can immediately recognize the denominator langle psi  psi rangle as the familiar PEPS norm, where we can compute the norm per site as the network_value of the corresponding InfiniteSquareNetwork by contracting it with the CTMRG algorithm. Similarly, the numerator langle psi  mathbbT  psi rangle is nothing more than an InfiniteSquareNetwork consisting of three layers corresponding to the ket, transfer operator and bra objects. This object can also be constructed and contracted in a straightforward way, so we can again compute its network_value.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"To define our cost function, we then need to construct the transfer operator as an InfinitePEPO, construct the two infinite 2D contractible networks for the numerator and denominator from the current PEPS and this transfer operator, and specify a contraction algorithm we can use to compute the values of these two networks. In addition, we'll specify the specific reverse rule algorithm that will be used to compute the gradient of this cost function.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"boundary_alg = SimultaneousCTMRG(; maxiter = 150, tol = 1.0e-8, verbosity = 1)\nrrule_alg = EigSolver(;\n    solver_alg = KrylovKit.Arnoldi(; maxiter = 30, tol = 1.0e-6, eager = true), iterscheme = :diffgauge\n)\nT = InfinitePEPO(O)\n\nfunction pepo_costfun((peps, env_double_layer, env_triple_layer))\n    # use Zygote to compute the gradient automatically\n    E, gs = withgradient(peps) do ψ\n        # construct the PEPS norm network\n        n_double_layer = InfiniteSquareNetwork(ψ)\n        # contract this network\n        env_double_layer′, info = PEPSKit.hook_pullback(\n            leading_boundary,\n            env_double_layer,\n            n_double_layer,\n            boundary_alg;\n            alg_rrule = rrule_alg,\n        )\n        # construct the PEPS-PEPO-PEPS overlap network\n        n_triple_layer = InfiniteSquareNetwork(ψ, T)\n        # contract this network\n        env_triple_layer′, info = PEPSKit.hook_pullback(\n            leading_boundary,\n            env_triple_layer,\n            n_triple_layer,\n            boundary_alg;\n            alg_rrule = rrule_alg,\n        )\n        # update the environments for reuse\n        PEPSKit.ignore_derivatives() do\n            PEPSKit.update!(env_double_layer, env_double_layer′)\n            PEPSKit.update!(env_triple_layer, env_triple_layer′)\n        end\n        # compute the network values per site\n        λ3 = network_value(n_triple_layer, env_triple_layer)\n        λ2 = network_value(n_double_layer, env_double_layer)\n        # use this to compute the actual cost function\n        return -log(real(λ3 / λ2))\n    end\n    g = only(gs)\n    return E, g\nend;","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"There are a few things to note about this cost function definition. Since we will pass it to the OptimKit.optimize, we require it to return both our cost function and the corresponding gradient. To do this, we simply use the withgradient method from Zygote.jl to automatically compute the gradient of the cost function straight from the primal computation. Since our cost function involves contractions using leading_boundary, we also have to specify exactly how Zygote should handle the backpropagation of the gradient through this function. This can be done using the PEPSKit.hook_pullback function from PEPSKit.jl, which allows to hook into the pullback of a given function by specifying a specific algorithm for the pullback computation. Here, we opted to use an Arnoldi method to solve the linear problem defining the gradient of the network contraction at its fixed point. This is exactly the workflow that internally underlies PEPSKit.fixedpoint, and more info on particular gradient algorithms can be found in the corresponding docstrings.","category":"page"},{"location":"examples/3d_ising_partition_function/#Characterizing-the-optimization-manifold","page":"The 3D classical Ising model","title":"Characterizing the optimization manifold","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"In order to make the best use of OptimKit.jl, we should specify some properties of the manifold on which we are optimizing. Looking at our cost function defined above, a point on our optimization manifold corresponds to a Tuple of three objects. The first is an InfinitePEPS encoding the fixed point we are actually optimizing, while the second and third are CTMRGEnv objects corresponding to the environments of the double and triple layer networks langle psi  psi rangle and langle psi  T  psi rangle respectively. While the environments are just there so we can reuse them between subsequent contractions and we don't need to think about them much, optimizing over the manifold of InfinitePEPS requires a bit more care.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"In particular, we need to define two kinds of operations on this manifold: a retraction and a transport. The retraction, corresponding to the retract keyword argument of OptimKit.optimize, specifies how to move from a point on a manifold along a given descent direction to obtain a new manifold point. The transport, corresponding to the transport! keyword argument of OptimKit.optimize, specifies how to transport a descent direction at a given manifold point to a valid descent direction at a different manifold point according to the appropriate metric. For a more detailed explanation we refer to the OptimKit.jl README. In PEPSKit.jl, these two procedures are defined through the PEPSKit.peps_retract and PEPSKit.peps_transport! methods. While it is instructive to read the corresponding docstrings in order to understand what these actually do, here we can just blindly reuse them where the only difference is that we have to pass along an extra environment since our cost function requires two distinct contractions as opposed to the setting of Hamiltonian PEPS optimization which only requires a double-layer contraction.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"function pepo_retract((peps, env_double_layer, env_triple_layer), η, α)\n    (peps´, env_double_layer´), ξ = PEPSKit.peps_retract((peps, env_double_layer), η, α)\n    env_triple_layer´ = deepcopy(env_triple_layer)\n    return (peps´, env_double_layer´, env_triple_layer´), ξ\nend\nfunction pepo_transport!(\n        ξ,\n        (peps, env_double_layer, env_triple_layer),\n        η,\n        α,\n        (peps´, env_double_layer´, env_triple_layer´),\n    )\n    return PEPSKit.peps_transport!(\n        ξ, (peps, env_double_layer), η, α, (peps´, env_double_layer´)\n    )\nend;","category":"page"},{"location":"examples/3d_ising_partition_function/#Finding-the-fixed-point","page":"The 3D classical Ising model","title":"Finding the fixed point","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"All that is left then is to specify the virtual spaces of the PEPS and the two environments, initialize them in the appropriate way, choose an optimization algortithm and call the optimize function from OptimKit.jl to get our desired PEPS fixed point.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Vpeps = ℂ^2\nVenv = ℂ^12\n\npsi0 = initializePEPS(T, Vpeps)\nenv2_0 = CTMRGEnv(InfiniteSquareNetwork(psi0), Venv)\nenv3_0 = CTMRGEnv(InfiniteSquareNetwork(psi0, T), Venv)\n\noptimizer_alg = LBFGS(32; maxiter = 100, gradtol = 1.0e-5, verbosity = 3)\n\n(psi_final, env2_final, env3_final), f, = optimize(\n    pepo_costfun,\n    (psi0, env2_0, env3_0),\n    optimizer_alg;\n    inner = PEPSKit.real_inner,\n    retract = pepo_retract,\n    (transport!) = (pepo_transport!),\n);","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"[ Info: LBFGS: initializing with f = -0.554073395182, ‖∇f‖ = 7.7844e-01\n┌ Warning: CTMRG cancel 150:\tobj = +1.702942228759e+01 +1.443123606306e-07im\terr = 2.4386740905e-05\ttime = 2.49 sec\n└ @ PEPSKit ~/PEPSKit.jl/src/algorithms/ctmrg/ctmrg.jl:152\n[ Info: LBFGS: iter    1, time  154.68 s: f = -0.777080930369, ‖∇f‖ = 3.1305e-02, α = 7.10e+02, m = 0, nfg = 7\n[ Info: LBFGS: iter    2, time  156.09 s: f = -0.784111515961, ‖∇f‖ = 2.0103e-02, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    3, time  156.40 s: f = -0.792705733484, ‖∇f‖ = 2.3327e-02, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, time  156.65 s: f = -0.796289732476, ‖∇f‖ = 2.2475e-02, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    5, time  156.86 s: f = -0.799674902374, ‖∇f‖ = 7.0288e-03, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    6, time  157.05 s: f = -0.800082100121, ‖∇f‖ = 1.2717e-03, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    7, time  157.27 s: f = -0.800110603125, ‖∇f‖ = 1.3384e-03, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    8, time  157.45 s: f = -0.800262201996, ‖∇f‖ = 2.4945e-03, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter    9, time  157.64 s: f = -0.800450505448, ‖∇f‖ = 2.9259e-03, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   10, time  157.85 s: f = -0.800764917087, ‖∇f‖ = 1.7221e-03, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, time  158.07 s: f = -0.800876048838, ‖∇f‖ = 2.2475e-03, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, time  158.26 s: f = -0.801100867467, ‖∇f‖ = 1.5561e-03, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, time  158.48 s: f = -0.801317048856, ‖∇f‖ = 1.1561e-03, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, time  158.69 s: f = -0.801373050545, ‖∇f‖ = 7.1300e-04, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, time  158.89 s: f = -0.801388615264, ‖∇f‖ = 2.8462e-04, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, time  159.10 s: f = -0.801394633333, ‖∇f‖ = 2.7607e-04, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, time  159.28 s: f = -0.801408061564, ‖∇f‖ = 3.6096e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, time  159.53 s: f = -0.801509542169, ‖∇f‖ = 1.9822e-03, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   19, time  159.77 s: f = -0.801578405251, ‖∇f‖ = 1.8040e-03, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   20, time  160.69 s: f = -0.801694524424, ‖∇f‖ = 2.9356e-03, α = 5.48e-01, m = 19, nfg = 3\n[ Info: LBFGS: iter   21, time  161.31 s: f = -0.801761920683, ‖∇f‖ = 1.1993e-03, α = 3.82e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   22, time  161.60 s: f = -0.801797785494, ‖∇f‖ = 6.0337e-04, α = 1.00e+00, m = 21, nfg = 1\n[ Info: LBFGS: iter   23, time  162.21 s: f = -0.801808747834, ‖∇f‖ = 3.7053e-04, α = 5.24e-01, m = 22, nfg = 2\n[ Info: LBFGS: iter   24, time  162.50 s: f = -0.801812729173, ‖∇f‖ = 3.0781e-04, α = 1.00e+00, m = 23, nfg = 1\n[ Info: LBFGS: iter   25, time  162.80 s: f = -0.801816445211, ‖∇f‖ = 2.9994e-04, α = 1.00e+00, m = 24, nfg = 1\n[ Info: LBFGS: iter   26, time  163.09 s: f = -0.801824713130, ‖∇f‖ = 3.6496e-04, α = 1.00e+00, m = 25, nfg = 1\n[ Info: LBFGS: iter   27, time  163.41 s: f = -0.801839673823, ‖∇f‖ = 5.4222e-04, α = 1.00e+00, m = 26, nfg = 1\n[ Info: LBFGS: iter   28, time  163.74 s: f = -0.801857478904, ‖∇f‖ = 2.7917e-04, α = 1.00e+00, m = 27, nfg = 1\n[ Info: LBFGS: iter   29, time  164.06 s: f = -0.801864555224, ‖∇f‖ = 1.2319e-04, α = 1.00e+00, m = 28, nfg = 1\n[ Info: LBFGS: iter   30, time  164.37 s: f = -0.801865598736, ‖∇f‖ = 8.6048e-05, α = 1.00e+00, m = 29, nfg = 1\n[ Info: LBFGS: iter   31, time  164.68 s: f = -0.801867571755, ‖∇f‖ = 8.8636e-05, α = 1.00e+00, m = 30, nfg = 1\n[ Info: LBFGS: iter   32, time  165.00 s: f = -0.801870393528, ‖∇f‖ = 2.6554e-04, α = 1.00e+00, m = 31, nfg = 1\n[ Info: LBFGS: iter   33, time  165.35 s: f = -0.801874797039, ‖∇f‖ = 2.7841e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   34, time  165.70 s: f = -0.801877566644, ‖∇f‖ = 1.8523e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   35, time  166.02 s: f = -0.801878506245, ‖∇f‖ = 2.0638e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   36, time  166.33 s: f = -0.801878995097, ‖∇f‖ = 5.6081e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   37, time  166.64 s: f = -0.801879153573, ‖∇f‖ = 6.2356e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   38, time  166.94 s: f = -0.801879355075, ‖∇f‖ = 6.0528e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   39, time  167.25 s: f = -0.801880115100, ‖∇f‖ = 6.2768e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   40, time  167.60 s: f = -0.801881475065, ‖∇f‖ = 6.2301e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   41, time  167.96 s: f = -0.801882272425, ‖∇f‖ = 9.5267e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   42, time  168.29 s: f = -0.801882600033, ‖∇f‖ = 5.1283e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   43, time  168.61 s: f = -0.801882711875, ‖∇f‖ = 2.6091e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   44, time  168.92 s: f = -0.801882805828, ‖∇f‖ = 2.9316e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   45, time  169.21 s: f = -0.801883027060, ‖∇f‖ = 2.7982e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   46, time  169.52 s: f = -0.801883402178, ‖∇f‖ = 3.8102e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   47, time  169.85 s: f = -0.801883718321, ‖∇f‖ = 5.3658e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   48, time  170.17 s: f = -0.801883962887, ‖∇f‖ = 2.8728e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   49, time  170.51 s: f = -0.801884158085, ‖∇f‖ = 3.0680e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   50, time  170.84 s: f = -0.801884385940, ‖∇f‖ = 4.1973e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   51, time  171.20 s: f = -0.801884810459, ‖∇f‖ = 6.8881e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   52, time  171.54 s: f = -0.801885011014, ‖∇f‖ = 3.8651e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   53, time  171.87 s: f = -0.801885126625, ‖∇f‖ = 1.9013e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   54, time  172.21 s: f = -0.801885186489, ‖∇f‖ = 3.2919e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   55, time  172.56 s: f = -0.801885309713, ‖∇f‖ = 4.8521e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   56, time  172.91 s: f = -0.801885491631, ‖∇f‖ = 1.1478e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   57, time  173.29 s: f = -0.801885912857, ‖∇f‖ = 7.7221e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   58, time  173.66 s: f = -0.801886451980, ‖∇f‖ = 6.5316e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   59, time  174.01 s: f = -0.801886639803, ‖∇f‖ = 5.1567e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   60, time  174.69 s: f = -0.801886699372, ‖∇f‖ = 4.5540e-05, α = 3.68e-01, m = 32, nfg = 2\n[ Info: LBFGS: iter   61, time  174.99 s: f = -0.801886723992, ‖∇f‖ = 2.1992e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   62, time  175.28 s: f = -0.801886735202, ‖∇f‖ = 1.8064e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   63, time  175.61 s: f = -0.801886771395, ‖∇f‖ = 3.8651e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   64, time  175.93 s: f = -0.801886801952, ‖∇f‖ = 4.2630e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   65, time  176.24 s: f = -0.801886837856, ‖∇f‖ = 3.9318e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   66, time  176.55 s: f = -0.801886916783, ‖∇f‖ = 3.8747e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   67, time  176.88 s: f = -0.801887030054, ‖∇f‖ = 3.7140e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   68, time  177.23 s: f = -0.801887141197, ‖∇f‖ = 5.7017e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   69, time  177.94 s: f = -0.801887199203, ‖∇f‖ = 3.0700e-05, α = 5.24e-01, m = 32, nfg = 2\n[ Info: LBFGS: iter   70, time  178.28 s: f = -0.801887246612, ‖∇f‖ = 1.3885e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   71, time  178.61 s: f = -0.801887263715, ‖∇f‖ = 1.5769e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   72, time  178.95 s: f = -0.801887319463, ‖∇f‖ = 2.1423e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   73, time  179.30 s: f = -0.801887406143, ‖∇f‖ = 1.9895e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   74, time  180.00 s: f = -0.801887467460, ‖∇f‖ = 1.9799e-05, α = 3.61e-01, m = 32, nfg = 2\n[ Info: LBFGS: converged after 75 iterations and time 180.33 s: f = -0.801887535670, ‖∇f‖ = 9.9342e-06\n","category":"page"},{"location":"examples/3d_ising_partition_function/#Verifying-the-result","page":"The 3D classical Ising model","title":"Verifying the result","text":"","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"Having found the fixed point, we have essentially contracted the entire partition function and we can start computing observables. The free energy per site for example is just given by the final value of the cost function we have just optimized.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"@show f","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"-0.8018875356702571","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"As another check, we can compute the magnetization per site and compare it to a reference value obtaind through Monte-Carlo simulations.","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"n3_final = InfiniteSquareNetwork(psi_final, T)\nnum = PEPSKit.contract_local_tensor((1, 1, 1), M, n3_final, env3_final)\ndenom = PEPSKit._contract_site((1, 1), n3_final, env3_final)\nm = abs(num / denom)\n\nm_ref = 0.667162\n\n@show abs(m - m_ref)","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"0.00011315585491944447","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"","category":"page"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/boundary_mps/#e_boundary_mps","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Instead of using CTMRG to contract the network encoding the norm of an infinite PEPS, one can also use so-called boundary MPS methods to contract this network. In this example, we will demonstrate how to use the VUMPS algorithm to do so.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Before we start, we'll fix the random seed for reproducability:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"using Random\nRandom.seed!(29384293742893);","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Besides TensorKit and PEPSKit, here we also need to load the MPSKit.jl package which implements a host of tools for working with 1D matrix product states (MPS), including the VUMPS algorithm:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"using TensorKit, PEPSKit, MPSKit","category":"page"},{"location":"examples/boundary_mps/#Computing-a-PEPS-norm","page":"Boundary MPS contractions of 2D networks","title":"Computing a PEPS norm","text":"","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"We start by initializing a random infinite PEPS. Let us use normally distributed complex entries using randn:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"ψ = InfinitePEPS(randn, ComplexF64, ComplexSpace(2), ComplexSpace(2))","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"InfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}[TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')):\n[:, :, 1, 1, 1] =\n -0.5524390176345264 - 0.07357188568178248im  0.34014501646081047 - 0.7552574870030472im\n -0.5455245317233405 + 0.8946618856309984im     1.249282911658007 + 0.45352274131986825im\n\n[:, :, 2, 1, 1] =\n    0.33621043661988675 + 0.4400876608299719im   -0.9866664087107284 - 0.28688827761325675im\n -0.0077250067072679235 + 1.7380910495900947im  -0.19071062901939098 - 1.1367500834118434im\n\n[:, :, 1, 2, 1] =\n -0.09149850722392933 + 0.3560942836258964im      1.6255618447281441 - 0.5689426732891244im\n -0.19309251474097275 - 0.32363899914302613im  -0.025356816648697236 + 0.5632279168368712im\n\n[:, :, 2, 2, 1] =\n 0.07675114584269166 - 0.011479824536308164im  -0.17779977372973318 + 1.1379201927122535im\n -1.0116302866282385 - 0.9253070687198848im      1.1649047337212566 + 0.9936369101208083im\n\n[:, :, 1, 1, 2] =\n  0.2510676919806213 - 0.182052326055189im   -0.5792402993550532 - 0.4309109406268341im\n 0.04501645227038913 - 0.8140971172854408im  -0.5608346802110794 + 0.21262550530307248im\n\n[:, :, 2, 1, 2] =\n  1.5061767210554262 + 0.17190948125245623im  -0.8001234458239143 + 0.6764943808639017im\n -0.8176938467062373 - 0.40919675695722396im  -0.6692181340575689 + 0.6923370271564298im\n\n[:, :, 1, 2, 2] =\n -0.16556382071485704 + 0.2540132491548349im   0.05546115732751907 + 0.3723175507964387im\n -0.29883021417599165 - 0.07229462525164528im   -1.200173153698329 - 0.45509299328832953im\n\n[:, :, 2, 2, 2] =\n  0.289873563752043 + 0.44718981087960125im  0.018357838612906643 + 0.9634127683557584im\n 0.5128282969211142 - 0.2865462937979091im   -0.44278618042821827 + 0.2612084385439659im\n;;])","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"To compute its norm, we have to contract a double-layer network which encodes the bra-ket PEPS overlap langle ψ  ψ rangle:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"<center>\n<img src=\"../../assets/figures/peps_norm_network.svg\" alt=\"peps norm network\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"In PEPSKit.jl, this structure is represented as an InfiniteSquareNetwork object, whose effective local rank-4 constituent tensor is given by the contraction of a pair of bra and ket PEPSKit.PEPSTensors across their physical legs. Until now, we have always contracted such a network using the CTMRG algorithm. Here however, we will use another approach.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"If we take out a single row of this infinite norm network, we can interpret it as a 1D row-to-row transfer operator mathbbT,","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"<center>\n<img src=\"../../assets/figures/peps_transfer_operator.svg\" alt=\"peps transfer operator\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"This transfer operator can be seen as an infinite chain of the effective local rank-4 tensors that make up the PEPS norm network. Since the network we want to contract can be interpreted as the infinite power of mathbbT, we can contract it by finding its leading eigenvector as a 1D MPS  psi_textMPS rangle, which we call the boundary MPS. This boundary MPS should satisfy the eigenvalue equation mathbbT  psi_textMPS rangle approx Lambda  psi_textMPS rangle, or diagrammatically:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"<center>\n<img src=\"../../assets/figures/peps_transfer_fixedpoint_equation.svg\" alt=\"peps transfer fixedpoint equation\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Note that if mathbbT is Hermitian, we can formulate this eigenvalue equation in terms of a variational problem for the free energy,","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"beginalign\nf = lim_N to  - frac1N log left( fraclangle psi_textMPS  mathbbT  psi_textMPS ranglelangle psi_textMPS  psi_textMPS rangle right)\n\n= -log(lambda)\nendalign","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"where lambda = Lambda^1N is the 'eigenvalue per site' of mathbbT, giving f the meaning of a free energy density.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Since the contraction of a PEPS norm network is in essence exactly the same problem as the contraction of a 2D classical partition function, we can directly use boundary MPS algorithms designed for 2D statistical mechanics models in this context. In particular, we'll use the the VUMPS algorithm to perform the boundary MPS contraction, and we'll call it through the leading_boundary method from MPSKit.jl. This method precisely finds the MPS fixed point of a 1D transfer operator.","category":"page"},{"location":"examples/boundary_mps/#Boundary-MPS-contractions-with-PEPSKit.jl","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions with PEPSKit.jl","text":"","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"To use leading_boundary, we first need to contruct the transfer operator mathbbT as an MPSKit.InfiniteMPO object. In PEPSKit.jl, we can directly construct the transfer operator corresponding to a PEPS norm network from a given infinite PEPS as an InfiniteTransferPEPS object, which is a specific kind of MPSKit.InfiniteMPO.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"To construct a 1D transfer operator from a 2D PEPS state, we need to specify which direction should be facing north (dir=1 corresponding to north, counting clockwise) and which row of the network is selected from the north - but since we have a trivial unit cell there is only one row here:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"dir = 1 ## does not rotate the partition function\nrow = 1\nT = InfiniteTransferPEPS(ψ, dir, row)","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"single site MPSKit.InfiniteMPO{Tuple{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}}:\n╷  ⋮\n┼ O[1]: (TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')), TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')))\n╵  ⋮\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Since we'll find the leading eigenvector of mathbbT as a boundary MPS, we first need to construct an initial guess to supply to our algorithm. We can do this using the initialize_mps function, which constructs a random MPS with a specific virtual space for a given transfer operator. Here, we'll build an initial guess for the boundary MPS with a bond dimension of 20:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"mps₀ = initialize_mps(T, [ComplexSpace(20)])","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"single site InfiniteMPS:\n│   ⋮\n│ C[1]: TensorMap(ℂ^20 ← ℂ^20)\n├── AL[1]: TensorMap((ℂ^20 ⊗ ℂ^2 ⊗ (ℂ^2)') ← ℂ^20)\n│   ⋮\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Note that this will just construct a MPS with random Gaussian entries based on the physical spaces of the supplied transfer operator. Of course, one might come up with a better initial guess (leading to better convergence) depending on the application. To find the leading boundary MPS fixed point, we call leading_boundary using the MPSKit.VUMPS algorithm:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"mps, env, ϵ = leading_boundary(mps₀, T, VUMPS(; tol = 1.0e-6, verbosity = 2));","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"[ Info: VUMPS init:\tobj = +1.674563752306e+00 +3.035692829590e+00im\terr = 7.5576e-01\n[ Info: VUMPS conv 120:\tobj = +6.831610878310e+00 -9.694385865125e-09im\terr = 9.5145748821e-07\ttime = 7.42 sec\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"The norm of the state per unit cell is then given by the expectation value langle psi_textMPS  mathbbT  psi_textMPS rangle per site:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"norm_vumps = abs(prod(expectation_value(mps, T)))","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"6.831610878309698","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"This can be compared to the result obtained using CTMRG, where we see that the results match:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"env_ctmrg, = leading_boundary(CTMRGEnv(ψ, ComplexSpace(20)), ψ; tol = 1.0e-6, verbosity = 2)\nnorm_ctmrg = abs(norm(ψ, env_ctmrg))\n@show abs(norm_vumps - norm_ctmrg) / norm_vumps;","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"[ Info: CTMRG init:\tobj = -1.495741317009e+01 +3.091851579631e-01im\terr = 1.0000e+00\n[ Info: CTMRG conv 30:\tobj = +6.831603585666e+00\terr = 6.2262595139e-07\ttime = 0.40 sec\nabs(norm_vumps - norm_ctmrg) / norm_vumps = 1.0674852575113105e-6\n","category":"page"},{"location":"examples/boundary_mps/#Working-with-unit-cells","page":"Boundary MPS contractions of 2D networks","title":"Working with unit cells","text":"","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"For PEPS with non-trivial unit cells, the principle is exactly the same. The only difference is that now the transfer operator of the PEPS norm partition function has multiple rows or 'lines', each of which can be represented by an InfiniteTransferPEPS object. Such a multi-line transfer operator is represented by a PEPSKit.MultilineTransferPEPS object. In this case, the boundary MPS is an MultilineMPS object, which should be initialized by specifying a virtual space for each site in the partition function unit cell.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"First, we construct a PEPS with a 2 times 2 unit cell using the unitcell keyword argument and then define the corresponding transfer operator, where we again specify the direction which will be facing north:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"ψ_2x2 = InfinitePEPS(rand, ComplexF64, ComplexSpace(2), ComplexSpace(2); unitcell = (2, 2))\nT_2x2 = PEPSKit.MultilineTransferPEPS(ψ_2x2, dir);","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Now, the procedure is the same as before: We compute the norm once using VUMPS, once using CTMRG and then compare.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"mps₀_2x2 = initialize_mps(T_2x2, fill(ComplexSpace(20), 2, 2))\nmps_2x2, = leading_boundary(mps₀_2x2, T_2x2, VUMPS(; tol = 1.0e-6, verbosity = 2))\nnorm_2x2_vumps = abs(prod(expectation_value(mps_2x2, T_2x2)))\n\nenv_ctmrg_2x2, = leading_boundary(\n    CTMRGEnv(ψ_2x2, ComplexSpace(20)), ψ_2x2; tol = 1.0e-6, verbosity = 2\n)\nnorm_2x2_ctmrg = abs(norm(ψ_2x2, env_ctmrg_2x2))\n\n@show abs(norm_2x2_vumps - norm_2x2_ctmrg) / norm_2x2_vumps;","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"[ Info: VUMPS init:\tobj = +8.149302834396e+02 -8.860408249120e+01im\terr = 8.6172e-01\n┌ Warning: VUMPS cancel 200:\tobj = +1.046992011815e+05 -2.212181695361e+00im\terr = 6.9503579749e-03\ttime = 13.67 sec\n└ @ MPSKit ~/.julia/packages/MPSKit/cKwp2/src/algorithms/groundstate/vumps.jl:76\n[ Info: CTMRG init:\tobj = -1.240261729401e+02 -1.672150510263e+01im\terr = 1.0000e+00\n[ Info: CTMRG conv 47:\tobj = +1.046633714846e+05\terr = 1.6991268013e-07\ttime = 1.84 sec\nabs(norm_2x2_vumps - norm_2x2_ctmrg) / norm_2x2_vumps = 0.00034221579358038244\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Again, the results are compatible. Note that for larger unit cells and non-Hermitian PEPS the VUMPS algorithm may become unstable, in which case the CTMRG algorithm is recommended.","category":"page"},{"location":"examples/boundary_mps/#Contracting-PEPO-overlaps","page":"Boundary MPS contractions of 2D networks","title":"Contracting PEPO overlaps","text":"","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Using exactly the same machinery, we can contract 2D networks which encode the expectation value of a PEPO for a given PEPS state. As an example, we can consider the overlap of the PEPO correponding to the partition function of 3D classical Ising model with our random PEPS from before and evaluate the overlap langle psi  T  psi rangle.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"The classical Ising PEPO is defined as follows:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"function ising_pepo(β; unitcell = (1, 1, 1))\n    t = ComplexF64[exp(β) exp(-β); exp(-β) exp(β)]\n    q = sqrt(t)\n\n    O = zeros(2, 2, 2, 2, 2, 2)\n    O[1, 1, 1, 1, 1, 1] = 1\n    O[2, 2, 2, 2, 2, 2] = 1\n    @tensor o[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n    O = TensorMap(o, ℂ^2 ⊗ (ℂ^2)' ← ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')\n\n    return InfinitePEPO(O; unitcell)\nend;","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"To evaluate the overlap, we instantiate the PEPO and the corresponding InfiniteTransferPEPO in the right direction, on the right row of the partition function (trivial here):","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"T = ising_pepo(1)\ntransfer_pepo = InfiniteTransferPEPO(ψ, T, 1, 1)","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"single site MPSKit.InfiniteMPO{Tuple{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 4, Vector{ComplexF64}}}}:\n╷  ⋮\n┼ O[1]: (TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')), TensorMap(ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')), TensorMap((ℂ^2 ⊗ (ℂ^2)') ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')))\n╵  ⋮\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"As before, we converge the boundary MPS using VUMPS and then compute the expectation value:","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"mps₀_pepo = initialize_mps(transfer_pepo, [ComplexSpace(20)])\nmps_pepo, = leading_boundary(mps₀_pepo, transfer_pepo, VUMPS(; tol = 1.0e-6, verbosity = 2))\nnorm_pepo = abs(prod(expectation_value(mps_pepo, transfer_pepo)));\n@show norm_pepo;","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"[ Info: VUMPS init:\tobj = +2.655321432467e+01 +3.760603778362e-01im\terr = 8.9759e-01\n┌ Warning: VUMPS cancel 200:\tobj = +7.226394646816e+01 +6.223361199138e+00im\terr = 5.7986634490e-01\ttime = 37.47 sec\n└ @ MPSKit ~/.julia/packages/MPSKit/cKwp2/src/algorithms/groundstate/vumps.jl:76\nnorm_pepo = 72.5314289378628\n","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"These objects and routines can be used to optimize PEPS fixed points of 3D partition functions, see for example Vanderstraeten et al.","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"","category":"page"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/j1j2_su/#Three-site-simple-update-for-the-J_1-J_2-model","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"","category":"section"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"In this example, we will use SimpleUpdate imaginary time evolution to treat the two-dimensional J_1-J_2 model, which contains next-nearest-neighbour interactions:","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"H = J_1 sum_langle ij rangle mathbfS_i cdot mathbfS_j\n+ J_2 sum_langle langle ij rangle rangle mathbfS_i cdot mathbfS_j","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"Here we will exploit the U(1) spin rotation symmetry in the J_1-J_2 model. The goal will be to calculate the energy at J_1 = 1 and J_2 = 12, first using the simple update algorithm and then, to refine the energy estimate, using AD-based variational PEPS optimization.","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"We first import all required modules and seed the RNG:","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"using Random\nusing TensorKit, PEPSKit\nRandom.seed!(29385293);","category":"page"},{"location":"examples/j1j2_su/#Simple-updating-a-challenging-phase","page":"Three-site simple update for the J_1-J_2 model","title":"Simple updating a challenging phase","text":"","category":"section"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"Let's start by initializing an InfinitePEPS for which we set the required parameters as well as physical and virtual vector spaces. The SUWeight used by simple update will be initialized to identity matrices. We use the minimal unit cell size (2 times 2) required by the simple update algorithm for Hamiltonians with next-nearest-neighbour interactions:","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"Dbond, symm = 4, U1Irrep\nNr, Nc, J1 = 2, 2, 1.0\n\n# random initialization of 2x2 iPEPS (using real numbers) and SUWeight\nPspace = Vect[U1Irrep](1 // 2 => 1, -1 // 2 => 1)\nVspace = Vect[U1Irrep](0 => 2, 1 // 2 => 1, -1 // 2 => 1)\npeps = InfinitePEPS(rand, Float64, Pspace, Vspace; unitcell = (Nr, Nc));\nwts = SUWeight(peps);","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"The value J_2  J_1 = 05 corresponds to a possible spin liquid phase, which is challenging for SU to produce a relatively good state from random initialization. Therefore, we shall gradually increase J_2  J_1 from 0.1 to 0.5, each time initializing on the previously evolved PEPS:","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"dt, tol, maxiter = 1.0e-2, 1.0e-8, 30000\ncheck_interval = 4000\ntrscheme_peps = truncerr(1.0e-10) & truncdim(Dbond)\nalg = SimpleUpdate(dt, tol, maxiter, trscheme_peps)\nfor J2 in 0.1:0.1:0.5\n    H = real( ## convert Hamiltonian `LocalOperator` to real floats\n        j1_j2_model(ComplexF64, symm, InfiniteSquare(Nr, Nc); J1, J2, sublattice = false),\n    )\n    global peps, wts, = simpleupdate(peps, H, alg, wts; check_interval)\nend","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1/2=>1, -1/2=>1)\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 1.188e+00,  time = 28.698 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU conv 1832   :  dt = 1e-02,  weight diff = 9.942e-09,  time = 104.269 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 3.400e-04,  time = 0.084 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU conv 523    :  dt = 1e-02,  weight diff = 9.964e-09,  time = 19.444 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 3.524e-04,  time = 0.065 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU conv 611    :  dt = 1e-02,  weight diff = 9.848e-09,  time = 22.684 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 3.661e-04,  time = 0.036 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU conv 735    :  dt = 1e-02,  weight diff = 9.962e-09,  time = 27.379 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 3.823e-04,  time = 0.036 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU conv 901    :  dt = 1e-02,  weight diff = 9.994e-09,  time = 33.440 sec\n","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"After we reach J_2  J_1 = 05, we gradually decrease the evolution time step to obtain a more accurately evolved PEPS:","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"dts = [1.0e-3, 1.0e-4]\ntols = [1.0e-9, 1.0e-9]\nJ2 = 0.5\nH = real(j1_j2_model(ComplexF64, symm, InfiniteSquare(Nr, Nc); J1, J2, sublattice = false))\nfor (dt, tol) in zip(dts, tols)\n    alg′ = SimpleUpdate(dt, tol, maxiter, trscheme_peps)\n    global peps, wts, = simpleupdate(peps, H, alg′, wts; check_interval)\nend","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU iter 1      :  dt = 1e-03,  weight diff = 4.447e-04,  time = 0.036 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU conv 3236   :  dt = 1e-03,  weight diff = 9.998e-10,  time = 118.922 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU iter 1      :  dt = 1e-04,  weight diff = 4.436e-05,  time = 0.036 sec\n[ Info: Space of x-weight at [1, 1] = Rep[TensorKitSectors.U₁](0=>2, 1=>1, -1=>1)\n[ Info: SU conv 796    :  dt = 1e-04,  weight diff = 9.999e-10,  time = 29.313 sec\n","category":"page"},{"location":"examples/j1j2_su/#Computing-the-simple-update-energy-estimate","page":"Three-site simple update for the J_1-J_2 model","title":"Computing the simple update energy estimate","text":"","category":"section"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"Finally, we measure the ground-state energy by converging a CTMRG environment and computing the expectation value, where we first normalize tensors in the PEPS:","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"normalize!.(peps.A, Inf) ## normalize each PEPS tensor by largest element\nχenv = 32\ntrscheme_env = truncerr(1.0e-10) & truncdim(χenv)\nEspace = Vect[U1Irrep](0 => χenv ÷ 2, 1 // 2 => χenv ÷ 4, -1 // 2 => χenv ÷ 4)\nenv₀ = CTMRGEnv(rand, Float64, peps, Espace)\nenv, = leading_boundary(env₀, peps; tol = 1.0e-10, alg = :sequential, trscheme = trscheme_env);\nE = expectation_value(peps, H, env) / (Nr * Nc)","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"-0.4908482949689091","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"Let us compare that estimate with benchmark data obtained from the YASTN/peps-torch package. which utilizes AD-based PEPS optimization to find E_textref=-049425:","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"E_ref = -0.49425\n@show (E - E_ref) / abs(E_ref);","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"(E - E_ref) / abs(E_ref) = 0.00688255949639037\n","category":"page"},{"location":"examples/j1j2_su/#Variational-PEPS-optimization-using-AD","page":"Three-site simple update for the J_1-J_2 model","title":"Variational PEPS optimization using AD","text":"","category":"section"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"As a last step, we will use the SU-evolved PEPS as a starting point for a fixedpoint PEPS optimization. Note that we could have also used a sublattice-rotated version of H to fit the Hamiltonian onto a single-site unit cell which would require us to optimize fewer parameters and hence lead to a faster optimization. But here we instead take advantage of the already evolved peps, thus giving us a physical initial guess for the optimization. In order to break some of the C_4v symmetry of the PEPS, we will add a bit of noise to it","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"this is conviently done using MPSKit's randomize! function. (Breaking some of the spatial","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"symmetry can be advantageous for obtaining lower energies.)","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"using MPSKit: randomize!\n\nnoise_peps = InfinitePEPS(randomize!.(deepcopy(peps.A)))\npeps₀ = peps + 1.0e-1noise_peps\npeps_opt, env_opt, E_opt, = fixedpoint(\n    H, peps₀, env; optimizer_alg = (; tol = 1.0e-4, maxiter = 80)\n);","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"┌ Warning: the provided real environment was converted to a complex environment since :fixed mode generally produces complex gauges; use :diffgauge mode instead by passing gradient_alg=(; iterscheme=:diffgauge) to the fixedpoint keyword arguments to work with purely real environments\n└ @ PEPSKit ~/PEPSKit.jl/src/algorithms/optimization/peps_optimization.jl:204\n[ Info: LBFGS: initializing with f = -1.906213849448, ‖∇f‖ = 7.1073e-01\n[ Info: LBFGS: iter    1, time  652.92 s: f = -1.912844704754, ‖∇f‖ = 6.1629e-01, α = 1.00e+00, m = 0, nfg = 1\n[ Info: LBFGS: iter    2, time  664.36 s: f = -1.937956278406, ‖∇f‖ = 2.9827e-01, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    3, time  674.98 s: f = -1.943097558049, ‖∇f‖ = 2.0511e-01, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, time  686.77 s: f = -1.951025956511, ‖∇f‖ = 1.4073e-01, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    5, time  697.58 s: f = -1.955168827774, ‖∇f‖ = 1.2051e-01, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    6, time  708.82 s: f = -1.960117970278, ‖∇f‖ = 1.1611e-01, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    7, time  720.26 s: f = -1.961216550036, ‖∇f‖ = 1.6042e-01, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    8, time  731.38 s: f = -1.963394812594, ‖∇f‖ = 7.0500e-02, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter    9, time  742.56 s: f = -1.964678496250, ‖∇f‖ = 4.8767e-02, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   10, time  755.02 s: f = -1.965924354920, ‖∇f‖ = 6.0609e-02, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, time  767.32 s: f = -1.968120587109, ‖∇f‖ = 7.1520e-02, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, time  780.79 s: f = -1.969562403653, ‖∇f‖ = 9.5065e-02, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, time  793.16 s: f = -1.970582005143, ‖∇f‖ = 6.1728e-02, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, time  805.31 s: f = -1.971121191726, ‖∇f‖ = 3.2137e-02, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, time  818.38 s: f = -1.971554453753, ‖∇f‖ = 2.5404e-02, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, time  831.96 s: f = -1.972190061011, ‖∇f‖ = 3.2651e-02, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, time  844.26 s: f = -1.972856212899, ‖∇f‖ = 3.0425e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, time  857.72 s: f = -1.973765750218, ‖∇f‖ = 3.2201e-02, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   19, time  870.23 s: f = -1.974161602591, ‖∇f‖ = 3.5568e-02, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   20, time  883.37 s: f = -1.974478336877, ‖∇f‖ = 1.8682e-02, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   21, time  895.17 s: f = -1.974710833057, ‖∇f‖ = 1.5936e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   22, time  908.28 s: f = -1.974975741077, ‖∇f‖ = 2.3555e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, time  920.27 s: f = -1.975198522454, ‖∇f‖ = 2.7962e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, time  932.03 s: f = -1.975394248410, ‖∇f‖ = 2.5314e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, time  944.70 s: f = -1.975512455006, ‖∇f‖ = 2.9518e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, time  956.37 s: f = -1.975616686676, ‖∇f‖ = 1.6802e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, time  967.76 s: f = -1.975710241181, ‖∇f‖ = 1.5024e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, time  978.98 s: f = -1.975795271168, ‖∇f‖ = 1.2833e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, time  989.49 s: f = -1.975865143335, ‖∇f‖ = 2.3418e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, time 1002.34 s: f = -1.975957427509, ‖∇f‖ = 1.1381e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, time 1013.66 s: f = -1.976015850153, ‖∇f‖ = 1.0083e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, time 1024.96 s: f = -1.976080164930, ‖∇f‖ = 1.3119e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, time 1037.67 s: f = -1.976152913537, ‖∇f‖ = 1.4611e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, time 1048.69 s: f = -1.976198207069, ‖∇f‖ = 9.6971e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, time 1061.48 s: f = -1.976250601632, ‖∇f‖ = 9.3909e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, time 1073.15 s: f = -1.976291935078, ‖∇f‖ = 1.4028e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, time 1084.60 s: f = -1.976340224013, ‖∇f‖ = 1.0472e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, time 1097.26 s: f = -1.976377344626, ‖∇f‖ = 6.9713e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, time 1109.15 s: f = -1.976411251633, ‖∇f‖ = 6.5882e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, time 1122.25 s: f = -1.976451966987, ‖∇f‖ = 7.7535e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, time 1133.98 s: f = -1.976491819091, ‖∇f‖ = 1.1597e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, time 1145.62 s: f = -1.976529574561, ‖∇f‖ = 8.6643e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, time 1158.08 s: f = -1.976564683972, ‖∇f‖ = 7.6509e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, time 1168.84 s: f = -1.976599313000, ‖∇f‖ = 7.3612e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, time 1181.74 s: f = -1.976636515361, ‖∇f‖ = 1.8259e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   46, time 1193.53 s: f = -1.976680292934, ‖∇f‖ = 9.8005e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, time 1205.13 s: f = -1.976709176062, ‖∇f‖ = 8.4490e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, time 1216.87 s: f = -1.976735409874, ‖∇f‖ = 1.5557e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, time 1228.56 s: f = -1.976776133103, ‖∇f‖ = 1.3263e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, time 1241.43 s: f = -1.976811137668, ‖∇f‖ = 1.1320e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   51, time 1265.73 s: f = -1.976843854259, ‖∇f‖ = 1.4911e-02, α = 5.24e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   52, time 1278.46 s: f = -1.976923448868, ‖∇f‖ = 9.7919e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, time 1289.71 s: f = -1.976965559297, ‖∇f‖ = 7.7472e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, time 1301.37 s: f = -1.977044614238, ‖∇f‖ = 1.3785e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, time 1313.26 s: f = -1.977075753938, ‖∇f‖ = 2.0809e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   56, time 1325.74 s: f = -1.977139445975, ‖∇f‖ = 9.3821e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, time 1336.75 s: f = -1.977165276657, ‖∇f‖ = 7.5268e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, time 1348.24 s: f = -1.977219450466, ‖∇f‖ = 1.1473e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, time 1359.70 s: f = -1.977275314249, ‖∇f‖ = 1.9030e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, time 1372.04 s: f = -1.977335522183, ‖∇f‖ = 1.1000e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, time 1383.33 s: f = -1.977385273141, ‖∇f‖ = 9.0696e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   62, time 1394.84 s: f = -1.977430128301, ‖∇f‖ = 1.1553e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, time 1406.33 s: f = -1.977469892558, ‖∇f‖ = 8.2877e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, time 1418.79 s: f = -1.977495288994, ‖∇f‖ = 7.9121e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   65, time 1430.48 s: f = -1.977553209211, ‖∇f‖ = 8.8664e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, time 1443.25 s: f = -1.977597458477, ‖∇f‖ = 1.9052e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, time 1453.49 s: f = -1.977660134707, ‖∇f‖ = 1.1063e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, time 1465.98 s: f = -1.977685405419, ‖∇f‖ = 2.0774e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, time 1476.58 s: f = -1.977717638754, ‖∇f‖ = 8.7390e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, time 1488.80 s: f = -1.977730883236, ‖∇f‖ = 7.0000e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, time 1500.40 s: f = -1.977768669053, ‖∇f‖ = 8.1853e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, time 1511.94 s: f = -1.977810913385, ‖∇f‖ = 1.0740e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, time 1523.64 s: f = -1.977817034893, ‖∇f‖ = 1.7372e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, time 1535.46 s: f = -1.977859790789, ‖∇f‖ = 6.3128e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, time 1547.05 s: f = -1.977877604524, ‖∇f‖ = 5.9647e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, time 1559.50 s: f = -1.977904920943, ‖∇f‖ = 8.3968e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, time 1571.15 s: f = -1.977943608891, ‖∇f‖ = 1.1579e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, time 1582.92 s: f = -1.977960278758, ‖∇f‖ = 1.3388e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, time 1595.75 s: f = -1.977963135797, ‖∇f‖ = 1.0697e-02, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 80 iterations and time 1606.72 s: f = -1.977988611344, ‖∇f‖ = 1.6698e-02\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/lbfgs.jl:197\n","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"Finally, we compare the variationally optimized energy against the reference energy. Indeed, we find that the additional AD-based optimization improves the SU-evolved PEPS and leads to a more accurate energy estimate.","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"E_opt /= (Nr * Nc)\n@show E_opt\n@show (E_opt - E_ref) / abs(E_ref);","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"E_opt = -0.4944971528359841\n(E_opt - E_ref) / abs(E_ref) = -0.0005000563196440829\n","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"","category":"page"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/bose_hubbard/#Optimizing-the-U(1)-symmetric-Bose-Hubbard-model","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"","category":"section"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"This example demonstrates the simulation of the two-dimensional Bose-Hubbard model. In particular, the point will be to showcase the use of internal symmetries and finite particle densities in PEPS ground state searches. As we will see, incorporating symmetries into the simulation consists of initializing a symmetric Hamiltonian, PEPS state and CTM environment - made possible through TensorKit.","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"But first let's seed the RNG and import the required modules:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"using Random\nusing TensorKit, PEPSKit\nusing MPSKit: add_physical_charge\nRandom.seed!(2928528935);","category":"page"},{"location":"examples/bose_hubbard/#Defining-the-model","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Defining the model","text":"","category":"section"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"We will construct the Bose-Hubbard model Hamiltonian through the bose_hubbard_model, function from MPSKitModels as reexported by PEPSKit. We'll simulate the model in its Mott-insulating phase where the ratio Ut is large, since in this phase we expect the ground state to be well approximated by a PEPS with a manifest global U(1) symmetry. Furthermore, we'll impose a cutoff at 2 bosons per site, set the chemical potential to zero and use a simple 1 times 1 unit cell:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"t = 1.0\nU = 30.0\ncutoff = 2\nmu = 0.0\nlattice = InfiniteSquare(1, 1);","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Next, we impose an explicit global U(1) symmetry as well as a fixed particle number density in our simulations. We can do this by setting the symmetry argument of the Hamiltonian constructor to U1Irrep and passing one as the particle number density keyword argument n:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"symmetry = U1Irrep\nn = 1\nH = bose_hubbard_model(ComplexF64, symmetry, lattice; cutoff, t, U, n);","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Before we continue, it might be interesting to inspect the corresponding lattice physical spaces (which is here just a 1 times 1 matrix due to the single-site unit cell):","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"physical_spaces = physicalspace(H)","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"1×1 Matrix{TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}}:\n Rep[TensorKitSectors.U₁](0=>1, 1=>1, -1=>1)","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Note that the physical space contains U(1) charges -1, 0 and +1. Indeed, imposing a particle number density of +1 corresponds to shifting the physical charges by -1 to 're-center' the physical charges around the desired density. When we do this with a cutoff of two bosons per site, i.e. starting from U(1) charges 0, 1 and 2 on the physical level, we indeed get the observed charges.","category":"page"},{"location":"examples/bose_hubbard/#Characterizing-the-virtual-spaces","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Characterizing the virtual spaces","text":"","category":"section"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"When running PEPS simulations with explicit internal symmetries, specifying the structure of the virtual spaces of the PEPS and its environment becomes a bit more involved. For the environment, one could in principle allow the virtual space to be chosen dynamically during the boundary contraction using CTMRG by using a truncation scheme that allows for this (e.g. using alg=:truncdim or alg=:truncbelow to truncate to a fixed total bond dimension or singular value cutoff respectively). For the PEPS virtual space however, the structure has to be specified before the optimization.","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"While there are a host of techniques to do this in an informed way (e.g. starting from a simple update result), here we just specify the virtual space manually. Since we're dealing with a model at unit filling our physical space only contains integer U(1) irreps. Therefore, we'll build our PEPS and environment spaces using integer U(1) irreps centered around the zero charge:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"V_peps = U1Space(0 => 2, 1 => 1, -1 => 1)\nV_env = U1Space(0 => 6, 1 => 4, -1 => 4, 2 => 2, -2 => 2);","category":"page"},{"location":"examples/bose_hubbard/#Finding-the-ground-state","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Finding the ground state","text":"","category":"section"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Having defined our Hamiltonian and spaces, it is just a matter of plugging this into the optimization framework in the usual way to find the ground state. So, we first specify all algorithms and their tolerances:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"boundary_alg = (; tol = 1.0e-8, alg = :simultaneous, trscheme = (; alg = :fixedspace))\ngradient_alg = (; tol = 1.0e-6, maxiter = 10, alg = :eigsolver, iterscheme = :diffgauge)\noptimizer_alg = (; tol = 1.0e-4, alg = :lbfgs, maxiter = 150, ls_maxiter = 2, ls_maxfg = 2);","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"note: Note\nTaking CTMRG gradients and optimizing symmetric tensors tends to be more problematic than with dense tensors. In particular, this means that one frequently needs to tweak the boundary_alg, gradient_alg and optimizer_alg settings. There rarely is a general-purpose set of settings which will always work, so instead one has to adjust the simulation settings for each specific application. For example, it might help to switch between the CTMRG flavors alg=:simultaneous and alg=:sequential to improve convergence. The evaluation of the CTMRG gradient can be instable, so there it is advised to try the different iterscheme=:diffgauge and iterscheme=:fixed schemes as well as different alg keywords. Of course the tolerances of the algorithms and their subalgorithms also have to be compatible. For more details on the available options, see the fixedpoint docstring.","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"Keep in mind that the PEPS is constructed from a unit cell of spaces, so we have to make a matrix of V_peps spaces:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"virtual_spaces = fill(V_peps, size(lattice)...)\npeps₀ = InfinitePEPS(randn, ComplexF64, physical_spaces, virtual_spaces)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, V_env), peps₀; boundary_alg...);","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"[ Info: CTMRG init:\tobj = +1.693461429863e+00 +8.390974048721e-02im\terr = 1.0000e+00\n[ Info: CTMRG conv 19:\tobj = +1.181834754305e+01 -1.514596781954e-11im\terr = 3.6943031807e-09\ttime = 8.97 sec\n","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"And at last, we optimize (which might take a bit):","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"peps, env, E, info = fixedpoint(\n    H, peps₀, env₀; boundary_alg, gradient_alg, optimizer_alg, verbosity = 3\n)\n@show E;","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"[ Info: LBFGS: initializing with f = 9.360531870693, ‖∇f‖ = 1.6954e+01\n[ Info: LBFGS: iter    1, time  835.55 s: f = 0.114269686001, ‖∇f‖ = 6.0686e+00, α = 1.56e+02, m = 0, nfg = 7\n[ Info: LBFGS: iter    2, time  867.07 s: f = 0.059480938115, ‖∇f‖ = 7.2206e+00, α = 5.27e-01, m = 1, nfg = 2\n[ Info: LBFGS: iter    3, time  870.15 s: f = -0.046499452141, ‖∇f‖ = 1.6329e+00, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, time  873.04 s: f = -0.079703746750, ‖∇f‖ = 1.4901e+00, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    5, time  883.62 s: f = -0.125317852222, ‖∇f‖ = 3.2630e+00, α = 5.23e-01, m = 4, nfg = 3\n[ Info: LBFGS: iter    6, time  886.73 s: f = -0.163554919176, ‖∇f‖ = 1.2781e+00, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    7, time  890.21 s: f = -0.193532735237, ‖∇f‖ = 9.6932e-01, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    8, time  895.90 s: f = -0.208656321338, ‖∇f‖ = 7.0028e-01, α = 1.68e-01, m = 7, nfg = 2\n[ Info: LBFGS: iter    9, time  901.97 s: f = -0.220718433148, ‖∇f‖ = 4.3381e-01, α = 3.95e-01, m = 8, nfg = 2\n[ Info: LBFGS: iter   10, time  904.78 s: f = -0.227817345456, ‖∇f‖ = 5.8993e-01, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, time  906.29 s: f = -0.235906486649, ‖∇f‖ = 5.2265e-01, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, time  907.72 s: f = -0.245544719160, ‖∇f‖ = 3.6462e-01, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, time  909.56 s: f = -0.251717239130, ‖∇f‖ = 3.3074e-01, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, time  910.74 s: f = -0.256869388562, ‖∇f‖ = 2.9129e-01, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, time  911.84 s: f = -0.265345632631, ‖∇f‖ = 2.3580e-01, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, time  912.79 s: f = -0.267397827108, ‖∇f‖ = 3.0098e-01, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, time  914.23 s: f = -0.268894232390, ‖∇f‖ = 1.1725e-01, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, time  915.16 s: f = -0.269501536205, ‖∇f‖ = 8.8162e-02, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   19, time  916.08 s: f = -0.270154405721, ‖∇f‖ = 7.1880e-02, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   20, time  917.04 s: f = -0.270612692532, ‖∇f‖ = 6.5906e-02, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   21, time  918.52 s: f = -0.270978612734, ‖∇f‖ = 6.8050e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   22, time  919.42 s: f = -0.271251104411, ‖∇f‖ = 4.7832e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, time  920.32 s: f = -0.271592065725, ‖∇f‖ = 5.2245e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, time  921.24 s: f = -0.271907473230, ‖∇f‖ = 4.7783e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, time  922.68 s: f = -0.272188790518, ‖∇f‖ = 6.1727e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, time  923.58 s: f = -0.272341714938, ‖∇f‖ = 2.8588e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, time  924.50 s: f = -0.272416985001, ‖∇f‖ = 2.4404e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, time  925.41 s: f = -0.272488140123, ‖∇f‖ = 2.8167e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, time  926.85 s: f = -0.272607173823, ‖∇f‖ = 4.0551e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, time  927.74 s: f = -0.272669542118, ‖∇f‖ = 2.8338e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, time  928.65 s: f = -0.272710735515, ‖∇f‖ = 1.3171e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, time  929.56 s: f = -0.272737399244, ‖∇f‖ = 1.5064e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, time  931.01 s: f = -0.272785529235, ‖∇f‖ = 2.2115e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, time  931.92 s: f = -0.272869320156, ‖∇f‖ = 2.7454e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, time  932.84 s: f = -0.272917746471, ‖∇f‖ = 4.3200e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, time  933.76 s: f = -0.272982782958, ‖∇f‖ = 1.3998e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, time  935.17 s: f = -0.273001975617, ‖∇f‖ = 9.8876e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, time  936.04 s: f = -0.273014701175, ‖∇f‖ = 1.2336e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, time  936.94 s: f = -0.273032513148, ‖∇f‖ = 1.6628e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, time  937.86 s: f = -0.273047957579, ‖∇f‖ = 1.1548e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, time  939.28 s: f = -0.273056319317, ‖∇f‖ = 6.3307e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, time  940.16 s: f = -0.273062571624, ‖∇f‖ = 6.8219e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, time  941.04 s: f = -0.273067065008, ‖∇f‖ = 8.8510e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, time  941.96 s: f = -0.273077210295, ‖∇f‖ = 9.9163e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, time  944.28 s: f = -0.273086893655, ‖∇f‖ = 1.8575e-02, α = 5.12e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   46, time  945.20 s: f = -0.273103078820, ‖∇f‖ = 8.5718e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, time  946.11 s: f = -0.273110799145, ‖∇f‖ = 5.8581e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, time  947.54 s: f = -0.273120104689, ‖∇f‖ = 8.0410e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, time  948.44 s: f = -0.273131281118, ‖∇f‖ = 1.1878e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, time  949.35 s: f = -0.273143808372, ‖∇f‖ = 9.4250e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   51, time  950.28 s: f = -0.273153887747, ‖∇f‖ = 7.2150e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, time  951.68 s: f = -0.273158885697, ‖∇f‖ = 6.7195e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, time  952.56 s: f = -0.273161233672, ‖∇f‖ = 4.1608e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, time  953.46 s: f = -0.273163225686, ‖∇f‖ = 4.0591e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, time  954.35 s: f = -0.273166294475, ‖∇f‖ = 4.9791e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   56, time  955.75 s: f = -0.273169366216, ‖∇f‖ = 4.4714e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, time  956.64 s: f = -0.273172354203, ‖∇f‖ = 6.3685e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, time  957.53 s: f = -0.273175363803, ‖∇f‖ = 3.9908e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, time  958.43 s: f = -0.273177279555, ‖∇f‖ = 3.9256e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, time  959.83 s: f = -0.273182789738, ‖∇f‖ = 6.6561e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, time  961.64 s: f = -0.273184790994, ‖∇f‖ = 5.6288e-03, α = 5.40e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   62, time  962.54 s: f = -0.273186538838, ‖∇f‖ = 2.7232e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, time  963.95 s: f = -0.273187761549, ‖∇f‖ = 2.8879e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, time  964.83 s: f = -0.273189383930, ‖∇f‖ = 3.5846e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   65, time  965.74 s: f = -0.273193896466, ‖∇f‖ = 8.4511e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, time  966.67 s: f = -0.273197826544, ‖∇f‖ = 6.5550e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, time  968.12 s: f = -0.273200889068, ‖∇f‖ = 3.7358e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, time  969.01 s: f = -0.273203155185, ‖∇f‖ = 3.5407e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, time  969.90 s: f = -0.273203929982, ‖∇f‖ = 3.6210e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, time  970.80 s: f = -0.273204838272, ‖∇f‖ = 3.2225e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, time  972.23 s: f = -0.273208065807, ‖∇f‖ = 3.2081e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, time  974.02 s: f = -0.273208664671, ‖∇f‖ = 2.6363e-03, α = 3.31e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   73, time  974.93 s: f = -0.273209100927, ‖∇f‖ = 2.4085e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, time  976.34 s: f = -0.273212054415, ‖∇f‖ = 3.6766e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, time  977.24 s: f = -0.273214539457, ‖∇f‖ = 4.4246e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, time  979.08 s: f = -0.273216162290, ‖∇f‖ = 4.5551e-03, α = 4.50e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   77, time  980.50 s: f = -0.273217804190, ‖∇f‖ = 2.2785e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, time  981.39 s: f = -0.273218883441, ‖∇f‖ = 2.0806e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, time  982.29 s: f = -0.273220350356, ‖∇f‖ = 2.6261e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   80, time  983.22 s: f = -0.273220936494, ‖∇f‖ = 6.7764e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   81, time  984.67 s: f = -0.273223126428, ‖∇f‖ = 2.3171e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   82, time  985.56 s: f = -0.273223758728, ‖∇f‖ = 1.4729e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   83, time  986.46 s: f = -0.273224312383, ‖∇f‖ = 1.6490e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   84, time  987.36 s: f = -0.273224595281, ‖∇f‖ = 5.4564e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   85, time  988.77 s: f = -0.273225489255, ‖∇f‖ = 2.6429e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   86, time  989.66 s: f = -0.273226533423, ‖∇f‖ = 1.3412e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   87, time  990.56 s: f = -0.273227338626, ‖∇f‖ = 1.9615e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   88, time  991.47 s: f = -0.273228071304, ‖∇f‖ = 2.3684e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   89, time  992.90 s: f = -0.273228783978, ‖∇f‖ = 2.1046e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   90, time  993.79 s: f = -0.273229430170, ‖∇f‖ = 1.6761e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   91, time  994.71 s: f = -0.273230395023, ‖∇f‖ = 2.3630e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   92, time  995.62 s: f = -0.273230913396, ‖∇f‖ = 4.6952e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   93, time  997.05 s: f = -0.273231822793, ‖∇f‖ = 2.4311e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   94, time  997.94 s: f = -0.273233027133, ‖∇f‖ = 2.0551e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   95, time  998.86 s: f = -0.273234061771, ‖∇f‖ = 3.0019e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   96, time  999.77 s: f = -0.273235399472, ‖∇f‖ = 3.6034e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   97, time 1001.23 s: f = -0.273236063107, ‖∇f‖ = 3.5368e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   98, time 1002.12 s: f = -0.273236795508, ‖∇f‖ = 1.2966e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   99, time 1003.01 s: f = -0.273237171417, ‖∇f‖ = 1.7109e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  100, time 1003.93 s: f = -0.273237667965, ‖∇f‖ = 2.2989e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  101, time 1006.24 s: f = -0.273237900160, ‖∇f‖ = 2.7773e-03, α = 4.53e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter  102, time 1007.14 s: f = -0.273238275586, ‖∇f‖ = 1.4700e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  103, time 1008.06 s: f = -0.273238523826, ‖∇f‖ = 8.5901e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  104, time 1009.47 s: f = -0.273238752012, ‖∇f‖ = 1.6628e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  105, time 1010.37 s: f = -0.273239111781, ‖∇f‖ = 2.6098e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  106, time 1011.27 s: f = -0.273239819089, ‖∇f‖ = 3.4353e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  107, time 1012.19 s: f = -0.273240369600, ‖∇f‖ = 4.2704e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  108, time 1013.60 s: f = -0.273241162430, ‖∇f‖ = 1.8052e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  109, time 1014.50 s: f = -0.273241475226, ‖∇f‖ = 1.0380e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  110, time 1015.42 s: f = -0.273241711280, ‖∇f‖ = 1.6135e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  111, time 1016.34 s: f = -0.273241988851, ‖∇f‖ = 2.1980e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  112, time 1017.75 s: f = -0.273242526227, ‖∇f‖ = 2.4062e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  113, time 1019.58 s: f = -0.273242706890, ‖∇f‖ = 2.5536e-03, α = 2.41e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter  114, time 1020.49 s: f = -0.273243063849, ‖∇f‖ = 1.2275e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  115, time 1021.91 s: f = -0.273243259716, ‖∇f‖ = 8.8173e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  116, time 1022.80 s: f = -0.273243390541, ‖∇f‖ = 1.2958e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  117, time 1023.71 s: f = -0.273243624187, ‖∇f‖ = 1.6522e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  118, time 1024.65 s: f = -0.273243975601, ‖∇f‖ = 2.4195e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  119, time 1026.08 s: f = -0.273244470238, ‖∇f‖ = 1.8095e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  120, time 1026.98 s: f = -0.273244906935, ‖∇f‖ = 1.1191e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  121, time 1027.88 s: f = -0.273245198892, ‖∇f‖ = 1.8385e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  122, time 1028.78 s: f = -0.273245436436, ‖∇f‖ = 1.7034e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  123, time 1030.25 s: f = -0.273245814839, ‖∇f‖ = 1.9152e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  124, time 1031.16 s: f = -0.273246901974, ‖∇f‖ = 2.4769e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  125, time 1032.06 s: f = -0.273247151000, ‖∇f‖ = 4.6605e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  126, time 1032.99 s: f = -0.273247895600, ‖∇f‖ = 1.6220e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  127, time 1034.43 s: f = -0.273248199597, ‖∇f‖ = 1.2653e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  128, time 1035.35 s: f = -0.273248721139, ‖∇f‖ = 2.0361e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  129, time 1036.28 s: f = -0.273249366483, ‖∇f‖ = 2.4923e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  130, time 1037.20 s: f = -0.273250035605, ‖∇f‖ = 3.6119e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  131, time 1038.61 s: f = -0.273250756926, ‖∇f‖ = 2.1636e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  132, time 1039.54 s: f = -0.273251085961, ‖∇f‖ = 1.1672e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  133, time 1040.45 s: f = -0.273251307038, ‖∇f‖ = 1.3676e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  134, time 1041.38 s: f = -0.273251484982, ‖∇f‖ = 1.6617e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  135, time 1042.81 s: f = -0.273251929354, ‖∇f‖ = 1.8732e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  136, time 1044.65 s: f = -0.273252100396, ‖∇f‖ = 1.8209e-03, α = 4.46e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter  137, time 1045.58 s: f = -0.273252323246, ‖∇f‖ = 1.1334e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  138, time 1047.02 s: f = -0.273252503681, ‖∇f‖ = 1.3498e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  139, time 1047.93 s: f = -0.273252679906, ‖∇f‖ = 1.8133e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  140, time 1048.85 s: f = -0.273253041604, ‖∇f‖ = 1.9959e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  141, time 1049.78 s: f = -0.273253394913, ‖∇f‖ = 2.7713e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  142, time 1051.23 s: f = -0.273253983127, ‖∇f‖ = 1.4203e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  143, time 1052.13 s: f = -0.273254647402, ‖∇f‖ = 2.1096e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  144, time 1053.05 s: f = -0.273255259635, ‖∇f‖ = 2.8357e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  145, time 1053.99 s: f = -0.273256194806, ‖∇f‖ = 3.9979e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  146, time 1056.37 s: f = -0.273256707532, ‖∇f‖ = 2.3435e-03, α = 4.40e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter  147, time 1057.29 s: f = -0.273257209926, ‖∇f‖ = 1.0557e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  148, time 1058.22 s: f = -0.273257438291, ‖∇f‖ = 9.7121e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  149, time 1059.67 s: f = -0.273257563053, ‖∇f‖ = 1.1509e-03, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 150 iterations and time 1060.58 s: f = -0.273257823816, ‖∇f‖ = 1.5465e-03\n└ @ OptimKit ~/.julia/packages/OptimKit/G6i79/src/lbfgs.jl:197\nE = -0.2732578238158397\n","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"We can compare our PEPS result to the energy obtained using a cylinder-MPS calculation using a cylinder circumference of L_y = 7 and a bond dimension of 446, which yields E = -0273284888:","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"E_ref = -0.273284888\n@show (E - E_ref) / E_ref;","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"(E - E_ref) / E_ref = -9.90328603911651e-5\n","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"","category":"page"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/hubbard_su/#Simple-update-for-the-Fermi-Hubbard-model-at-half-filling","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"","category":"section"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Once again, we consider the Hubbard model but this time we obtain the ground-state PEPS by imaginary time evolution. In particular, we'll use the SimpleUpdate algorithm. As a reminder, we define the Hubbard model as","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"H = -t sum_langle ij rangle sum_sigma left( c_isigma^+ c_jsigma^- -\nc_isigma^- c_jsigma^+ right) + U sum_i n_iuparrown_idownarrow - mu sum_i n_i","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"with sigma in uparrowdownarrow and n_isigma = c_isigma^+ c_isigma^-.","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Let's get started by seeding the RNG and importing the required modules:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"using Random\nusing TensorKit, PEPSKit\nRandom.seed!(12329348592498);","category":"page"},{"location":"examples/hubbard_su/#Defining-the-Hamiltonian","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Defining the Hamiltonian","text":"","category":"section"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"First, we define the Hubbard model at t=1 hopping and U=6 using Trivial sectors for the particle and spin symmetries, and set mu = U2 for half-filling. The model will be constructed on a 2 times 2 unit cell, so we have:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"t = 1\nU = 6\nNr, Nc = 2, 2\nH = hubbard_model(Float64, Trivial, Trivial, InfiniteSquare(Nr, Nc); t, U, mu = U / 2);\nphysical_space = Vect[fℤ₂](0 => 2, 1 => 2);","category":"page"},{"location":"examples/hubbard_su/#Running-the-simple-update-algorithm","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Running the simple update algorithm","text":"","category":"section"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Suppose the goal is to use imaginary-time simple update to optimize a PEPS with bond dimension D = 8, and 2 times 2 unit cells. For a challenging model like the Hubbard model, a naive evolution starting from a random PEPS at D = 8 will almost always produce a sub-optimal state. In this example, we shall demonstrate some common practices to improve SU result.","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"First, we shall use a small D for the random PEPS initialization, which is chosen as 4 here. For convenience, here we work with real tensors with Float64 entries. The bond weights are still initialized as identity matrices.","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"virtual_space = Vect[fℤ₂](0 => 2, 1 => 2)\npeps = InfinitePEPS(rand, Float64, physical_space, virtual_space; unitcell = (Nr, Nc));\nwts = SUWeight(peps);","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Starting from the random state, we first use a relatively large evolution time step dt = 1e-2. After convergence at D = 4, to avoid stucking at some bad local minimum, we first increase D to 12, and drop it back to D = 8 after a while. Afterwards, we keep D = 8 and gradually decrease dt to 1e-4 to improve convergence.","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"dts = [1.0e-2, 1.0e-2, 1.0e-3, 4.0e-4, 1.0e-4]\ntols = [1.0e-7, 1.0e-7, 1.0e-8, 1.0e-8, 1.0e-8]\nDs = [4, 12, 8, 8, 8]\nmaxiter = 20000\n\nfor (dt, tol, Dbond) in zip(dts, tols, Ds)\n    trscheme = truncerr(1.0e-10) & truncdim(Dbond)\n    alg = SimpleUpdate(dt, tol, maxiter, trscheme)\n    global peps, wts, = simpleupdate(\n        peps, H, alg, wts; bipartite = false, check_interval = 2000\n    )\nend","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>2, 1=>2)\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 1.316e+00,  time = 27.486 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>2, 1=>2)\n[ Info: SU conv 1045   :  dt = 1e-02,  weight diff = 9.843e-08,  time = 34.956 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>6, 1=>6)\n[ Info: SU iter 1      :  dt = 1e-02,  weight diff = 6.459e-06,  time = 0.077 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>6, 1=>6)\n[ Info: SU conv 584    :  dt = 1e-02,  weight diff = 9.946e-08,  time = 42.322 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>3, 1=>5)\n[ Info: SU iter 1      :  dt = 1e-03,  weight diff = 5.245e-03,  time = 0.235 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>3, 1=>5)\n[ Info: SU iter 2000   :  dt = 1e-03,  weight diff = 1.418e-07,  time = 0.018 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>3, 1=>5)\n[ Info: SU conv 3791   :  dt = 1e-03,  weight diff = 9.990e-09,  time = 78.783 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>3, 1=>5)\n[ Info: SU iter 1      :  dt = 4e-04,  weight diff = 3.256e-04,  time = 0.018 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>3, 1=>5)\n[ Info: SU iter 2000   :  dt = 4e-04,  weight diff = 1.888e-08,  time = 0.024 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>3, 1=>5)\n[ Info: SU conv 3034   :  dt = 4e-04,  weight diff = 9.997e-09,  time = 62.113 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>3, 1=>5)\n[ Info: SU iter 1      :  dt = 1e-04,  weight diff = 1.627e-04,  time = 0.024 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>3, 1=>5)\n[ Info: SU iter 2000   :  dt = 1e-04,  weight diff = 1.532e-08,  time = 0.018 sec\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0=>3, 1=>5)\n[ Info: SU conv 2916   :  dt = 1e-04,  weight diff = 9.997e-09,  time = 59.560 sec\n","category":"page"},{"location":"examples/hubbard_su/#Computing-the-ground-state-energy","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Computing the ground-state energy","text":"","category":"section"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"In order to compute the energy expectation value with evolved PEPS, we need to converge a CTMRG environment on it. We first converge an environment with a small enviroment dimension and then use that to initialize another run with bigger environment dimension. We'll use trscheme=truncdim(χ) for that such that the dimension is increased during the second CTMRG run:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"χenv₀, χenv = 6, 16\nenv_space = Vect[fℤ₂](0 => χenv₀ / 2, 1 => χenv₀ / 2)\nnormalize!.(peps.A, Inf)\nenv = CTMRGEnv(rand, Float64, peps, env_space)\nfor χ in [χenv₀, χenv]\n    global env, = leading_boundary(\n        env, peps; alg = :sequential, tol = 1.0e-8, maxiter = 50, trscheme = truncdim(χ)\n    )\nend","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"[ Info: CTMRG init:\tobj = +4.034556135739e-13\terr = 1.0000e+00\n┌ Warning: CTMRG cancel 50:\tobj = +1.777694990783e+00\terr = 2.1447151954e-06\ttime = 18.75 sec\n└ @ PEPSKit ~/PEPSKit.jl/src/algorithms/ctmrg/ctmrg.jl:152\n[ Info: CTMRG init:\tobj = +1.777694990783e+00\terr = 1.0000e+00\n[ Info: CTMRG conv 7:\tobj = +1.781063096355e+00\terr = 3.5793745596e-10\ttime = 21.32 sec\n","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"We measure the energy by computing the H expectation value, where we have to make sure to normalize with respect to the unit cell to obtain the energy per site:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"E = expectation_value(peps, H, env) / (Nr * Nc)\n@show E;","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"E = -3.652497562261351\n","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Finally, we can compare the obtained ground-state energy against the literature, namely the QMC estimates from Qin et al.. We find that the results generally agree:","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Es_exact = Dict(0 => -1.62, 2 => -0.176, 4 => 0.8603, 6 => -0.6567, 8 => -0.5243)\nE_exact = Es_exact[U] - U / 2\n@show (E - E_exact) / abs(E_exact);","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"(E - E_exact) / abs(E_exact) = 0.001149243235334783\n","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"","category":"page"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#PEPSKit.jl","page":"Home","title":"PEPSKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for working with projected entangled-pair states","category":"page"},{"location":"","page":"Home","title":"Home","text":"It contracts, it optimizes, it may break.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed through the Julia general registry, via the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PEPSKit","category":"page"},{"location":"#Key-features","page":"Home","title":"Key features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Construction and manipulation of infinite projected entangled-pair states (PEPS)\nContraction of infinite PEPS using the corner transfer matrix renormalization group (CTMRG) and boundary MPS methods\nNative support for symmetric tensors through TensorKit, including fermionic tensors\nPEPS optimization using automatic differentiation (AD) provided through Zygote\nImaginary time evolution algorithms\nSupport for PEPS with generic unit cells\nSupport for classical 2D partition functions and projected entangled-pair operators (PEPOs)\nExtensible system for custom states, operators and algorithms","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After following the installation process, it should now be possible to load the packages and start simulating. For example, in order to obtain the ground state of the 2D Heisenberg model, we can use the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorKit, PEPSKit\n\n# construct the Hamiltonian\nH = heisenberg_XYZ(InfiniteSquare())\n\n# configure the parameters\nD = 2\nχ = 20\nctmrg_tol = 1e-10\ngrad_tol = 1e-4\n\n# initialize a PEPS and CTMRG environment\npeps₀ = InfinitePEPS(ComplexSpace(2), ComplexSpace(D))\nenv₀, = leading_boundary(CTMRGEnv(peps₀, ComplexSpace(χ)), peps₀; tol=ctmrg_tol)\n\n# ground state search\npeps, env, E, = fixedpoint(H, peps₀, env₀; tol=grad_tol, boundary_alg=(; tol=ctmrg_tol))\n\n@show E # -0.6625...","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more in-depth explanation of this simple example, check the Optimizing the 2D Heisenberg model tutorial or consult the Manual pages.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A detailed rundown of PEPSKit's features can be found in the Manual section (not yet complete, more coming soon™), including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/models.md\", \"man/multithreading.md\", \"man/precompilation.md\"]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, we provide a list of commented examples in the Examples section which showcases most of PEPSKit's capabilities in action.","category":"page"},{"location":"man/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"man/operators/","page":"Operators","title":"Operators","text":"note: Note\nThis section is still under construction.","category":"page"}]
}
