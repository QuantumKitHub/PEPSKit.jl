<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The 2D classical Ising model using CTMRG · PEPSKit.jl</title><meta name="title" content="The 2D classical Ising model using CTMRG · PEPSKit.jl"/><meta property="og:title" content="The 2D classical Ising model using CTMRG · PEPSKit.jl"/><meta property="twitter:title" content="The 2D classical Ising model using CTMRG · PEPSKit.jl"/><meta name="description" content="Documentation for PEPSKit.jl."/><meta property="og:description" content="Documentation for PEPSKit.jl."/><meta property="twitter:description" content="Documentation for PEPSKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PEPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PEPSKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/models/">Models</a></li><li><a class="tocitem" href="../../man/multithreading/">Multithreading</a></li><li><a class="tocitem" href="../../man/precompilation/">Precompilation using PrecompileTools.jl</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">Overview</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../heisenberg/">Optimizing the 2D Heisenberg model</a></li><li><a class="tocitem" href="../bose_hubbard/">Optimizing the <span>$U(1)$</span>-symmetric Bose-Hubbard model</a></li><li><a class="tocitem" href="../xxz/">Néel order in the <span>$U(1)$</span>-symmetric XXZ model</a></li><li><a class="tocitem" href="../fermi_hubbard/">Fermi-Hubbard model with <span>$f\mathbb{Z}_2 \boxtimes U(1)$</span> symmetry, at large <span>$U$</span> and half-filling</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Time Evolution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../heisenberg_su/">Simple update for the Heisenberg model</a></li><li><a class="tocitem" href="../hubbard_su/">Simple update for the Fermi-Hubbard model at half-filling</a></li><li><a class="tocitem" href="../j1j2_su/">Three-site simple update for the <span>$J_1$</span>-<span>$J_2$</span> model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox" checked/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Partition Functions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>The 2D classical Ising model using CTMRG</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-partition-function"><span>Defining the partition function</span></a></li><li><a class="tocitem" href="#Contracting-the-partition-function"><span>Contracting the partition function</span></a></li><li><a class="tocitem" href="#Comparing-against-the-exact-Onsager-solution"><span>Comparing against the exact Onsager solution</span></a></li></ul></li><li><a class="tocitem" href="../3d_ising_partition_function/">The 3D classical Ising model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Boundary MPS</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../boundary_mps/">Boundary MPS contractions of 2D networks</a></li></ul></li></ul></li><li><a class="tocitem" href="../../lib/lib/">Library</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Partition Functions</a></li><li class="is-active"><a href>The 2D classical Ising model using CTMRG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The 2D classical Ising model using CTMRG</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/PEPSKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/master/examples/2d_ising_partition_function/main.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p><a href="https://mybinder.org/v2/gh/QuantumKitHub/PEPSKit.jl/gh-pages?filepath=dev/examples/2d_ising_partition_function/main.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/QuantumKitHub/PEPSKit.jl/blob/gh-pages/dev/examples/2d_ising_partition_function/main.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a> <a href="https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/QuantumKitHub/PEPSKit.jl/examples/tree/gh-pages/dev/examples/2d_ising_partition_function"><img src="https://img.shields.io/badge/download-project-orange" alt/></a></p><h1 id="e_2d_ising"><a class="docs-heading-anchor" href="#e_2d_ising">The 2D classical Ising model using CTMRG</a><a id="e_2d_ising-1"></a><a class="docs-heading-anchor-permalink" href="#e_2d_ising" title="Permalink"></a></h1><p>While PEPSKit has a lot of use in quantum systems, describing states using InfinitePEPS that can be contracted via CTMRG or <a href="../boundary_mps/#e_boundary_mps">boundary MPS techniques</a>, here we shift our focus to classical physics. We consider the 2D classical Ising model and compute its partition function defined as:</p><p class="math-container">\[\mathcal{Z}(\beta) = \sum_{\{s\}} \exp(-\beta H(s)) \text{ with } H(s) = -J \sum_{\langle i, j \rangle} s_i s_j .\]</p><p>where the classical spins <span>$s_i \in \{+1, -1\}$</span> are located on the vertices <span>$i$</span> of a 2D square lattice. The idea is to encode the partition function as an infinite square network consisting of local rank-4 tensors, which can then be contracted using CTMRG. An infinite square network of these rank-4 tensors can be represented as an <a href="../../lib/lib/#PEPSKit.InfinitePartitionFunction"><code>InfinitePartitionFunction</code></a> object, as we will see.</p><p>But first, let&#39;s seed the RNG and import all required modules:</p><pre><code class="language-julia hljs">using Random, LinearAlgebra
using TensorKit, PEPSKit
using QuadGK
Random.seed!(234923);</code></pre><h2 id="Defining-the-partition-function"><a class="docs-heading-anchor" href="#Defining-the-partition-function">Defining the partition function</a><a id="Defining-the-partition-function-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-partition-function" title="Permalink"></a></h2><p>The first step is to define the rank-4 tensor that, when contracted on a square lattice, evaluates to the partition function value at a given <span>$\beta$</span>. This is done through a <a href="../../references/#haegeman_diagonalizing_2017">fairly generic procedure</a> where the interaction weights are distributed among vertex tensors in an appropriate way. Concretely, here we first define a &#39;link&#39; matrix containing the Boltzmann weights associated to all possible spin configurations across a given link on the lattice. Next, we define site tensors as delta-tensors that ensiure that the spin value on all adjacent links is the same. Since we only want tensors on the sites in the end, we can symmetrically absorb the link weight tensors into the site tensors, which gives us exactly the kind of network we&#39;re looking for. Since we later want to compute the magnetization and energy to check our results, we define the appropriate rank-4 tensors here as well while we&#39;re at it.</p><pre><code class="language-julia hljs">function classical_ising(; beta = log(1 + sqrt(2)) / 2, J = 1.0)
    K = beta * J

    # Boltzmann weights
    t = ComplexF64[exp(K) exp(-K); exp(-K) exp(K)]
    r = eigen(t)
    nt = r.vectors * sqrt(Diagonal(r.values)) * r.vectors

    # local partition function tensor
    O = zeros(2, 2, 2, 2)
    O[1, 1, 1, 1] = 1
    O[2, 2, 2, 2] = 1
    @tensor o[-1 -2; -3 -4] := O[3 4; 2 1] * nt[-3; 3] * nt[-4; 4] * nt[-2; 2] * nt[-1; 1]

    # magnetization tensor
    M = copy(O)
    M[2, 2, 2, 2] *= -1
    @tensor m[-1 -2; -3 -4] := M[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * nt[-3; 3] * nt[-4; 4]

    # bond interaction tensor and energy-per-site tensor
    e = ComplexF64[-J J; J -J] .* nt
    @tensor e_hor[-1 -2; -3 -4] :=
        O[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * nt[-3; 3] * e[-4; 4]
    @tensor e_vert[-1 -2; -3 -4] :=
        O[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * e[-3; 3] * nt[-4; 4]
    e = e_hor + e_vert

    # fixed tensor map space for all three
    TMS = ℂ^2 ⊗ ℂ^2 ← ℂ^2 ⊗ ℂ^2

    return TensorMap(o, TMS), TensorMap(m, TMS), TensorMap(e, TMS)
end;</code></pre><p>So let&#39;s initialize these tensors at inverse temperature <span>$\beta=0.6$</span>, check that they are indeed rank-4 and construct the corresponding <code>InfinitePartitionFunction</code>:</p><pre><code class="language-julia hljs">beta = 0.6
O, M, E = classical_ising(; beta)
@show space(O)
Z = InfinitePartitionFunction(O)</code></pre><pre><code class="nohighlight hljs">InfinitePartitionFunction{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}[TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):
[:, :, 1, 1] =
  3.169519816780443 + 0.0im  0.4999999999999995 + 0.0im
 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im

[:, :, 2, 1] =
 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im
 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im

[:, :, 1, 2] =
 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im
 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im

[:, :, 2, 2] =
 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im
 0.4999999999999995 + 0.0im   3.169519816780443 + 0.0im
;;])</code></pre><h2 id="Contracting-the-partition-function"><a class="docs-heading-anchor" href="#Contracting-the-partition-function">Contracting the partition function</a><a id="Contracting-the-partition-function-1"></a><a class="docs-heading-anchor-permalink" href="#Contracting-the-partition-function" title="Permalink"></a></h2><p>Next, we can contract the partition function as per usual by constructing a <code>CTMRGEnv</code> with a specified environment virtual space and calling <code>leading_boundary</code> with appropriate settings:</p><pre><code class="language-julia hljs">Venv = ℂ^20
env₀ = CTMRGEnv(Z, Venv)
env, = leading_boundary(env₀, Z; tol = 1.0e-8, maxiter = 500);</code></pre><pre><code class="nohighlight hljs">[ Info: CTMRG init:	obj = +1.784252138312e+00 -1.557258880375e+00im	err = 1.0000e+00
[ Info: CTMRG conv 63:	obj = +3.353928644031e+00	err = 4.6032264022e-09	time = 5.74 sec
</code></pre><p>Note that CTMRG environments for partition functions differ from the PEPS environments only by the edge tensors. Instead of two legs connecting the edges and the PEPS-PEPS sandwich, there is only one leg connecting the edges and the partition function tensor, meaning that the edge tensors are now rank-3:</p><pre><code class="language-julia hljs">space.(env.edges)</code></pre><pre><code class="nohighlight hljs">4×1×1 Array{TensorKit.TensorMapSpace{TensorKit.ComplexSpace, 2, 1}, 3}:
[:, :, 1] =
 (ℂ^20 ⊗ ℂ^2) ← ℂ^20
 (ℂ^20 ⊗ ℂ^2) ← ℂ^20
 (ℂ^20 ⊗ (ℂ^2)&#39;) ← ℂ^20
 (ℂ^20 ⊗ (ℂ^2)&#39;) ← ℂ^20</code></pre><p>To compute the value of the partition function, we have to contract <code>Z</code> with the converged environment using <a href="../../lib/lib/#PEPSKit.network_value-Tuple{InfiniteSquareNetwork, CTMRGEnv}"><code>network_value</code></a>. Additionally, we will compute the magnetization and energy (per site), again using <a href="../../lib/lib/#MPSKit.expectation_value-Tuple{Any, Any}"><code>expectation_value</code></a> but this time also specifying the index in the unit cell where we want to insert the local tensor:</p><pre><code class="language-julia hljs">λ = network_value(Z, env)
m = expectation_value(Z, (1, 1) =&gt; M, env)
e = expectation_value(Z, (1, 1) =&gt; E, env)
@show λ m e;</code></pre><pre><code class="nohighlight hljs">λ = 3.353928644031378 + 7.047583922370844e-16im
m = 0.9736086674403002 + 0.0im
e = -1.8637796145082448 + 1.4610281815259345e-16im
</code></pre><h2 id="Comparing-against-the-exact-Onsager-solution"><a class="docs-heading-anchor" href="#Comparing-against-the-exact-Onsager-solution">Comparing against the exact Onsager solution</a><a id="Comparing-against-the-exact-Onsager-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-against-the-exact-Onsager-solution" title="Permalink"></a></h2><p>In order to assess our results, we will compare against the <a href="https://en.wikipedia.org/wiki/Square_lattice_Ising_model#Exact_solution">exact Onsager solution</a> of the 2D classical Ising model. To that end, we compute the exact free energy, magnetization and energy per site (where we use <code>quadgk</code> to perform integrals of an auxiliary variable from <span>$0$</span> to <span>$\pi/2$</span>):</p><pre><code class="language-julia hljs">function classical_ising_exact(; beta = log(1 + sqrt(2)) / 2, J = 1.0)
    K = beta * J

    k = 1 / sinh(2 * K)^2
    F = quadgk(
        theta -&gt; log(cosh(2 * K)^2 + 1 / k * sqrt(1 + k^2 - 2 * k * cos(2 * theta))), 0, pi
    )[1]
    f = -1 / beta * (log(2) / 2 + 1 / (2 * pi) * F)

    m = 1 - (sinh(2 * K))^(-4) &gt; 0 ? (1 - (sinh(2 * K))^(-4))^(1 / 8) : 0

    E = quadgk(theta -&gt; 1 / sqrt(1 - (4 * k) * (1 + k)^(-2) * sin(theta)^2), 0, pi / 2)[1]
    e = -J * cosh(2 * K) / sinh(2 * K) * (1 + 2 / pi * (2 * tanh(2 * K)^2 - 1) * E)

    return f, m, e
end

f_exact, m_exact, e_exact = classical_ising_exact(; beta);</code></pre><p>And indeed, we do find agreement between the exact and CTMRG values (keeping in mind that energy accuracy is limited by the environment dimension and the lack of proper extrapolation):</p><pre><code class="language-julia hljs">@show (-log(λ) / beta - f_exact) / f_exact
@show (abs(m) - abs(m_exact)) / abs(m_exact)
@show (e - e_exact) / e_exact;</code></pre><pre><code class="nohighlight hljs">(-(log(λ)) / beta - f_exact) / f_exact = -8.807417386354037e-16 + 1.736415096112634e-16im
(abs(m) - abs(m_exact)) / abs(m_exact) = -3.420952570843561e-16
(e - e_exact) / e_exact = -0.02373206809908996 - 7.653023727290916e-17im
</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../j1j2_su/">« Three-site simple update for the <span>$J_1$</span>-<span>$J_2$</span> model</a><a class="docs-footer-nextpage" href="../3d_ising_partition_function/">The 3D classical Ising model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 11:15">Wednesday 25 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
