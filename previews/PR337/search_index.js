var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"Corboz, P. (2016). Variational optimization with infinite projected entangled-pair states. Phys. Rev. B 94, 035133.\n\n\n\nEvenbly, G. (2018). Gauge fixing, canonical forms, and optimal truncations in tensor networks with closed loops. Phys. Rev. B 98, 085155.\n\n\n\nFrancuz, A.; Schuch, N. and Vanhecke, B. (2025). Stable and Efficient Differentiation of Tensor Network Algorithms. Physical Review Research 7, 013237.\n\n\n\nHaegeman, J. and Verstraete, F. (2017). Diagonalizing Transfer Matrices and Matrix Product Operators: A Medley of Exact and Computational Methods. Annual Review of Condensed Matter Physics 8, 355–406.\n\n\n\nHasenbusch, M. (2001). Monte Carlo Studies of the Three-Dimensional Ising Model in Equilibrium. International Journal of Modern Physics C 12, 911–1009.\n\n\n\nLiu, W.-Y.; Gong, S.-S.; Li, Y.-B.; Poilblanc, D.; Chen, W.-Q. and Gu, Z.-C. (2022). Gapless quantum spin liquid and global phase diagram of the spin-1/2 J1-J2 square antiferromagnetic Heisenberg model. Science Bulletin 67, 1034–1041.\n\n\n\nQin, M.; Shi, H. and Zhang, S. (2016). Benchmark study of the two-dimensional Hubbard model with auxiliary-field quantum Monte Carlo method. Phys. Rev. B 94, 085103.\n\n\n\nSandvik, A. W. (2010). Computational Studies of Quantum Spin Systems. AIP Conference Proceedings 1297, 135–338.\n\n\n\nVanderstraeten, L.; Burgelman, L.; Ponsioen, B.; Van Damme, M.; Vanhecke, B.; Corboz, P.; Haegeman, J. and Verstraete, F. (2022). Variational Methods for Contracting Projected Entangled-Pair States. Physical Review B 105, 195140.\n\n\n\nVanderstraeten, L.; Haegeman, J. and Verstraete, F. (2019). Tangent-Space Methods for Uniform Matrix Product States. SciPost Physics Lecture Notes, 007.\n\n\n\nVanderstraeten, L.; Vanhecke, B. and Verstraete, F. (2018). Residual entropies for three-dimensional frustrated spin systems with tensor networks. Phys. Rev. E 98, 042145.\n\n\n\n","category":"section"},{"location":"examples/xxz/","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/xxz/#Néel-order-in-the-U(1)-symmetric-XXZ-model","page":"Néel order in the U(1)-symmetric XXZ model","title":"Néel order in the U(1)-symmetric XXZ model","text":"Here, we want to look at a special case of the Heisenberg model, where the x and y couplings are equal, called the XXZ model\n\nH_0 = J big(sum_langle i j rangle S_i^x S_j^x + S_i^y S_j^y + Delta S_i^z S_j^z big) \n\nFor appropriate Delta, the model enters an antiferromagnetic phase (Néel order) which we will force by adding staggered magnetic charges to H_0. Furthermore, since the XXZ Hamiltonian obeys a U(1) symmetry, we will make use of that and work with U(1)-symmetric PEPS and CTMRG environments. For simplicity, we will consider spin-12 operators.\n\nBut first, let's make this example deterministic and import the required packages:\n\nusing Random\nusing TensorKit, PEPSKit\nusing MPSKit: add_physical_charge\nRandom.seed!(2928528935);","category":"section"},{"location":"examples/xxz/#Constructing-the-model","page":"Néel order in the U(1)-symmetric XXZ model","title":"Constructing the model","text":"Let us define the U(1)-symmetric XXZ Hamiltonian on a 2 times 2 unit cell with the parameters:\n\nJ = 1.0\nDelta = 1.0\nspin = 1 // 2\nsymmetry = U1Irrep\nlattice = InfiniteSquare(2, 2)\nH₀ = heisenberg_XXZ(ComplexF64, symmetry, lattice; J, Delta, spin);\n\nThis ensures that our PEPS ansatz can support the bipartite Néel order. As discussed above, we encode the Néel order directly in the ansatz by adding staggered auxiliary physical charges:\n\nS_aux = [\n    U1Irrep(-1 // 2) U1Irrep(1 // 2)\n    U1Irrep(1 // 2) U1Irrep(-1 // 2)\n]\nH = add_physical_charge(H₀, S_aux);","category":"section"},{"location":"examples/xxz/#Specifying-the-symmetric-virtual-spaces","page":"Néel order in the U(1)-symmetric XXZ model","title":"Specifying the symmetric virtual spaces","text":"Before we create an initial PEPS and CTM environment, we need to think about which symmetric spaces we need to construct. Since we want to exploit the global U(1) symmetry of the model, we will use TensorKit's U1Spaces where we specify dimensions for each symmetry sector. From the virtual spaces, we will need to construct a unit cell (a matrix) of spaces which will be supplied to the PEPS constructor. The same is true for the physical spaces, which can be extracted directly from the Hamiltonian LocalOperator:\n\nV_peps = U1Space(0 => 2, 1 => 1, -1 => 1)\nV_env = U1Space(0 => 6, 1 => 4, -1 => 4, 2 => 2, -2 => 2)\nvirtual_spaces = fill(V_peps, size(lattice)...)\nphysical_spaces = physicalspace(H)\n\n2×2 Matrix{TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}}:\n Rep[U₁](…) of dim 2   Rep[U₁](…) of dim 2\n Rep[U₁](…) of dim 2  Rep[U₁](…) of dim 2","category":"section"},{"location":"examples/xxz/#Ground-state-search","page":"Néel order in the U(1)-symmetric XXZ model","title":"Ground state search","text":"From this point onwards it's business as usual: Create an initial PEPS and environment (using the symmetric spaces), specify the algorithmic parameters and optimize:\n\nboundary_alg = (; tol = 1.0e-8, alg = :simultaneous, trunc = (; alg = :fixedspace))\ngradient_alg = (; tol = 1.0e-6, alg = :eigsolver, maxiter = 10, iterscheme = :diffgauge)\noptimizer_alg = (; tol = 1.0e-4, alg = :lbfgs, maxiter = 85, ls_maxiter = 3, ls_maxfg = 3)\n\npeps₀ = InfinitePEPS(randn, ComplexF64, physical_spaces, virtual_spaces)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, V_env), peps₀; boundary_alg...);\n\n[ Info: CTMRG init:\tobj = -2.356413456811e+03 +3.307968169629e+02im\terr = 1.0000e+00\n[ Info: CTMRG conv 30:\tobj = +6.245129734283e+03 -4.009325493826e-08im\terr = 5.3638614449e-09\ttime = 7.21 sec\n\n\nFinally, we can optimize the PEPS with respect to the XXZ Hamiltonian and check the resulting ground state energy per site using our (2 times 2) unit cell. Note that the optimization might take a while since precompilation of symmetric AD code takes longer and because symmetric tensors do create a bit of overhead (which does pay off at larger bond and environment dimensions):\n\npeps, env, E, info = fixedpoint(\n    H, peps₀, env₀; boundary_alg, gradient_alg, optimizer_alg, verbosity = 3\n)\n@show E / prod(size(lattice));\n\n[ Info: LBFGS: initializing with f = -1.385136095079e-01, ‖∇f‖ = 1.2184e+00\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -2.44e-02, ϕ - ϕ₀ = -4.56e-01\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/linesearches.jl:148\n[ Info: LBFGS: iter    1, Δt  1.47 m: f = -5.947088555354e-01, ‖∇f‖ = 3.7329e+00, α = 2.50e+01, m = 0, nfg = 4\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -7.72e-03, ϕ - ϕ₀ = -1.52e+00\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/linesearches.jl:148\n[ Info: LBFGS: iter    2, Δt  1.37 m: f = -2.114273975713e+00, ‖∇f‖ = 2.9121e+00, α = 2.50e+01, m = 0, nfg = 4\n[ Info: LBFGS: iter    3, Δt 16.27 s: f = -2.218657557832e+00, ‖∇f‖ = 1.4788e+00, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    4, Δt 50.77 s: f = -2.473597362695e+00, ‖∇f‖ = 1.2506e+00, α = 3.17e+00, m = 2, nfg = 3\n[ Info: LBFGS: iter    5, Δt 15.40 s: f = -2.546159338872e+00, ‖∇f‖ = 1.4463e+00, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    6, Δt 16.81 s: f = -2.614645567157e+00, ‖∇f‖ = 4.0554e-01, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    7, Δt 15.00 s: f = -2.622673933783e+00, ‖∇f‖ = 1.8054e-01, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    8, Δt 15.49 s: f = -2.626310260551e+00, ‖∇f‖ = 1.7749e-01, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    9, Δt 13.94 s: f = -2.632769138215e+00, ‖∇f‖ = 1.8586e-01, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter   10, Δt 14.24 s: f = -2.639694625673e+00, ‖∇f‖ = 2.2500e-01, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   11, Δt 12.62 s: f = -2.644827933644e+00, ‖∇f‖ = 1.2801e-01, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   12, Δt 13.99 s: f = -2.646459706216e+00, ‖∇f‖ = 6.7575e-02, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   13, Δt 12.48 s: f = -2.647499601247e+00, ‖∇f‖ = 6.0731e-02, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   14, Δt 13.90 s: f = -2.648703044472e+00, ‖∇f‖ = 7.1312e-02, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   15, Δt 12.38 s: f = -2.650602130567e+00, ‖∇f‖ = 9.3675e-02, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   16, Δt 12.72 s: f = -2.652309127838e+00, ‖∇f‖ = 8.3679e-02, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   17, Δt 12.14 s: f = -2.654182955360e+00, ‖∇f‖ = 9.5661e-02, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   18, Δt 12.51 s: f = -2.655830722048e+00, ‖∇f‖ = 1.4282e-01, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   19, Δt 13.91 s: f = -2.658506524808e+00, ‖∇f‖ = 8.6259e-02, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   20, Δt 12.28 s: f = -2.660101934378e+00, ‖∇f‖ = 5.5568e-02, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   21, Δt 13.67 s: f = -2.660655823922e+00, ‖∇f‖ = 5.0087e-02, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   22, Δt 12.20 s: f = -2.661713913904e+00, ‖∇f‖ = 6.6024e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, Δt 13.88 s: f = -2.663783161449e+00, ‖∇f‖ = 1.4168e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, Δt 12.33 s: f = -2.664843824225e+00, ‖∇f‖ = 1.3560e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, Δt 13.71 s: f = -2.666211864482e+00, ‖∇f‖ = 6.7535e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, Δt 12.34 s: f = -2.666722906773e+00, ‖∇f‖ = 5.1877e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, Δt 12.35 s: f = -2.667030535551e+00, ‖∇f‖ = 4.7362e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, Δt 13.93 s: f = -2.668169807778e+00, ‖∇f‖ = 5.6321e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, Δt 12.64 s: f = -2.668423674818e+00, ‖∇f‖ = 1.1940e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, Δt 13.82 s: f = -2.669339425071e+00, ‖∇f‖ = 4.0856e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, Δt 12.36 s: f = -2.669606925028e+00, ‖∇f‖ = 3.0584e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, Δt 13.86 s: f = -2.669888443527e+00, ‖∇f‖ = 3.6473e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, Δt 12.59 s: f = -2.670409100956e+00, ‖∇f‖ = 5.7239e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, Δt 14.06 s: f = -2.670955476785e+00, ‖∇f‖ = 6.0862e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, Δt 12.54 s: f = -2.671400581183e+00, ‖∇f‖ = 4.4907e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, Δt 13.84 s: f = -2.671654670301e+00, ‖∇f‖ = 2.3660e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, Δt 12.53 s: f = -2.671805543674e+00, ‖∇f‖ = 2.3806e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, Δt 12.62 s: f = -2.672069196257e+00, ‖∇f‖ = 3.7666e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, Δt 13.93 s: f = -2.672392041467e+00, ‖∇f‖ = 4.6014e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, Δt 12.58 s: f = -2.672631814576e+00, ‖∇f‖ = 2.8983e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, Δt 13.94 s: f = -2.672757830427e+00, ‖∇f‖ = 2.0269e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, Δt 11.54 s: f = -2.672875298674e+00, ‖∇f‖ = 2.3893e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, Δt 12.91 s: f = -2.673086282043e+00, ‖∇f‖ = 3.1487e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, Δt 11.56 s: f = -2.673264734617e+00, ‖∇f‖ = 5.1144e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, Δt 11.70 s: f = -2.673441586270e+00, ‖∇f‖ = 2.2014e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   46, Δt 13.22 s: f = -2.673518413423e+00, ‖∇f‖ = 1.6755e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, Δt 11.73 s: f = -2.673610437186e+00, ‖∇f‖ = 2.1374e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, Δt 12.99 s: f = -2.673749787831e+00, ‖∇f‖ = 3.0825e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, Δt 11.81 s: f = -2.673963455728e+00, ‖∇f‖ = 2.8112e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, Δt 13.16 s: f = -2.674085248803e+00, ‖∇f‖ = 3.6768e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   51, Δt 11.39 s: f = -2.674188984088e+00, ‖∇f‖ = 1.7117e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, Δt 11.56 s: f = -2.674242447315e+00, ‖∇f‖ = 1.4444e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, Δt 12.95 s: f = -2.674306699476e+00, ‖∇f‖ = 1.8187e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, Δt 11.87 s: f = -2.674433434449e+00, ‖∇f‖ = 2.0657e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, Δt 24.94 s: f = -2.674481180296e+00, ‖∇f‖ = 2.0935e-02, α = 3.31e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   56, Δt 13.27 s: f = -2.674543091778e+00, ‖∇f‖ = 1.1697e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, Δt 11.73 s: f = -2.674593597475e+00, ‖∇f‖ = 1.2064e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, Δt 13.98 s: f = -2.674645033379e+00, ‖∇f‖ = 1.7233e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, Δt 13.19 s: f = -2.674707076560e+00, ‖∇f‖ = 1.4282e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, Δt 12.30 s: f = -2.674765993748e+00, ‖∇f‖ = 1.5331e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, Δt 13.45 s: f = -2.674818411605e+00, ‖∇f‖ = 1.7528e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   62, Δt 11.79 s: f = -2.674860141812e+00, ‖∇f‖ = 1.5281e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, Δt 13.29 s: f = -2.674937524252e+00, ‖∇f‖ = 1.3781e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, Δt 11.59 s: f = -2.674948199372e+00, ‖∇f‖ = 2.8631e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   65, Δt 22.94 s: f = -2.674990650090e+00, ‖∇f‖ = 9.4163e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, Δt 11.50 s: f = -2.675004596824e+00, ‖∇f‖ = 7.9770e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, Δt 12.75 s: f = -2.675026772162e+00, ‖∇f‖ = 1.1890e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, Δt 11.54 s: f = -2.675068849496e+00, ‖∇f‖ = 1.5839e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, Δt 12.83 s: f = -2.675131833485e+00, ‖∇f‖ = 1.9865e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, Δt 23.26 s: f = -2.675161486689e+00, ‖∇f‖ = 1.6149e-02, α = 3.77e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   71, Δt 12.81 s: f = -2.675191940653e+00, ‖∇f‖ = 7.4164e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, Δt 11.69 s: f = -2.675210048264e+00, ‖∇f‖ = 8.1107e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, Δt 12.81 s: f = -2.675226236810e+00, ‖∇f‖ = 1.0563e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, Δt 11.71 s: f = -2.675255865322e+00, ‖∇f‖ = 1.5000e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, Δt 12.83 s: f = -2.675284908686e+00, ‖∇f‖ = 9.5271e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, Δt 11.47 s: f = -2.675303880609e+00, ‖∇f‖ = 6.1567e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, Δt 13.03 s: f = -2.675316351383e+00, ‖∇f‖ = 8.2404e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, Δt 11.71 s: f = -2.675331006484e+00, ‖∇f‖ = 8.6196e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, Δt 11.73 s: f = -2.675352594041e+00, ‖∇f‖ = 1.1186e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   80, Δt 13.08 s: f = -2.675368505391e+00, ‖∇f‖ = 1.0487e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   81, Δt 11.58 s: f = -2.675379342123e+00, ‖∇f‖ = 5.6587e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   82, Δt 12.54 s: f = -2.675386556147e+00, ‖∇f‖ = 5.4612e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   83, Δt 11.64 s: f = -2.675400703567e+00, ‖∇f‖ = 7.6013e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   84, Δt 13.11 s: f = -2.675419793189e+00, ‖∇f‖ = 1.4146e-02, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 85 iterations and time 26.03 m: f = -2.675438660313e+00, ‖∇f‖ = 7.9074e-03\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/lbfgs.jl:199\nE / prod(size(lattice)) = -0.6688596650783208\n\n\nNote that for the specified parameters J = Delta = 1, we simulated the same Hamiltonian as in the Heisenberg example. In that example, with a non-symmetric D=2 PEPS simulation, we reached a ground-state energy per site of around E_textD=2 = -06625dots. Again comparing against Sandvik's accurate QMC estimate E_textref=06694421, we see that we already got closer to the reference energy.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"lib/lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/lib/#PEPSKit.ALSTruncation","page":"Library","title":"PEPSKit.ALSTruncation","text":"struct ALSTruncation\n\nAlgorithm struct for the alternating least square (ALS) optimization of a bond. \n\nFields\n\ntrunc::MatrixAlgebraKit.TruncationStrategy\nmaxiter::Int64\ntol::Float64\ncheck_interval::Int64\n\nConstructors\n\nALSTruncation(; kwargs...)\n\nThe truncation algorithm can be constructed from the following keyword arguments:\n\ntrunc::TruncationStrategy: SVD truncation strategy when initilizing the truncated tensors connected by the bond.\nmaxiter::Int=50 : Maximal number of ALS iterations.\ntol::Float64=1e-9 : ALS converges when the relative change in bond SVD spectrum between two iterations is smaller than tol.\ncheck_interval::Int=0 : Set number of iterations to print information. Output is suppressed when check_interval <= 0. \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.BPEnv","page":"Library","title":"PEPSKit.BPEnv","text":"struct BPEnv{T}\n\nBelief propagation (BP) environment for a square lattice norm network,  containing a 4 x rows x cols array of message tensors, defined for  each oriented nearest neighbor bond in the network. \n\nThe message tensors connect to the network tensors  P at site [r,c] in the unit cell as:\n\n                    m[1,r-1,c]\n                    |\n    m[4,r,c-1]------P[r,c]------m[2,r,c+1]\n                    |\n                    m[3,r+1,c]\n\n[1,r-1,c]: message from P[r-1,c] to P[r,c] (axis order: ket ← bra)\n[2,r,c+1]: message from P[r,c+1] to P[r,c] (axis order: ket ← bra)\n[3,r+1,c]: message from P[r+1,c] to P[r,c] (axis order: bra ← ket)\n[4,r,c-1]: message from P[r,c-1] to P[r,c] (axis order: bra ← ket)\n\nFields\n\nmessages::Array{T, 3} where T: 4 x rows x cols array of message tensors, where the first dimension specifies the spatial direction\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.BPEnv-Tuple{Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.BPEnv","text":"BPEnv([f=randn, T=ComplexF64], network::InfiniteSquareNetwork; posdef::Bool = true)\n\nConstruct a BP environment by specifying a corresponding InfiniteSquareNetwork.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.BPEnv-Tuple{SUWeight}","page":"Library","title":"PEPSKit.BPEnv","text":"BPEnv(wts::SUWeight)\n\nConvert fixed point weights wts of trivial simple update to a belief propagation environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.BPEnv-Union{Tuple{A}, Tuple{A, A}} where A<:(AbstractMatrix{<:TensorKit.ProductSpace})","page":"Library","title":"PEPSKit.BPEnv","text":"BPEnv(\n    [f=randn, T=ComplexF64], Ds_north::A, Ds_east::A; posdef::Bool = true\n) where {A <: AbstractMatrix{<:ProductSpace}}\n\nConstruct a BP environment by specifying matrices of north and east virtual spaces of the corresponding InfiniteSquareNetwork. Each matrix entry corresponds to a site in the unit cell.\n\nWhen posdef is true, all messages will be made semi-positive definite (when interpreted as a bra ← ket TensorMap).\n\nEach entry of the Ds_north and Ds_east matrices corresponds to an effective local space of the network, and can be represented as a ProductSpace (e.g. for the case of a network representing overlaps of PEPSs).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.BPEnv-Union{Tuple{P}, Tuple{P, P}} where P<:TensorKit.ProductSpace","page":"Library","title":"PEPSKit.BPEnv","text":"BPEnv(\n    [f=randn, T=ComplexF64], D_north::P, D_east::P;\n    unitcell::Tuple{Int, Int} = (1, 1), posdef::Bool = true\n) where {P <: ProductSpace}\n\nConstruct a BP environment by specifying the north and east virtual spaces of the corresponding InfiniteSquareNetwork. The network unit cell can be specified by the unitcell keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.BPGauge","page":"Library","title":"PEPSKit.BPGauge","text":"struct BPGauge\n\nAlgorithm for gauging PEPS with belief propagation fixed point messages.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.BeliefPropagation","page":"Library","title":"PEPSKit.BeliefPropagation","text":"struct BeliefPropagation\n\nAlgorithm for computing the belief propagation fixed point messages.\n\nFields\n\ntol::Float64: Stopping criterion for the BP iterations in relative trace norm difference\nminiter::Int64: Minimal number of BP iterations\nmaxiter::Int64: Maximal number of BP iterations\nproject_hermitian::Bool: Toggle for projecting messages onto the hermitian subspace immediately after update through BP equation\nbipartite::Bool: When true, preserve bipartite structure of BPEnv inherited from input network\nverbosity::Int64: Output verbosity level\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.C4vCTMRG","page":"Library","title":"PEPSKit.C4vCTMRG","text":"struct C4vCTMRG{P<:PEPSKit.ProjectorAlgorithm} <: PEPSKit.CTMRGAlgorithm\n\nCTMRG algorithm assuming a C₄ᵥ-symmetric PEPS, i.e. invariance under 90° spatial rotation and Hermitian reflection. This requires a single-site unit cell. The projector is obtained from eigh decomposing the Hermitian enlarged corner.\n\nFields\n\ntol::Float64\nmaxiter::Int64\nminiter::Int64\nverbosity::Int64\nprojector_alg::PEPSKit.ProjectorAlgorithm\n\nConstructors\n\nC4vCTMRG(; kwargs...)\n\nConstruct a C₄ᵥ CTMRG algorithm struct based on keyword arguments. For a full description, see leading_boundary. The supported keywords are:\n\ntol::Real=1.0e-8\nmaxiter::Int=100\nminiter::Int=4\nverbosity::Int=2\ntrunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)\ndecomposition_alg::Union{<:EighAdjoint,NamedTuple}\nprojector_alg::Symbol=:c4v_eigh\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.C4vEighProjector","page":"Library","title":"PEPSKit.C4vEighProjector","text":"struct C4vEighProjector{S<:EighAdjoint, T} <: PEPSKit.ProjectorAlgorithm\n\nProjector algorithm implementing the eigh decomposition of a Hermitian enlarged corner.\n\nFields\n\ndecomposition_alg::EighAdjoint\ntrunc::Any\nverbosity::Int64\n\nConstructors\n\nC4vEighProjector(; kwargs...)\n\nConstruct the C₄ᵥ eigh-based projector algorithm based on the following keyword arguments:\n\ndecomposition_alg::Union{<:EighAdjoint,NamedTuple}=EighAdjoint() : eigh algorithm including the reverse rule. See EighAdjoint.\ntrunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation strategy for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerror : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncrank : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:trunctol : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nverbosity::Int=0 : Projector output verbosity which can be:\nSuppress output information\nPrint singular value degeneracy warnings\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.C4vQRProjector","page":"Library","title":"PEPSKit.C4vQRProjector","text":"struct C4vQRProjector{S} <: PEPSKit.ProjectorAlgorithm\n\nProjector algorithm implementing the qr decomposition of a column-enlarged corner.\n\nFields\n\ndecomposition_alg::Any\n\nConstructors\n\nC4vQRProjector(; kwargs...)\n\nConstruct the C₄ᵥ qr-based projector algorithm based on the following keyword arguments:\n\ndecomposition_alg=QRAdjoint() : left_orth algorithm including the reverse rule. See QRAdjoint.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGAlgorithm","page":"Library","title":"PEPSKit.CTMRGAlgorithm","text":"abstract type CTMRGAlgorithm\n\nAbstract super type for the corner transfer matrix renormalization group (CTMRG) algorithm for contracting infinite PEPS.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGAlgorithm-Tuple{}","page":"Library","title":"PEPSKit.CTMRGAlgorithm","text":"CTMRGAlgorithm(; kwargs...)\n\nKeyword argument parser returning the appropriate CTMRGAlgorithm algorithm struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv","page":"Library","title":"PEPSKit.CTMRGEnv","text":"struct CTMRGEnv{C, T}\n\nCorner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.\n\nGiven arrays of corners c and edges t, they connect to the network tensors P at site (r, c) in the unit cell as:\n\n   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]\n   |              |             |\n   t[4,r,c-1]-----P[r,c]--------t[2,r,c+1]\n   |              |             |\n   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]\n\nHere P represents an effective local constituent tensor. This can either be a single rank-4 tensor, a pair of PEPS tensors, or a stack of PEPS-PEPO-PEPS tensors depending on the network being contracted.\n\nFields\n\ncorners::Array{C, 3} where C: 4 x rows x cols array of corner tensors, where the first dimension specifies the spatial direction\nedges::Array{T, 3} where T: 4 x rows x cols array of edge tensors, where the first dimension specifies the spatial direction\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Tuple{Any, Any, InfiniteSquareNetwork, Vararg{Any}}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], network::InfiniteSquareNetwork, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:Union{AbstractMatrix{<:ElementarySpace}, ElementarySpace}}\n\nConstruct a CTMRG environment by specifying a corresponding InfiniteSquareNetwork, and the north, east, south and west virtual spaces of the environment. The virtual spaces can either be specified as matrices of ElementarySpaces, or as individual ElementarySpaces which are then filled to match the size of the unit cell. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Tuple{BPEnv}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(bp_env::BPEnv)\n\nConstruct a CTMRG environment with bond dimension χ = 1  from the belief propagation environment bp_env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Tuple{SUWeight}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(wts::SUWeight)\n\nConstruct a CTMRG environment with a trivial environment space  (bond dimension χ = 1) from SUWeight wts, which has the same real scalartype as `wts.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{B}, Tuple{A}, Tuple{Any, Any, A, A, B}, Tuple{Any, Any, A, A, B, B}, Tuple{Any, Any, A, A, B, B, B}, Tuple{Any, Any, A, A, Vararg{B, 4}}} where {A<:(AbstractMatrix{<:TensorKit.ProductSpace}), B<:(AbstractMatrix{<:TensorKit.ElementarySpace})}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], Ds_north::A, Ds_east::A, chis_north::B, [chis_east::B], [chis_south::B], [chis_west::B]\n) where {A<:AbstractMatrix{<:VectorSpace}, B<:AbstractMatrix{<:ElementarySpace}}\n\nConstruct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding partition function and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\nEach entry of the Ds_north and Ds_east matrices corresponds to an effective local space of the partition function, and can be represented as an ElementarySpace (e.g. for the case of a partition function defined in terms of local rank-4 tensors) or a ProductSpace (e.g. for the case of a network representing overlaps of PEPSs and PEPOs).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{Any, Any, S, S, Vararg{Any}}} where S<:TensorKit.VectorSpace","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], D_north::P, D_east::P, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S];\n    unitcell::Tuple{Int,Int}=(1, 1),\n) where {P<:VectorSpace,S<:ElementarySpace}\n\nConstruct a CTMRG environment by specifying the north and east virtual spaces of the corresponding InfiniteSquareNetwork and the north, east, south and west virtual spaces of the environment. The network unit cell can be specified by the unitcell keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ColumnEnlargedCorner","page":"Library","title":"PEPSKit.ColumnEnlargedCorner","text":"struct ColumnEnlargedCorner{TC, TE}\n\nColumn-enlarged CTMRG corner tensor storage.\n\nConstructors\n\nColumnEnlargedCorner(env, coordinates)\n\nConstruct a column-enlarged corner with the correct row and column indices  based on the given coordinates which are of the form (dir, row, col).\n\n    [NORTHWEST,r,c]         [NORTHEAST,r,c]\n\n        c-1    c                 c     c+1\n    r   C₁--←--E₁--←--      --←--E₂--←--C₂  r\n        ↓      |                 |      ↑\n\n        ↓      |                 |      ↑\n    r   C₄--→--E₃--→--      --→--E₃--→--C₃  r\n        c-1    c                 c     c+1\n\n    [SOUTHWEST,r,c]         [SOUTHEAST,r,c]\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.EigSolver","page":"Library","title":"PEPSKit.EigSolver","text":"struct EigSolver{F} <: PEPSKit.GradMode{F}\n\nGradient mode wrapper around KrylovKit.KrylovAlgorithm for solving the gradient linear problem as an eigenvalue problem.\n\nFields\n\nsolver_alg::KrylovKit.KrylovAlgorithm\n\nConstructors\n\nEigSolver(; kwargs...)\n\nConstruct the EigSolver algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance of the eigen solver.\nmaxiter::Int=30 : Maximal number of solver iterations.\nverbosity::Int=-1 : Output information verbosity of the linear solver.\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\nsolver_alg::Union{KrylovKit.KrylovAlgorithm,NamedTuple}=(; alg=:arnoldi : Eigen solver algorithm which, if supplied directly as a KrylovKit.KrylovAlgorithm overrides the above specified tol, maxiter and verbosity. Alternatively, it can be supplied via a NamedTuple where alg can be one of the following:\n:arnoldi : Arnoldi Krylov algorithm, see KrylovKit.Arnoldi for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.EighAdjoint","page":"Library","title":"PEPSKit.EighAdjoint","text":"struct EighAdjoint{F, R}\n\nWrapper for a eigenvalue decomposition algorithm fwd_alg with a defined reverse rule rrule_alg. If isnothing(rrule_alg), Zygote differentiates the forward call automatically.\n\nFields\n\nfwd_alg::Any\nrrule_alg::Any\n\nConstructors\n\nEighAdjoint(; kwargs...)\n\nConstruct a EighAdjoint algorithm struct based on the following keyword arguments:\n\nfwd_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=qriteration): Eig algorithm of the forward pass which can either be passed as an Algorithm instance or a NamedTuple where alg is one of the following:\n:qriteration : MatrixAlgebraKit's LAPACK_QRIteration\n:bisection : MatrixAlgebraKit's LAPACK_Bisection\n:divideandconquer : MatrixAlgebraKit's LAPACK_DivideAndConquer\n:multiple : MatrixAlgebraKit's LAPACK_MultipleRelativelyRobustRepresentations\n:lanczos : Lanczos algorithm for symmetric/Hermitian matrices, see KrylovKit docs\n:blocklanczos : Block version of :lanczos for repeated extremal eigenvalues, see KrylovKit docs\nrrule_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=full): Reverse-rule algorithm for differentiating the eigenvalue decomposition. Can be supplied by an Algorithm instance directly or as a NamedTuple where alg is one of the following:\n:full : MatrixAlgebraKit's eigh_pullback! that requires access to the full spectrum\n:trunc : MatrixAlgebraKit's eigh_trunc_pullback! solving a Sylvester equation on the truncated subspace\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.EnlargedCorner","page":"Library","title":"PEPSKit.EnlargedCorner","text":"struct EnlargedCorner{TC, TE, TA}\n\nEnlarged CTMRG corner tensor storage.\n\nConstructors\n\nEnlargedCorner(network::InfiniteSquareNetwork, env, coordinates)\n\nConstruct an enlarged corner with the correct row and column indices based on the given coordinates which are of the form (dir, row, col).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedEig","page":"Library","title":"PEPSKit.FixedEig","text":"struct FixedEig{Dt, Vt, Dtf, Vtf, It}\n\nEigenvalue decomposition struct containing a pre-computed decomposition or even multiple ones. Additionally, it can contain the full untruncated decomposition and the corresponding truncation indices as well. The call to eigh_trunc/eig_trunc just returns the pre-computed D and V. In the reverse pass, the adjoint is computed with these exact D and V and, potentially, the full decompositions if the adjoints require access to them.\n\nFields\n\nD::Any\nV::Any\nD_full::Any\nV_full::Any\ntruncation_indices::Any\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedQR","page":"Library","title":"PEPSKit.FixedQR","text":"struct FixedQR{Qt, Rt}\n\nQR decomposition struct containing a pre-computed decomposition. Th call to left_orth(!) just returns the precomputed Q and R. In the reverse pass, the adjoint is computed with these exact D and R.\n\nFields\n\nQ::Any\nR::Any\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedSVD","page":"Library","title":"PEPSKit.FixedSVD","text":"struct FixedSVD{Ut, St, Vt, Utf, Stf, Vtf, It}\n\nSVD struct containing a pre-computed decomposition or even multiple ones. Additionally, it can contain the untruncated full decomposition as well. The call to svd_trunc just returns the pre-computed U, S and V. In the reverse pass, the SVD adjoint is computed with these exact U, S, and V and, potentially, the full decompositions if the adjoints needs access to them.\n\nFields\n\nU::Any\nS::Any\nV::Any\nU_full::Any\nS_full::Any\nV_full::Any\ntruncation_indices::Any\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedSpaceTruncation","page":"Library","title":"PEPSKit.FixedSpaceTruncation","text":"struct FixedSpaceTruncation <: MatrixAlgebraKit.TruncationStrategy\n\nCTMRG specific truncation strategy for svd_trunc which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from TruncationSpace.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullEighPullback","page":"Library","title":"PEPSKit.FullEighPullback","text":"struct FullEighPullback\n\nEigh reverse-rule algorithm which wraps MatrixAlgebraKit's eigh_pullback!.\n\nFields\n\ndegeneracy_atol::Real\nverbosity::Int64\n\nConstructors\n\nFullEighPullback(; kwargs...)\n\nConstruct a FullEighPullback algorithm struct from the following keyword arguments:\n\nverbosity::Int=0 : Suppresses all output if ≤0, prints gauge dependency warnings if 1, and always prints gauge dependency if ≥2.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullEnvTruncation","page":"Library","title":"PEPSKit.FullEnvTruncation","text":"struct FullEnvTruncation\n\nAlgorithm struct for the full environment truncation (FET).\n\nFields\n\ntrunc::MatrixAlgebraKit.TruncationStrategy\nmaxiter::Int64\ntol::Float64\ntrunc_init::Bool\ncheck_interval::Int64\n\nConstructors\n\nFullEnvTruncation(; kwargs...)\n\nThe truncation algorithm can be constructed from the following keyword arguments:\n\ntrunc::TruncationStrategy : SVD truncation strategy when optimizing the new bond matrix.\nmaxiter::Int=50 : Maximal number of FET iterations.\ntol::Float64=1e-9 : FET converges when the relative change in bond SVD spectrum between two FET iterations is smaller than tol.\ntrunc_init::Bool=true : Controls whether the initialization of the new bond matrix is obtained from truncated SVD of the old bond matrix. \ncheck_interval::Int=0 : Set number of iterations to print information. Output is suppressed when check_interval <= 0. \n\nReferences\n\nGlen Evenbly, Phys. Rev. B 98, 085155 (2018). \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullInfiniteEnv","page":"Library","title":"PEPSKit.FullInfiniteEnv","text":"struct FullInfiniteEnv{TC, TE, TA}\n\nFull-infinite CTMRG environment tensor storage.\n\nFields\n\nC_1\nC_2\nC_3\nC_4\nE_1\nE_2\nE_3\nE_4\nE_5\nE_6\nE_7\nE_8\nA_1\nA_2\nA_3\nA_4\n\nConstructors\n\nFullInfiniteEnv(\n    quadrant1::E, quadrant2::E, quadrant3::E, quadrant4::E\n) where {E<:EnlargedCorner}\n\nConstruct sparse full-infinite environment based on four sparse enlarged corners (quadrants).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullInfiniteEnv-Tuple{Any, Val{false}}","page":"Library","title":"PEPSKit.FullInfiniteEnv","text":"(env::FullInfiniteEnv)(x, ::Val{false}) \n(env::FullInfiniteEnv)(x, ::Val{true})\n\nContract full-infinite environment with a vector x, such that the environment acts as a linear map or adjoint linear map on x if Val(true) or Val(false) is passed, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.FullInfiniteProjector","page":"Library","title":"PEPSKit.FullInfiniteProjector","text":"struct FullInfiniteProjector{S<:SVDAdjoint, T} <: PEPSKit.ProjectorAlgorithm\n\nProjector algorithm implementing projectors from SVDing the full 4x4 CTMRG environment.\n\nFields\n\ndecomposition_alg::SVDAdjoint\ntrunc::Any\nverbosity::Int64\n\nConstructors\n\nFullInfiniteProjector(; kwargs...)\n\nConstruct the full-infinite projector algorithm based on the following keyword arguments:\n\ndecomposition_alg::Union{<:SVDAdjoint,NamedTuple}=SVDAdjoint() : SVD algorithm including the reverse rule. See SVDAdjoint.\ntrunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerror : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncrank : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:trunctol : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nverbosity::Int=0 : Projector output verbosity which can be:\nSuppress output information\nPrint singular value degeneracy warnings\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullSVDPullback","page":"Library","title":"PEPSKit.FullSVDPullback","text":"struct FullSVDPullback\n\nSVD reverse-rule algorithm which wraps MatrixAlgebraKit's svd_pullback!.\n\nFields\n\ndegeneracy_atol::Real\nverbosity::Int64\n\nConstructors\n\nFullSVDPullback(; kwargs...)\n\nConstruct a FullSVDPullback algorithm struct from the following keyword arguments:\n\ndegeneracy_atol::Real=1.0e-13 : Broadening amplitude for smoothing divergent term in SVD derivative in case of (pseudo) degenerate singular values.\nverbosity::Int=0 : Suppresses all output if ≤0, prints gauge dependency warnings if 1, and always prints gauge dependency if ≥2.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GeomSum","page":"Library","title":"PEPSKit.GeomSum","text":"struct GeomSum{F} <: PEPSKit.GradMode{F}\n\nGradient mode for CTMRG using explicit evaluation of the geometric sum.\n\nFields\n\ntol::Real\nmaxiter::Int64\nverbosity::Int64\n\nConstructors\n\nGeomSum(; kwargs...)\n\nConstruct the GeomSum algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance for the difference of norms of two consecutive summands in the geometric sum.\nmaxiter::Int=30 : Maximal number of gradient iterations.\nverbosity::Int=-1 : Output information verbosity that can be one of the following:\nSuppress output information\nPrint convergence warnings\nInformation at each gradient iteration\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GradMode-Tuple{}","page":"Library","title":"PEPSKit.GradMode","text":"GradMode(; kwargs...)\n\nKeyword argument parser returning the appropriate GradMode algorithm struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"struct HalfInfiniteEnv{TC, TE, TA}\n\nHalf-infinite CTMRG environment tensor storage.\n\nFields\n\nC_1\nC_2\nE_1\nE_2\nE_3\nE_4\nA_1\nA_2\n\nConstructors\n\nHalfInfiniteEnv(quadrant1::EnlargedCorner, quadrant2::EnlargedCorner)\n\nConstruct sparse half-infinite environment based on two sparse enlarged corners (quadrants).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv-Tuple{Any, Val{false}}","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"(env::HalfInfiniteEnv)(x, ::Val{false}) \n(env::HalfInfiniteEnv)(x, ::Val{true})\n\nContract half-infinite environment with a vector x, such that the environment acts as a linear map or adjoint linear map on x if Val(true) or Val(false) is passed, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.HalfInfiniteProjector","page":"Library","title":"PEPSKit.HalfInfiniteProjector","text":"struct HalfInfiniteProjector{S<:SVDAdjoint, T} <: PEPSKit.ProjectorAlgorithm\n\nProjector algorithm implementing projectors from SVDing the half-infinite CTMRG environment.\n\nFields\n\ndecomposition_alg::SVDAdjoint\ntrunc::Any\nverbosity::Int64\n\nConstructors\n\nHalfInfiniteProjector(; kwargs...)\n\nConstruct the half-infinite projector algorithm based on the following keyword arguments:\n\ndecomposition_alg::Union{<:SVDAdjoint,NamedTuple}=SVDAdjoint() : SVD algorithm including the reverse rule. See SVDAdjoint.\ntrunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation strategy for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerror : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncrank : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:trunctol : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nverbosity::Int=0 : Projector output verbosity which can be:\nSuppress output information\nPrint singular value degeneracy warnings\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO","page":"Library","title":"PEPSKit.InfinitePEPO","text":"struct InfinitePEPO{T<:PEPOTensor}\n\nRepresents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.\n\nFields\n\nA::Array{T, 3} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::PEPOTensor; unitcell=(1, 1, 1))\n\nCreate an InfinitePEPO by specifying a tensor which is repeated across the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::AbstractArray{T, 3})\n\nAllow users to pass in an array of tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A<:(AbstractArray{<:TensorKit.ElementarySpace, 3})","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO([f=randn, T=ComplexF64,] Pspaces, Nspaces, Espaces)\n\nAllow users to pass in arrays of spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO([f=randn, T=ComplexF64,] Pspace::S, Nspace::S, [Espace::S]; unitcell=(1,1,1)) where {S<:ElementarySpace}\n\nCreate an InfinitePEPO by specifying its spaces and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS","page":"Library","title":"PEPSKit.InfinitePEPS","text":"struct InfinitePEPS{T<:PEPSTensor}\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice.\n\nFields\n\nA::Matrix{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{AbstractMatrix{<:TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::AbstractMatrix{T})\n\nCreate an InfinitePEPS by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::PEPSTensor; unitcell=(1, 1))\n\nCreate an InfinitePEPS by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            ||         ||\n---T[r,c-1]=====AA[r,c]====AA[r,c+1]====\n   |            ||         ||\n---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==\n   |            ||         ||\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{M}, Tuple{Any, Type{<:Number}, M, M}, Tuple{Any, Type{<:Number}, M, M, M}} where M<:(AbstractMatrix{<:TensorKit.ElementarySpace})","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS([f=randn, T=ComplexF64,] Pspaces::A, Nspaces::A, [Espaces::A]) where {A<:AbstractMatrix{ElementarySpace}}\n\nCreate an InfinitePEPS by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{Any, Type{<:Number}, S, Vararg{Any}}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS([f=randn, T=ComplexF64,] Pspace, Nspace, [Espace]; unitcell=(1,1))\n\nCreate an InfinitePEPS by specifying its physical, north and east spaces and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"struct InfinitePartitionFunction{T<:PartitionFunctionTensor}\n\nRepresents an infinite partition function on a 2D square lattice.\n\nFields\n\nA::Matrix{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Tuple{T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(A; unitcell=(1, 1))\n\nCreate an InfinitePartitionFunction by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if partition function tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            |          |\n---T[r,c-1]-----AA[r,c]----AA[r,c+1]----\n   |            |          |\n---T[r+1,c-1]---AA[r+1,c]--AA[r+1,c+1]--\n   |            |          |\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(A::AbstractMatrix{T})\n\nCreate an InfinitePartitionFunction by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{M}, Tuple{Any, Any, M}, Tuple{Any, Any, M, M}} where M<:(AbstractMatrix{<:TensorKit.ElementarySpace})","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(\n    [f=randn, T=ComplexF64,] Pspaces::A, Nspaces::A, [Espaces::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfinitePartitionFunction by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePartitionFunction-Union{Tuple{S}, Tuple{Any, Any, S}, Tuple{Any, Any, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePartitionFunction","text":"InfinitePartitionFunction(\n    [f=randn, T=ComplexF64,] Pspace::S, Nspace::S, [Espace::S]; unitcell=(1,1)\n) where {S<:ElementarySpace}\n\nCreate an InfinitePartitionFunction by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via Int or via ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteSquare","page":"Library","title":"PEPSKit.InfiniteSquare","text":"struct InfiniteSquare <: MPSKitModels.AbstractLattice{2}\n\nInfinite square lattice with a unit cell of size (Nrows, Ncols).\n\nFields\n\nNrows::Int64\nNcols::Int64\n\nConstructor\n\nInfiniteSquare([Nrows=1, Ncols=1])\n\nBy default, an infinite square with a (1, 1)-unitcell is constructed.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteSquareNetwork","page":"Library","title":"PEPSKit.InfiniteSquareNetwork","text":"struct InfiniteSquareNetwork{O}\n\nContractible square network. Wraps a matrix of 'rank-4-tensor-like' objects.\n\nFields\n\nA::Matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO{H,T,O}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS{T}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS(T::InfinitePEPS, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.IterEigh","page":"Library","title":"PEPSKit.IterEigh","text":"struct IterEigh\n\nIterative eigenvalue solver based on KrylovKit's eigsolve, adapted to (symmetric) tensors. The number of targeted eigenvalues is set via the truncspace in ProjectorAlg. In particular, this makes it possible to specify the targeted eigenvalues block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative decomposition didn't converge, the algorithm falls back to a dense eigh/eigh.\n\nFields\n\nalg::Any\nfallback_threshold::Float64\nstart_vector::Any\n\nConstructors\n\nIterEigh(; kwargs...)\n\nConstruct an IterEigh algorithm struct based on the following keyword arguments:\n\nalg=KrylovKit.Lanczos(; tol=1e-14, krylovdim=25) : KrylovKit algorithm struct for iterative eigenvalue decomposition.\nfallback_threshold::Float64=Inf : Threshold for howmany / minimum(size(block)) above which (if the block is too small) the algorithm falls back to a dense decomposition.\nstart_vector=random_start_vector : Function providing the initial vector for the iterative algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.IterSVD","page":"Library","title":"PEPSKit.IterSVD","text":"struct IterSVD\n\nIterative SVD solver based on KrylovKit's GKL algorithm, adapted to (symmetric) tensors. The number of targeted singular values is set via the truncspace in ProjectorAlg. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn't converge, the algorithm falls back to a dense SVD.\n\nFields\n\nalg::KrylovKit.GKL\nfallback_threshold::Float64\nstart_vector::Any\n\nConstructors\n\nIterSVD(; kwargs...)\n\nConstruct an IterSVD algorithm struct based on the following keyword arguments:\n\nalg::KrylovKit.GKL=KrylovKit.GKL(; tol=1e-14, krylovdim=25) : GKL algorithm struct for block-wise iterative SVD.\nfallback_threshold::Float64=Inf : Threshold for howmany / minimum(size(block)) above which (if the block is too small) the algorithm falls back to TensorKit's dense SVD.\nstart_vector=random_start_vector : Function providing the initial vector for the iterative SVD algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LinSolver","page":"Library","title":"PEPSKit.LinSolver","text":"struct LinSolver{F} <: PEPSKit.GradMode{F}\n\nGradient mode wrapper around KrylovKit.LinearSolver for solving the gradient linear problem using iterative solvers.\n\nFields\n\nsolver_alg::KrylovKit.LinearSolver\n\nConstructors\n\nLinSolver(; kwargs...)\n\nConstruct the LinSolver algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance of the linear solver.\nmaxiter::Int=30 : Maximal number of solver iterations.\nverbosity::Int=-1 : Output information verbosity of the linear solver.\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\nsolver_alg::Union{KrylovKit.LinearSolver,NamedTuple}=(; alg::Symbol=:bicgstab : Linear solver algorithm which, if supplied directly as a KrylovKit.LinearSolver overrides the above specified tol, maxiter and verbosity. Alternatively, it can be supplied via a NamedTuple where alg can be one of the following:\n:gmres : GMRES iterative linear solver, see KrylovKit.GMRES for details\n:bicgstab : BiCGStab iterative linear solver, see KrylovKit.BiCGStab for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LocalOperator","page":"Library","title":"PEPSKit.LocalOperator","text":"struct LocalOperator{T<:Tuple, S}\n\nA sum of local operators acting on a lattice. The lattice is stored as a matrix of vector spaces, and the terms are stored as a tuple of pairs of indices and operators.\n\nFields\n\nlattice::Matrix{S}: The lattice on which the operator acts.\nterms::T: The terms of the operator, stored as a tuple of pairs of indices and operators.\n\nConstructors\n\nLocalOperator(lattice::Matrix{S}, terms::Pair...)\nLocalOperator{T,S}(lattice::Matrix{S}, terms::T) where {T,S}\n\nExamples\n\nlattice = fill(ℂ^2, 1, 1) # single-site unitcell\nO1 = LocalOperator(lattice, ((1, 1),) => σx, ((1, 1), (1, 2)) => σx ⊗ σx, ((1, 1), (2, 1)) => σx ⊗ σx)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ManualIter","page":"Library","title":"PEPSKit.ManualIter","text":"struct ManualIter{F} <: PEPSKit.GradMode{F}\n\nGradient mode for CTMRG using manual iteration to solve the linear problem.\n\nFields\n\ntol::Real\nmaxiter::Int64\nverbosity::Int64\n\nConstructors\n\nManualIter(; kwargs...)\n\nConstruct the ManualIter algorithm struct based on the following keyword arguments:\n\ntol::Real=1.0e-6 : Convergence tolerance for the norm difference of two consecutive dx contributions.\nmaxiter::Int=30 : Maximal number of gradient iterations.\nverbosity::Int=-1 : Output information verbosity that can be one of the following:\nSuppress output information\nPrint convergence warnings\nInformation at each gradient iteration\niterscheme::Symbol=:fixed : Style of CTMRG iteration which is being differentiated, which can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPO","page":"Library","title":"PEPSKit.MultilineTransferPEPO","text":"const MultilineTransferPEPO = MPSKit.Multiline{<:InfiniteTransferPEPO}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any}","page":"Library","title":"PEPSKit.MultilineTransferPEPO","text":"MultilineTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPS","page":"Library","title":"PEPSKit.MultilineTransferPEPS","text":"const MultilineTransferPEPS = MPSKit.Multiline{<:InfiniteTransferPEPS}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.MultilineTransferPEPS-Tuple{InfinitePEPS, Any}","page":"Library","title":"PEPSKit.MultilineTransferPEPS","text":"MultilineTransferPEPS(T::InfinitePEPS, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.PEPOTensor","page":"Library","title":"PEPSKit.PEPOTensor","text":"const PEPOTensor{S}\n\nDefault type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: T  P  P  N  E  S  W. Here, P and P denote the incoming and outgoing physical space respectively, encoding the physical mapping from P to P where P corresponds to a physical PEPS index. N, E, S and W denote the physics, north, east, south and west spaces, respectively.\n\n        P´ N\n        | ╱\n        |╱\n   W---- ----E\n       ╱|\n      ╱ |\n     S  P\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSOptimize","page":"Library","title":"PEPSKit.PEPSOptimize","text":"struct PEPSOptimize{B, G}\n\nAlgorithm struct for PEPS ground-state optimization using AD. See fixedpoint for details.\n\nFields\n\nboundary_alg::Any\ngradient_alg::Any\noptimizer_alg::OptimKit.OptimizationAlgorithm\nreuse_env::Bool\nsymmetrization::Union{Nothing, PEPSKit.SymmetrizationStyle}\n\nConstructors\n\nPEPSOptimize(; kwargs...)\n\nConstruct a PEPS optimization algorithm struct based on keyword arguments. For a full description, see fixedpoint. The supported keywords are:\n\nboundary_alg::Union{NamedTuple,<:CTMRGAlgorithm,...}\ngradient_alg::Union{NamedTuple,Nothing,<:GradMode}\noptimizer_alg::Union{NamedTuple,<:OptimKit.OptimizationAlgorithm}\nreuse_env::Bool=true\nsymmetrization::Union{Nothing,SymmetrizationStyle}=nothing\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor","page":"Library","title":"PEPSKit.PEPSTensor","text":"const PEPSTensor{S}\n\nDefault type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: T  P  N  E  S  W. Here, P denotes the physical space and N, E, S and W denote the north, east, south and west virtual spaces, respectively.\n\n           N\n          ╱\n         ╱\n   W---- ----E\n       ╱|\n      ╱ |\n     S  P\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.PEPSTensor","text":"PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,\n           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S<:Union{Int,ElementarySpace}}\n\nConstruct a PEPS tensor based on the physical, north, east, south and west spaces. The tensor elements are generated based on f and the element type is specified in T.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.PEPSWeight","page":"Library","title":"PEPSKit.PEPSWeight","text":"const PEPSWeight\n\nDefault type for PEPS bond weights with 2 virtual indices.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PartitionFunctionTensor","page":"Library","title":"PEPSKit.PartitionFunctionTensor","text":"const PartitionFunctionTensor{S}\n\nDefault type for partition function tensors with 4 virtual indices, conventionally ordered as: T  W  S  N  E. Here, N, E, S and W denote the north, east, south and west spaces, respectively.\n\n          N\n         ╱\n        ╱\n  W---- ----E\n      ╱\n     ╱\n    S \n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PartitionFunctionTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}} where {T, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.PartitionFunctionTensor","text":"PartitionFunctionTensor(f, ::Type{T}, Pspace::S, Nspace::S,\n           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S<:Union{Int,ElementarySpace}}\n\nConstruct a PartitionFunctionTensor tensor based on the north, east, west and south spaces. The tensor elements are generated based on f and the element type is specified in T.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ProjectorAlgorithm","page":"Library","title":"PEPSKit.ProjectorAlgorithm","text":"abstract type ProjectorAlgorithm\n\nAbstract super type for all CTMRG projector algorithms.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ProjectorAlgorithm-Tuple{}","page":"Library","title":"PEPSKit.ProjectorAlgorithm","text":"ProjectorAlgorithm(; kwargs...)\n\nKeyword argument parser returning the appropriate ProjectorAlgorithm algorithm struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.QRAdjoint","page":"Library","title":"PEPSKit.QRAdjoint","text":"struct QRAdjoint{F, R}\n\nWrapper for a QR decomposition algorithm fwd_alg with a defined reverse rule rrule_alg. If isnothing(rrule_alg), Zygote differentiates the forward call automatically.\n\nFields\n\nfwd_alg::Any\nrrule_alg::Any\n\nConstructors\n\nQRAdjoint(; kwargs...)\n\nConstruct a QRAdjoint algorithm struct based on the following keyword arguments:\n\nfwd_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=qr): Eig algorithm of the forward pass which can either be passed as an Algorithm instance or a NamedTuple where alg is one of the following:\n:qr : MatrixAlgebraKit's LAPACK_HouseholderQR\nrrule_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=qr): Reverse-rule algorithm for differentiating the eigenvalue decomposition. Can be supplied by an Algorithm instance directly or as a NamedTuple where alg is one of the following:\n:qr : MatrixAlgebraKit's qr_pullback\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.QRPullback","page":"Library","title":"PEPSKit.QRPullback","text":"struct QRPullback\n\nQR reverse-rule algorithm which wraps MatrixAlgebraKit's qr_pullback!.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectDepth","page":"Library","title":"PEPSKit.ReflectDepth","text":"struct ReflectDepth <: PEPSKit.SymmetrizationStyle\n\nReflection symmmetrization along the horizontal axis, such that north and south are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectWidth","page":"Library","title":"PEPSKit.ReflectWidth","text":"struct ReflectWidth <: PEPSKit.SymmetrizationStyle\n\nReflection symmmetrization along the vertical axis, such that east and west are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.Rotate","page":"Library","title":"PEPSKit.Rotate","text":"struct Rotate <: PEPSKit.SymmetrizationStyle\n\nRotation symmmetrization leaving the object invariant under π/2 rotations.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.RotateReflect","page":"Library","title":"PEPSKit.RotateReflect","text":"struct RotateReflect <: PEPSKit.SymmetrizationStyle\n\nFull reflection and rotation symmmetrization, such that reflection along the horizontal and vertical axis as well as π/2 rotations leave the object invariant.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SUGauge","page":"Library","title":"PEPSKit.SUGauge","text":"struct SUGauge\n\nAlgorithm for fixing gauge of an iPEPS using trivial simple update (with identity gates).\n\nFields\n\ntol::Float64: Stopping criterion for the trivial SU iterations in weight difference\nminiter::Int64: Minimal number of SU iterations\nmaxiter::Int64: Maximal number of SU iterations\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SUState","page":"Library","title":"PEPSKit.SUState","text":"Internal state of simple update algorithm\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SUWeight","page":"Library","title":"PEPSKit.SUWeight","text":"struct SUWeight{E<:PEPSWeight}\n\nSchmidt bond weights used in simple/cluster update. Each weight is a real and semi-positive definite DiagonalTensorMap, with the same codomain and domain.\n\nOn the square lattice,\n\nwt[1,r,c] is on the x-bond between [r,c] and [r,c+1];\nwt[2,r,c] is on the y-bond between [r,c] and [r-1,c].\n\nAxis order of each weight matrix is\n\n    x-weights:      y-weights:\n\n    1 - x - 2           2\n                        |\n                        y\n                        |\n                        1\n\nFields\n\ndata::Array{E, 3} where E<:(TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S})\n\nConstructors\n\nSUWeight(wts_mats::AbstractMatrix{E}...) where {E<:PEPSWeight}\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SUWeight-Tuple{BPEnv}","page":"Library","title":"PEPSKit.SUWeight","text":"SUWeight(env::BPEnv)\n\nConstruct SUWeight from belief propagation fixed point environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.SUWeight-Tuple{InfinitePEPO}","page":"Library","title":"PEPSKit.SUWeight","text":"SUWeight(pepo::InfinitePEPO)\n\nCreate a trivial SUWeight for a given one-layer InfinitePEPO.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.SUWeight-Tuple{InfinitePEPS}","page":"Library","title":"PEPSKit.SUWeight","text":"SUWeight(peps::InfinitePEPS)\n\nCreate a trivial SUWeight for a given InfinitePEPS.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.SUWeight-Union{Tuple{M}, Tuple{M, M}} where M<:(AbstractMatrix{<:TensorKit.ElementarySpace})","page":"Library","title":"PEPSKit.SUWeight","text":"SUWeight(Nspaces::M, [Espaces::M]) where {M<:AbstractMatrix{<:ElementarySpace}}\n\nCreate a trivial SUWeight by specifying the vertical (north) or horizontal (east) virtual bond spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.SUWeight-Union{Tuple{S}, Tuple{S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.SUWeight","text":"SUWeight(Nspace::S, Espace::S=Nspace; unitcell::Tuple{Int,Int}=(1, 1)) where {S<:ElementarySpace}\n\nCreate a trivial SUWeight by specifying its vertical (north) and horizontal (east)  as ElementarySpaces) and unit cell size.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.SVDAdjoint","page":"Library","title":"PEPSKit.SVDAdjoint","text":"struct SVDAdjoint{F, R}\n\nWrapper for a SVD algorithm fwd_alg with a defined reverse rule rrule_alg. If isnothing(rrule_alg), Zygote differentiates the forward call automatically.\n\nFields\n\nfwd_alg::Any\nrrule_alg::Any\n\nConstructors\n\nSVDAdjoint(; kwargs...)\n\nConstruct a SVDAdjoint algorithm struct based on the following keyword arguments:\n\nfwd_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=sdd): SVD algorithm of the forward pass which can either be passed as an Algorithm instance or a NamedTuple where alg is one of the following:\n:sdd : MatrixAlgebraKit's LAPACK_DivideAndConquer\n:svd : MatrixAlgebraKit's LAPACK_QRIteration\n:bisection : MatrixAlgebraKit's LAPACK_Bisection\n:jacobi : MatrixAlgebraKit's LAPACK_Jacobi\n:iterative : Iterative SVD only computing the specifed number of singular values and vectors, see IterSVD\nrrule_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=full): Reverse-rule algorithm for differentiating the SVD. Can be supplied by an Algorithm instance directly or as a NamedTuple where alg is one of the following:\n:full : MatrixAlgebraKit's svd_pullback! that requires access to the full spectrum\n:trunc : MatrixAlgebraKit's svd_trunc_pullback! solving a Sylvester equation on the truncated subspace\n:gmres : GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab : BiCGStab iterative linear solver, see the KrylovKit docs for details\n:arnoldi : Arnoldi Krylov algorithm, see the KrylovKit docs for details\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ScramblingEnvGauge","page":"Library","title":"PEPSKit.ScramblingEnvGauge","text":"struct ScramblingEnvGauge\n\nCTMRG environment gauge fixing algorithm implementing the \"general\" technique from https://arxiv.org/abs/2311.11894. This works by constructing a transfer matrix consisting of an edge tensor and a random MPS, thus scrambling potential degeneracies, and then performing a QR decomposition to extract the gauge signs. This is adapted accordingly for asymmetric CTMRG algorithms using multi-site unit cell transfer matrices.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ScramblingEnvGaugeC4v","page":"Library","title":"PEPSKit.ScramblingEnvGaugeC4v","text":"struct ScramblingEnvGaugeC4v\n\nC4v-symmetric equivalent of the ScramblingEnvGauge` environment gauge fixing algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SequentialCTMRG","page":"Library","title":"PEPSKit.SequentialCTMRG","text":"struct SequentialCTMRG <: CTMRGAlgorithm\n\nCTMRG algorithm where the expansions and renormalization is performed sequentially column-wise. This is implemented as a growing and projecting step to the left, followed by a clockwise rotation (performed four times).\n\nFields\n\ntol::Float64\nmaxiter::Int64\nminiter::Int64\nverbosity::Int64\nprojector_alg::PEPSKit.ProjectorAlgorithm\n\nConstructors\n\nSequentialCTMRG(; kwargs...)\n\nConstruct a sequential CTMRG algorithm struct based on keyword arguments. For a full description, see leading_boundary. The supported keywords are:\n\ntol::Real=1.0e-8\nmaxiter::Int=100\nminiter::Int=4\nverbosity::Int=2\ntrunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)\ndecomposition_alg::Union{<:SVDAdjoint,NamedTuple}\nprojector_alg::Symbol=:halfinfinite\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimpleUpdate","page":"Library","title":"PEPSKit.SimpleUpdate","text":"struct SimpleUpdate <: PEPSKit.TimeEvolution\n\nAlgorithm struct for simple update (SU) of InfinitePEPS or InfinitePEPO.\n\nFields\n\ntrunc::MatrixAlgebraKit.TruncationStrategy: Truncation strategy for bonds updated by Trotter gates\nimaginary_time::Bool: When true (or false), the Trotter gate is exp(-H dt) (or exp(-iH dt))\nforce_3site::Bool: When true, force the usage of 3-site simple update\nbipartite::Bool: When true, assume bipartite unit cell structure\npurified::Bool: (Only applicable to InfinitePEPO)     When true, the PEPO is regarded as a purified PEPS, and updated as     |ρ(t + dt)⟩ = exp(-H dt/2) |ρ(t)⟩.     When false, the PEPO is updated as     ρ(t + dt) = exp(-H dt/2) ρ(t) exp(-H dt/2).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimultaneousCTMRG","page":"Library","title":"PEPSKit.SimultaneousCTMRG","text":"struct SimultaneousCTMRG{P<:PEPSKit.ProjectorAlgorithm} <: PEPSKit.CTMRGAlgorithm\n\nCTMRG algorithm where all sides are grown and renormalized at the same time. In particular, the projectors are applied to the corners from two sides simultaneously.\n\nFields\n\ntol::Float64\nmaxiter::Int64\nminiter::Int64\nverbosity::Int64\nprojector_alg::PEPSKit.ProjectorAlgorithm\n\nConstructors\n\nSimultaneousCTMRG(; kwargs...)\n\nConstruct a simultaneous CTMRG algorithm struct based on keyword arguments. For a full description, see leading_boundary. The supported keywords are:\n\ntol::Real=1.0e-8\nmaxiter::Int=100\nminiter::Int=4\nverbosity::Int=2\ntrunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)\ndecomposition_alg::Union{<:SVDAdjoint,NamedTuple}\nprojector_alg::Symbol=:halfinfinite\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TimeEvolution","page":"Library","title":"PEPSKit.TimeEvolution","text":"abstract type TimeEvolution\n\nAbstract super type for time evolution algorithms of InfinitePEPS or InfinitePEPO.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TimeEvolver","page":"Library","title":"PEPSKit.TimeEvolver","text":"mutable struct TimeEvolver{TE <: TimeEvolution, G, S, N <: Number}\n\nIterator for Trotter-based time evolution of InfinitePEPS or InfinitePEPO.\n\nFields\n\nalg::PEPSKit.TimeEvolution: Time evolution algorithm (currently supported: SimpleUpdate)\ndt::Number: Trotter time step\nnstep::Int64: The number of iteration steps\ngate::Any: Trotter gates\nstate::Any: Internal state of the iterator, including the number of     already performed iterations, evolved time, PEPS/PEPO and its environment\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TimeEvolver-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Number, Int64, SimpleUpdate, SUWeight}","page":"Library","title":"PEPSKit.TimeEvolver","text":"TimeEvolver(\n    psi0::InfiniteState, H::LocalOperator, dt::Number, nstep::Int, \n    alg::SimpleUpdate, env0::SUWeight; t0::Number = 0.0\n)\n\nInitialize a TimeEvolver with Hamiltonian H and simple update alg,  starting from the initial state psi0 and SUWeight environment env0.\n\nThe initial time is specified by t0.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.TruncEighPullback","page":"Library","title":"PEPSKit.TruncEighPullback","text":"struct TruncEighPullback\n\nTruncated eigh reverse-rule algorithm which wraps MatrixAlgebraKit's eigh_trunc_pullback!.\n\nFields\n\ndegeneracy_atol::Real\nverbosity::Int64\n\nConstructors\n\nTruncEighPullback(; kwargs...)\n\nConstruct a TruncEighPullback algorithm struct from the following keyword arguments:\n\nverbosity::Int=0 : Suppresses all output if ≤0, prints gauge dependency warnings if 1, and always prints gauge dependency if ≥2.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TruncSVDPullback","page":"Library","title":"PEPSKit.TruncSVDPullback","text":"struct TruncSVDPullback\n\nSVD reverse-rule algorithm which wraps MatrixAlgebraKit's svd_trunc_pullback!.\n\nFields\n\ndegeneracy_atol::Real\nverbosity::Int64\n\nConstructors\n\nTruncSVDPullback(; kwargs...)\n\nConstruct a TruncSVDPullback algorithm struct from the following keyword arguments:\n\ndegeneracy_atol::Real=1.0e-13 : Broadening amplitude for smoothing divergent term in SVD derivative in case of (pseudo) degenerate singular values.\nverbosity::Int=0 : Suppresses all output if ≤0, prints gauge dependency warnings if 1, and always prints gauge dependency if ≥2.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.ColumnEnlargedCorner}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(Q::ColumnEnlargedCorner)\n\nInstantiate column-enlarged corner as a TensorMap.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.EnlargedCorner}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(Q::EnlargedCorner)\n\nInstantiate enlarged corner as a TensorMap.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.FullInfiniteEnv}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(env::FullInfiniteEnv)\n\nInstantiate full-infinite environment as TensorMap explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.HalfInfiniteEnv}","page":"Library","title":"TensorKit.TensorMap","text":"TensorMap(env::HalfInfiniteEnv)\n\nInstantiate half-infinite environment as TensorMap explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#FiniteDifferences.to_vec-Tuple{InfinitePEPS}","page":"Library","title":"FiniteDifferences.to_vec","text":"to_vec(A::InfinitePEPS) -> vec, state_from_vec\n\nVectorize an InfinitePEPS into a vector of real numbers. A vectorized infinite PEPS can retrieved again as an InfinitePEPS by application of the state_from_vec map.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.add_physical_charge-Tuple{LocalOperator, AbstractMatrix{<:TensorKitSectors.Sector}}","page":"Library","title":"MPSKit.add_physical_charge","text":"add_physical_charge(H::LocalOperator, charges::AbstractMatrix{<:Sector})\n\nChange the spaces of a LocalOperator by fusing in an auxiliary charge into the domain of the operator on every site, according to a given matrix of 'auxiliary' physical charges.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.correlation_length-Tuple{Any, CTMRGEnv}","page":"Library","title":"MPSKit.correlation_length","text":"correlation_length(state, env::CTMRGEnv; num_vals=2, kwargs...)\n\nCompute the correlation length associated to state as contracted using the environment env, based on the spectrum of the horizontal and vertical transfer matrices associated to env. Additionally the (normalized) eigenvalue spectrum is returned. The number of computed eigenvalues can be specified using num_vals, and any remaining keyword arguments are passed through to MPSKit.transfer_spectrum (e.g. allowing to target the correlation length in a specific symmetry sector).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{Any, Any}","page":"Library","title":"MPSKit.expectation_value","text":"MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})\nMPSKit.expectation_value(st::MultilineMPS, op::Union{MultilineTransferPEPS,MultilineTransferPEPO})\n\nCompute expectation value of the transfer operator op for the state st for each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Union{InfinitePEPO, InfinitePEPS}, CTMRGEnv}","page":"Library","title":"MPSKit.expectation_value","text":"expectation_value(state, O::LocalOperator, env::CTMRGEnv)\nexpectation_value(bra, O::LocalOperator, ket, env::CTMRGEnv)\n\nCompute the expectation value ⟨bra|O|ket⟩ / ⟨bra|ket⟩ of a LocalOperator O. This can be done either for a PEPS, or alternatively for a density matrix PEPO. In the latter case the first signature corresponds to a single layer PEPO contraction, while the second signature yields a bilayer contraction instead.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Union{Tuple{S}, Tuple{T}, Tuple{InfinitePartitionFunction, Pair{CartesianIndex{2}, <:TensorKit.AbstractTensorMap{T, S, 2, 2}}, CTMRGEnv}} where {T, S}","page":"Library","title":"MPSKit.expectation_value","text":"expectation_value(pf::InfinitePartitionFunction, inds => O, env::CTMRGEnv)\n\nCompute the expectation value corresponding to inserting a local tensor(s) O at position inds in the partition function pf and contracting the chole using a given CTMRG environment env.\n\nHere inds can be specified as either a Tuple{Int,Int} or a CartesianIndex{2}, and O should be a rank-4 tensor conforming to the PartitionFunctionTensor indexing convention.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, Any, Any}","page":"Library","title":"MPSKit.leading_boundary","text":"leading_boundary(\n    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [env]\n)\nleading_boundary(\n    st::MPSMulitline, op::Union{MultilineTransferPEPS,MultilineTransferPEPO}, alg, [env]\n)\n\nApproximate the leading boundary MPS eigenvector for the transfer operator op using st as initial guess.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{BPEnv, InfiniteSquareNetwork, BeliefPropagation}","page":"Library","title":"MPSKit.leading_boundary","text":"leading_boundary(env₀::BPEnv, network, alg::BeliefPropagation)\n\nContract network in the BP approximation and return the corresponding messages.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{CTMRGEnv, InfiniteSquareNetwork}","page":"Library","title":"MPSKit.leading_boundary","text":"leading_boundary(env₀, network; kwargs...) -> env, info\n# expert version:\nleading_boundary(env₀, network, alg::CTMRGAlgorithm)\n\nContract network using CTMRG and return the CTM environment. The algorithm can be supplied via the keyword arguments or directly as an CTMRGAlgorithm struct.\n\nKeyword arguments\n\nCTMRG iterations\n\ntol::Real=1.0e-8 : Stopping criterium for the CTMRG iterations. This is the norm convergence, as well as the distance in singular values of the corners and edges.\nminiter::Int=4 : Minimal number of CTMRG iterations.\nmaxiter::Int=100 : Maximal number of CTMRG iterations.\nverbosity::Int=2 : Output verbosity level, should be one of the following:\nSuppress all output\nOnly print warnings\nInitialization and convergence info\nIteration info\nDebug info\nalg::Symbol=:simultaneous : Variant of the CTMRG algorithm. See also CTMRGAlgorithm.\n:simultaneous : Simultaneous expansion and renormalization of all sides.\n:sequential : Sequential application of left moves and rotations.\n:c4v : CTMRG assuming C₄ᵥ-symmetric PEPS and environment.\n\nProjector algorithm\n\ntrunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace) : Truncation strategy for the projector computation, which controls the resulting virtual spaces. Here, alg can be one of the following:\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerror : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncrank : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:trunctol : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\ndecomposition_alg : Tensor decomposition algorithm for computing projectors. See e.g. SVDAdjoint. \nprojector_alg::Symbol=:halfinfinite : Variant of the projector algorithm. See also ProjectorAlgorithm.\n:halfinfinite : Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.\n:fullinfinite : Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.\n:c4v_eigh : Projection via eigh of the Hermitian enlarged corner.\n\nReturn values\n\nThe CTMRG routine returns the final CTMRG environment as well as an information NamedTuple containing the following fields:\n\ntruncation_error : Last (maximal) SVD truncation error of the CTMRG projectors.\ncondition_number : Last (maximal) condition number of the enlarged CTMRG environment.\n\nIn case the alg is a SimultaneousCTMRG, the last SVD will also be returned:\n\nU : Last unit cell of left singular vectors.\nS : Last unit cell of singular values.\nV : Last unit cell of right singular vectors.\n\nIf, in addition, the specified SVD algorithm computes the full, untruncated SVD, the full set of vectors and values will be returned as well:\n\nU_full : Last unit cell of all left singular vectors.\nS_full : Last unit cell of all singular values.\nV_full : Last unit cell of all right singular vectors.\n\nFor C4vCTMRG instead the last eigendecomposition V and D (and V_full, D_full) will be returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.physicalspace-Tuple{LocalOperator}","page":"Library","title":"MPSKit.physicalspace","text":"physicalspace(O::LocalOperator)\n\nReturn lattice of physical spaces on which the LocalOperator is defined.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.time_evolve-Tuple{TimeEvolver{<:SimpleUpdate}}","page":"Library","title":"MPSKit.time_evolve","text":"time_evolve(\n    it::TimeEvolver{<:SimpleUpdate}; \n    tol::Float64 = 0.0, check_interval::Int = 500\n) -> (psi, env, info)\n\nPerform time evolution to the end of TimeEvolver iterator it, or until convergence of SUWeight set by a positive tol.\n\nSetting tol > 0 enables convergence check (for imaginary time evolution of InfinitePEPS only).   For other usages it should not be changed.\ncheck_interval sets the number of iterations between outputs of information.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.time_evolve-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Number, Int64, SimpleUpdate, SUWeight}","page":"Library","title":"MPSKit.time_evolve","text":"time_evolve(\n    psi0::Union{InfinitePEPS, InfinitePEPO}, H::LocalOperator, \n    dt::Number, nstep::Int, alg::SimpleUpdate, env0::SUWeight;\n    tol::Float64 = 0.0, t0::Number = 0.0, check_interval::Int = 500\n) -> (psi, env, info)\n\nPerform time evolution on the initial state psi0 and initial environment env0 with Hamiltonian H, using SimpleUpdate algorithm alg, time step dt for  nstep number of steps. \n\nSetting tol > 0 enables convergence check (for imaginary time evolution of InfinitePEPS only).   For other usages it should not be changed.\nUse t0 to specify the initial time of the evolution.\ncheck_interval sets the interval to output information. Output during the evolution can be turned off by setting check_interval <= 0.\ninfo is a NamedTuple containing information of the evolution,    including the time info.t evolved since psi0.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.timestep-Tuple{TimeEvolver{<:SimpleUpdate}, Union{InfinitePEPO, InfinitePEPS}, SUWeight}","page":"Library","title":"MPSKit.timestep","text":"timestep(\n    it::TimeEvolver{<:SimpleUpdate}, psi::InfiniteState, env::SUWeight\n) -> (psi, env, info)\n\nGiven the TimeEvolver iterator it, perform one step of time evolution on the input state psi and its environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MatrixAlgebraKit.eigh_trunc-Tuple{Any, EighAdjoint}","page":"Library","title":"MatrixAlgebraKit.eigh_trunc","text":"eigh_trunc(t, alg::EighAdjoint; trunc=notrunc())\neigh_trunc!(t, alg::EighAdjoint; trunc=notrunc())\n\nWrapper around eigh_trunc(!) which dispatches on the EighAdjoint algorithm. This is needed since a custom adjoint may be defined, depending on the alg.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MatrixAlgebraKit.left_orth-Tuple{Any, QRAdjoint}","page":"Library","title":"MatrixAlgebraKit.left_orth","text":"left_orth(t, alg::QRAdjoint)\nleft_orth!(t, alg::QRAdjoint)\n\nWrapper around left_orth(!) which dispatches on the QRAdjoint algorithm. This is needed since a custom adjoint may be defined, depending on the alg.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MatrixAlgebraKit.svd_trunc-Tuple{Any, SVDAdjoint}","page":"Library","title":"MatrixAlgebraKit.svd_trunc","text":"svd_trunc(t, alg::SVDAdjoint; trunc=notrunc())\nsvd_trunc!(t, alg::SVDAdjoint; trunc=notrunc())\n\nWrapper around svd_trunc(!) which dispatches on the SVDAdjoint algorithm. This is needed since a custom adjoint may be defined, depending on the alg. E.g., for IterSVD the adjoint for a truncated SVD from KrylovKit.svdsolve is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._apply_gate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap{T, S, 2, 2}, MatrixAlgebraKit.TruncationStrategy}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._apply_gate","text":"_apply_gate(a, b, gate, trunc)\n\n\nApply 2-site gate on the reduced matrices a, b\n\n    -1← a --- 3 --- b ← -4          -2         -3\n        ↓           ↓               ↓           ↓\n        1           2               |----gate---|\n        ↓           ↓       or      ↓           ↓\n        |----gate---|               1           2\n        ↓           ↓               ↓           ↓\n        -2         -3           -1← a --- 3 --- b ← -4\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._apply_gatempo!-Union{Tuple{T2}, Tuple{T1}, Tuple{Vector{T1}, Vector{T2}}} where {T1<:(TensorKit.AbstractTensorMap{T, var\"#s82\", 4, 1} where {var\"#s82\"<:TensorKit.ElementarySpace, T}), T2<:TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit._apply_gatempo!","text":"Apply the gate MPO gs on the cluster Ms. When gate_ax is 1 or 2, the gate acts from the physical codomain or domain side.\n\ne.g. Cluster in PEPS with gate_ax = 1:\n\n         ╱       ╱       ╱\n    --- M1 -←-- M2 -←-- M3 ---\n      ╱ |     ╱ |     ╱ |\n        ↓       ↓       ↓\n        g1 -←-- g2 -←-- g3\n        ↓       ↓       ↓\n\nIn the cluster, the axes of each tensor use the MPS order\n\n    PEPS:           PEPO:\n           3             3  4\n          ╱              | ╱\n    1 -- M -- 5     1 -- M -- 6\n       ╱ |             ╱ |\n      4  2            5  2\n    M[1 2 3 4; 5]  M[1 2 3 4 5; 6]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._bp_gauge_fix!-Tuple{CartesianIndex{3}, InfinitePEPS, BPEnv}","page":"Library","title":"PEPSKit._bp_gauge_fix!","text":"_bp_gauge_fix!(I, psi::InfinitePEPS, env::BPEnv) -> psi, X, X⁻¹\n\nFor the bond at direction I[1] (which can be NORTH or EAST) from site I[2], I[3], we identify the following gauge matrices, along the canonical direction of the PEPS arrows (SOUTH ← NORTH or WEST ← EAST):\n\n    I = M₁₂¹ M₁₂ M₂₁ M₂₁¹\n      = M₁₂¹ (U Λ Vᴴ) M₂₁¹\n      = (M₁₂¹ U Λ) (Λ Vᴴ M₂₁¹)\n      = X X¹\n\nWhich are then used to update the gauge of psi. Thus, by convention X is attached to the SOUTH/WEST directions and X⁻¹ is attached to the NORTH/EAST directions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._check_algorithm_combination-Tuple{Any, Any}","page":"Library","title":"PEPSKit._check_algorithm_combination","text":"_check_algorithm_combination(boundary_alg, gradient_alg)\n\nCheck for allowed combinations of gradient algorithm and boundary algorithm to be used for computing the gradient of a leading_boundary call. Throws an error containing a recommended fix if the combination is not allowed or broken.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._cluster_truncate!-Union{Tuple{E}, Tuple{T}, Tuple{Vector{T}, Vector{E}}} where {T<:(TensorKit.AbstractTensorMap{T, var\"#s163\", 4, 1} where {var\"#s163\"<:TensorKit.ElementarySpace, T}), E<:MatrixAlgebraKit.TruncationStrategy}","page":"Library","title":"PEPSKit._cluster_truncate!","text":"Find projectors to truncate internal bonds of the cluster Ms.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._combine_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._combine_ab","text":"_combine_ab(a, b)\n\n\nContract the axis between a and b tensors\n\n    -- DX - a - D - b - DY --\n            ↓       ↓\n            da      db\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_corners-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_corners","text":"_contract_corners(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract all corners around the south-east at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_horizontal_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_horizontal_edges","text":"_contract_horizontal_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract the horizontal edges and corners around the south edge at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_site-Tuple{Tuple{Int64, Int64}, Any, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_site","text":"_contract_site(ind::Tuple{Int,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv)\n\nContract around a single site ind of a square network using a given CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._contract_vertical_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}","page":"Library","title":"PEPSKit._contract_vertical_edges","text":"_contract_vertical_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)\n\nContract the vertical edges and corners around the east edge at position ind of the CTMRG environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._fixgauge_benvXY-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensor{T, S, 4}, TensorKit.AbstractTensor{T, S, 4}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._fixgauge_benvXY","text":"When the (half) bond environment Z consists of two PEPSOrth tensors X, Y as\n\n    ┌---------------┐   ┌-------------------┐\n    |               | = |                   | ,\n    └---Z--       --┘   └--Z0---X--    --Y--┘\n        ↓                  ↓\n\napply the gauge transformation Linv, Rinv for Z to X, Y:\n\n        -1                                     -1\n         |                                      |\n    -4 - X - 1 - Rinv - -2      -4 - Linv - 1 - Y - -2\n         |                                      |\n        -3                                     -3\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._flip_virtuals!-Union{Tuple{T}, Tuple{Vector{T}, Vector{Bool}}} where T<:(TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T})","page":"Library","title":"PEPSKit._flip_virtuals!","text":"Flip the virtual arrows in the MPS Ms\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._fuse_ids-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, NTuple{N, S}}} where {T, S, N}","page":"Library","title":"PEPSKit._fuse_ids","text":"_fuse_ids(op::AbstractTensorMap{T, S, N, N}, [Ps::NTuple{N, S}]) where {T, S, N}\n\nFuse identities on auxiliary physical spaces Ps into a given operator op. When Ps is not specified, it defaults to the domain spaces of op.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._get_allRLs-Union{Tuple{Vector{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{T, var\"#s682\", 4, 1} where {var\"#s682\"<:TensorKit.ElementarySpace, T})","page":"Library","title":"PEPSKit._get_allRLs","text":"Given a cluster Ms, find all R, L matrices on each internal bond\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._get_allprojs-Union{Tuple{E}, Tuple{Any, Any, Any, Vector{E}}} where E<:MatrixAlgebraKit.TruncationStrategy","page":"Library","title":"PEPSKit._get_allprojs","text":"Given a cluster Ms and the pre-calculated R, L bond matrices, find all projectors Pa, Pb and Schmidt weights wts on internal bonds.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._get_dt-Tuple{Union{InfinitePEPO, InfinitePEPS}, Number, Bool}","page":"Library","title":"PEPSKit._get_dt","text":"Process the Trotter time step dt according to the intended usage.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._get_gatempo_se-Tuple{LocalOperator, Number, Int64, Int64}","page":"Library","title":"PEPSKit._get_gatempo_se","text":"Obtain the 3-site gate MPO on the southeast cluster at position [row, col]\n\n    r-1        g3\n                |\n                ↓\n    r   g1 -←- g2\n        c      c+1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._get_gatempos_se-Tuple{LocalOperator, Number}","page":"Library","title":"PEPSKit._get_gatempos_se","text":"Construct the 3-site gate MPOs on the southeast cluster  for 3-site simple update on square lattice.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._linearmap_twist!-Tuple{TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit._linearmap_twist!","text":"_linearmap_twist!(t)\n\n\nApply a twist to domain or codomain indices that correspond to dual spaces\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._message_tensor-Union{Tuple{P}, Tuple{T}, Tuple{Any, Type{T}, P}} where {T, P<:TensorKit.ProductSpace}","page":"Library","title":"PEPSKit._message_tensor","text":"Construct a message tensor on a certain bond of a network, with bond space specified by pspaces.  In the 2-layer case, the message tensor will be\n\n    ┌--- pspaces[1] (ket layer)\n    m\n    └--- pspaces[2] (bra layer)\n\nReturning axis order is bra ← ket.\n\nWhen posdef is true, the message will be made semi-posdef definite (when interpreted as a bra ← ket TensorMap).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._proj_from_RL-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}}","page":"Library","title":"PEPSKit._proj_from_RL","text":"Given the tensors R, L on a bond, construct  the projectors Pa, Pb and the new bond weight s such that the contraction of Pa, s, Pb is identity when trunc = notrunc,\n\nThe arrows between Pa, s, Pb are\n\n    - Pa --←-- Pb -\n       1 ← s ← 2\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._qr_bond-Union{Tuple{PT}, Tuple{PT, PT}} where PT<:Union{TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._qr_bond","text":"_qr_bond(A, B; gate_ax)\n\n\nUse QR decomposition on two tensors A, B connected by a bond to get the reduced tensors. When A, B are PEPSTensors,\n\n        2                   1                                   1\n        |                   |                                   |\n    5 -A/B- 3   ====>   4 - X ← 2   1 ← a - 3   1 - b → 3   4 → Y - 2\n        | ↘                 |            ↘           ↘          |\n        4   1               3             2           2         3\n\nWhen A, B are PEPOTensors, \n\nIf gate_ax = 1\n\n    2   3                1  2                                1  2\n      ↘ |                 ↘ |                                 ↘ |\n    6 -A/B- 4   ====>   5 - X ← 3   1 ← a - 3   1 - b → 3   5 → Y - 3\n        | ↘                 |            ↘           ↘          |\n        5   1               4             2           2         4\n\nIf gate_ax = 2\n\n    2   3                   2         2           2             2\n      ↘ |                   |          ↘           ↘            |\n    6 -A/B- 4   ====>   5 - X ← 3   1 ← a - 3   1 - b → 3   5 → Y - 3\n        | ↘                 | ↘                                 | ↘\n        5   1               4  1                                4  1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._qr_bond_undo-Tuple{TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit._qr_bond_undo","text":"_qr_bond_undo(X, a, b, Y)\n\n\nReconstruct the tensors connected by a bond from their _qr_bond results. For PEPSTensors,\n\n        -2                             -2\n        |                               |\n    -5- X - 1 - a - -3     -5 - b - 1 - Y - -3\n        |        ↘               ↘      |\n        -4        -1              -1   -4\n\nFor PEPOTensors\n\n    -2  -3                          -2  -3\n      ↘ |                             ↘ |\n    -6- X - 1 - a - -4     -6 - b - 1 - Y - -4\n        |        ↘               ↘      |\n        -5        -1              -1   -5\n\n        -3   -2              -2        -3\n        |      ↘               ↘        |\n    -6- X - 1 - a - -4     -6 - b - 1 - Y - -4\n        | ↘                             | ↘\n        -5 -1                          -5  -1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}","page":"Library","title":"PEPSKit._rrule","text":"_rrule(alg_rrule, config, f, args...; kwargs...) -> ∂f, ∂args...\n\nCustomize the pullback of a function f. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nwarning: Warning\nNo tangent is expected for the alg_rrule argument\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._set_truncation-Tuple{PEPSKit.ProjectorAlgorithm, MatrixAlgebraKit.TruncationStrategy}","page":"Library","title":"PEPSKit._set_truncation","text":"_set_truncation(alg::ProjectorAlgorithm, trunc::TruncationStrategy)\n\nUpdate the truncation strategy of a given projector algorithm, keeping all other settings the same.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._singular_value_distance-Union{Tuple{SV}, Tuple{SV, SV}} where SV<:TensorKit.SectorVector","page":"Library","title":"PEPSKit._singular_value_distance","text":"_singular_value_distance(S₁, S₂)\n\nCompute the singular value distance as an error measure, e.g. for CTMRG iterations. To that end, the singular values of the current iteration S₁ are compared with the previous one S₂. When the virtual spaces change, this comparison is not directly possible such that both tensors are projected into the smaller space and then subtracted.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._solve_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._solve_ab","text":"_solve_ab(Rx, Sx, x0)\n\n\nSolve the equations Rx x = Sx (x = a, b) with initial guess x0\n\n    ┌---------------------------┐\n    |   ┌----┐                  |\n    └---|    |--- 1 -- x -- 2 --┘\n        |    |         ↓\n        | Rx |        -3\n        |    |\n    ┌---|    |--- -1       -2 --┐\n    |   └----┘                  |\n    └---------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._su_xbond!-Union{Tuple{S}, Tuple{T}, Tuple{Union{InfinitePEPO, InfinitePEPS}, TensorKit.AbstractTensorMap{T, S, 2, 2}, SUWeight, Int64, Int64, MatrixAlgebraKit.TruncationStrategy}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._su_xbond!","text":"Simple update of the x-bond between [r,c] and [r,c+1].\n\n        |           |\n    -- T[r,c] -- T[r,c+1] --\n        |           |\n\nWhen gate_ax = 1 (or 2), the gate will be applied to  the codomain (or domain) physicsl legs of state.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._su_ybond!-Union{Tuple{S}, Tuple{T}, Tuple{Union{InfinitePEPO, InfinitePEPS}, TensorKit.AbstractTensorMap{T, S, 2, 2}, SUWeight, Int64, Int64, MatrixAlgebraKit.TruncationStrategy}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._su_ybond!","text":"Simple update of the y-bond between [r,c] and [r-1,c].\n\n        |\n    --T[r-1,c] --\n        |\n    -- T[r,c] ---\n        |\n\nWhen gate_ax = 1 (or 2), the gate will be applied to  the codomain (or domain) physicsl legs of state.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Ra-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Ra","text":"_tensor_Ra(benv, b)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0     Db0 - b -- DY0 -┘\n        |    |                ↓\n        |benv|                db\n        |    |                ↓\n    ┌---|    |- DX1     Db1 - b† - DY1 -┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Rb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Rb","text":"_tensor_Rb(benv, a)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 - a -- Da0     DY0 -┘\n        |    |        ↓\n        |benv|        da\n        |    |        ↓\n    ┌---|    |- DX1 - a† - Da1     DY1 -┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Sa-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Sa","text":"_tensor_Sa(benv, b, a2b2)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 -- (a2 b2) -- DY0 --┘\n        |    |         ↓     ↓\n        |benv|         da    db\n        |    |               ↓\n    ┌---|    |- DX1   Db1 -- b† - DY1 --┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._tensor_Sb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit._tensor_Sb","text":"_tensor_Sb(benv, a, a2b2)\n\n\nConstruct the tensor\n\n    ┌-----------------------------------┐\n    |   ┌----┐                          |\n    └---|    |- DX0 -- (a2 b2) -- DY0 --┘\n        |    |         ↓     ↓\n        |benv|         da    db\n        |    |         ↓\n    ┌---|    |- DX1 -- a† - Da1   DY1 --┐\n    |   └----┘                          |\n    └-----------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._trivial_gates-Union{Tuple{S}, Tuple{Type{<:Number}, Matrix{S}}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit._trivial_gates","text":"A LocalOperator consisting of identity gates on all nearest neighbor bonds.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_s-Tuple{TensorKit.AbstractTensorMap, TensorKit.DiagonalTensorMap, TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit.absorb_s","text":"absorb_s(U::AbstractTensorMap, S::DiagonalTensorMap, V::AbstractTensorMap)\n\nGiven SVD result U, S and V, absorb singular values S into U and V by:\n\n    U -> U * sqrt(S), V -> sqrt(S) * V\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_weight-Tuple{Union{TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace}, SUWeight, Int64, Int64, Int64}","page":"Library","title":"PEPSKit.absorb_weight","text":"absorb_weight(t::Union{PEPSTensor, PEPOTensor}, weights::SUWeight, row::Int, col::Int, ax::Int; inv::Bool = false)\nabsorb_weight(t::Union{PEPSTensor, PEPOTensor}, weights::SUWeight, row::Int, col::Int, ax::NTuple{N, Int}; inv::Bool = false)\n\nAbsorb or remove (in a twist-free way) the square root of environment weight  on an axis of the PEPS/PEPO tensor t known to be at position (row, col) in the unit cell of an InfinitePEPS/InfinitePEPO. The involved weights are\n\n                    |\n                [2,r,c]\n                    |\n    - [1,r,c-1] - T[r,c] - [1,r,c] -\n                    |\n                [1,r+1,c]\n                    |\n\nArguments\n\nt::Union{PEPSTensor, PEPOTensor} : PEPSTensor or PEPOTensor to which the weight will be absorbed.\nweights::SUWeight : All simple update weights.\nrow::Int : The row index specifying the position in the tensor network.\ncol::Int : The column index specifying the position in the tensor network.\nax::Int : The axis into which the weight is absorbed, taking values from 1 to 4, standing for north, east, south, west respectively.\n\nKeyword arguments\n\ninv::Bool=false : If true, the inverse square root of the weight is absorbed.\n\nExamples\n\n# Absorb the weight into the north axis of tensor at position (2, 3)\nabsorb_weight(t, weights, 2, 3, 1)\n\n# Absorb the inverse of (i.e. remove) the weight into the east axis\nabsorb_weight(t, weights, 2, 3, 2; inv=true)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.bond_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, ALSTruncation}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.bond_truncate","text":"bond_truncate(a::AbstractTensorMap{T,S,2,1}, b::AbstractTensorMap{T,S,1,2}, benv::BondEnv{T,S}, alg) -> U, S, V, info\n\nAfter time-evolving the reduced tensors a and b connected by a bond,  truncate the bond dimension using the bond environment tensor benv.\n\n    ┌-----------------------┐\n    |   ┌----┐              |\n    └---|    |-- a === b ---┘\n        |benv|   ↓     ↓\n    ┌---|    |-- a† == b† --┐\n    |   └----┘              |\n    └-----------------------┘\n\nThe truncation algorithm alg can be either FullEnvTruncation or ALSTruncation.  The index order of a or b is\n\n    1 -a/b- 3\n        ↓       a[1 2; 3]\n        2       b[1; 2 3]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.bondenv_fu-Tuple{Int64, Int64, TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}, TensorKit.AbstractTensor{T, S, 4} where {T<:Number, S<:TensorKit.ElementarySpace}, CTMRGEnv}","page":"Library","title":"PEPSKit.bondenv_fu","text":"Construct the environment (norm) tensor\n\n    C1---T1---------T1---C2   r-1\n    |    ‖          ‖    |\n    T4===XX==     ==YY===T2    r\n    |    ‖          ‖    |\n    C4---T3---------T3---C3   r+1\n    c-1  c         c+1  c+2\n\nwhere XX = X' X and YY = Y' Y (stacked together).\n\nAxis order: [DX1 DY1; DX0 DY0], as in\n\n    ┌---------------------┐\n    | ┌----┐              |\n    └-|    |---DX0  DY0---┘\n      |benv|\n    ┌-|    |---DX1  DY1---┐\n    | └----┘              |\n    └---------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.bp_iteration-Tuple{InfiniteSquareNetwork, BPEnv, BeliefPropagation}","page":"Library","title":"PEPSKit.bp_iteration","text":"One iteration to update the BP environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.c4v_enlarge-Tuple{Any, Any, C4vEighProjector}","page":"Library","title":"PEPSKit.c4v_enlarge","text":"c4v_enlarge(network, env, ::C4vEighProjector)\n\nCompute the normalized and Hermitian-symmetrized C₄ᵥ enlarged corner.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.c4v_enlarge-Tuple{Any, C4vQRProjector}","page":"Library","title":"PEPSKit.c4v_enlarge","text":"c4v_enlarge(env, ::C4vQRProjector)\n\nCompute the normalized column-enlarged northeast corner for C₄ᵥ QR-CTMRG.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.c4v_projector!-Tuple{Any, C4vEighProjector}","page":"Library","title":"PEPSKit.c4v_projector!","text":"c4v_projector!(enlarged_corner, alg::C4vEighProjector)\n\nCompute the C₄ᵥ projector from eigh decomposing the Hermitian enlarged_corner. Also return the normalized eigenvalues as the new corner tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.c4v_projector!-Tuple{Any, C4vQRProjector}","page":"Library","title":"PEPSKit.c4v_projector!","text":"c4v_projector!(enlarged_corner, alg::C4vQRProjector)\n\nCompute the C₄ᵥ projector by decomposing the column-enlarged corner with left_orth.\n\n                   R--←--\n                   ↓\n    C-←-E-←-  =  [~Q~]    \n    ↓   |        ↓   |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_convergence-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.calc_convergence","text":"calc_convergence(env, CS_old, TS_old)\ncalc_convergence(env_new, env_old)\n\nGiven a new environment env, compute the maximal singular value distance. This determined either from the previous corner and edge singular values CS_old and TS_old, or alternatively, directly from the old environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_elementwise_convergence-Union{Tuple{C′}, Tuple{C}, Tuple{CTMRGEnv{C}, CTMRGEnv{C′}}} where {C, C′}","page":"Library","title":"PEPSKit.calc_elementwise_convergence","text":"calc_elementwise_convergence(envfinal, envfix; atol=1e-6)\n\nCheck if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below atol and return the maximal difference.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.check_input-Tuple{typeof(fixedpoint), Any, Any, PEPSOptimize}","page":"Library","title":"PEPSKit.check_input","text":"check_input(::typeof(fixedpoint), peps₀, env₀, alg::PEPSOptimize{<:SimultaneousCTMRG})\n\nCheck compatibility of an initial PEPS and environment with a specified PEPS optimization algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.check_input-Tuple{typeof(leading_boundary), Any, Any, PEPSKit.CTMRGAlgorithm}","page":"Library","title":"PEPSKit.check_input","text":"check_input(::typeof(leading_boundary), network, env, alg::CTMRGAlgorithm)\n\nCheck compatibility of a given network and environment with a specified CTMRG algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.checklattice-Tuple","page":"Library","title":"PEPSKit.checklattice","text":"checklattice(Bool, args...)\nchecklattice(args...)\n\nHelper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.column_enlarge_northwest_corner-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, N, 1}}} where {T, S, N}","page":"Library","title":"PEPSKit.column_enlarge_northwest_corner","text":"column_enlarge_northwest_corner(C_northwest, edge)\n\n\nContract the half-enlarged northwest corner of the CTMRG environment.\n\n    C₁-←-E₁-←-\n    ↓    |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.compute_projector-Tuple{Any, Any, HalfInfiniteProjector}","page":"Library","title":"PEPSKit.compute_projector","text":"compute_projector(enlarged_corners, coordinate, alg::ProjectorAlgorithm)\n\nDetermine left and right projectors at the bond given determined by the enlarged corners and the given coordinate using the specified alg.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_norm-Union{Tuple{N}, Tuple{NTuple{N, CartesianIndex{2}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N","page":"Library","title":"PEPSKit.contract_local_norm","text":"contract_local_norm(inds, ket, bra, env)\n\n\nContract a local norm of the PEPS peps around indices inds.\n\nThis works analogously to contract_local_operator by generating the contraction on a rectangular patch based on inds but replacing the operator with an identity such that the PEPS norm is computed. (Note that this is not the physical norm of the state.)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_operator-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{T, S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {T, S, N}","page":"Library","title":"PEPSKit.contract_local_operator","text":"contract_local_operator(inds, O, ket, bra, env)\n\n\nContract a local operator O on the PEPS peps at the indices inds using the environment env.\n\nThis works by generating the appropriate contraction on a rectangular patch with its corners specified by inds. The peps is contracted with O from above and below, and the PEPS-operator sandwich is surrounded with the appropriate environment tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_tensor-Tuple{Tuple{Int64, Int64, Int64}, TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace, InfiniteSquareNetwork{<:Tuple{T, T, Vararg{P, N}} where {N, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), P<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}}, CTMRGEnv}","page":"Library","title":"PEPSKit.contract_local_tensor","text":"contract_local_tensor(inds, O::PEPOTensor, network, env)\n\nContract a local tensor O inserted into the PEPO of a given network at position inds, using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_local_tensor-Union{Tuple{C}, Tuple{Tuple{Int64, Int64}, TensorKit.AbstractTensorMap{<:Any, S, 2, 2} where S<:TensorKit.ElementarySpace, CTMRGEnv{C, <:TensorKit.AbstractTensorMap{T, S, 2, 1} where {T, S}}}} where C","page":"Library","title":"PEPSKit.contract_local_tensor","text":"contract_local_tensor(inds, O::PFTensor, env)\n\nContract a local tensor O inserted into a partition function pf at position inds, using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_projectors-NTuple{5, Any}","page":"Library","title":"PEPSKit.contract_projectors","text":"contract_projectors(U, S, V, Q, Q_next)\n\n\nCompute projectors based on a SVD of Q * Q_next, where the inverse square root isqS of the singular values is computed.\n\nLeft projector:\n\n    -- |~~~~~~| -- |~~|\n       |Q_next|    |V'| -- isqS --\n    == |~~~~~~| == |~~|\n\nRight projector:\n\n               |~~| -- |~~~| --\n    -- isqS -- |U'|    | Q |\n               |~~| == |~~~| ==\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.cost_function-Tuple{InfinitePEPS, CTMRGEnv, LocalOperator}","page":"Library","title":"PEPSKit.cost_function","text":"cost_function(peps::InfinitePEPS, env::CTMRGEnv, O::LocalOperator)\n\nReal part of expectation value of O. Prints a warning if the expectation value yields a finite imaginary part (up to a tolerance).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.cost_function_als-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.cost_function_als","text":"cost_function_als(benv, a1b1, a2b2)\n\n\nCalculate the cost function\n\n    f(a,b)  = ‖ |a1,b1⟩ - |a2,b2⟩ ‖^2\n    = ⟨a1,b1|a1,b1⟩ - 2 Re⟨a1,b1|a2,b2⟩ + ⟨a2,b2|a2,b2⟩\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_iteration-Tuple{Any, Any, PEPSKit.CTMRGAlgorithm}","page":"Library","title":"PEPSKit.ctmrg_iteration","text":"ctmrg_iteration(network, env, alg::CTMRGAlgorithm) -> env′, info\n\nPerform a single CTMRG iteration in which all directions are being grown and renormalized.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_leftmove-Tuple{Int64, Any, CTMRGEnv, SequentialCTMRG}","page":"Library","title":"PEPSKit.ctmrg_leftmove","text":"ctmrg_leftmove(col::Int, network, env::CTMRGEnv, alg::SequentialCTMRG)\n\nPerform sequential CTMRG left move on the col-th column.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.decomposition_algorithm-Tuple{PEPSKit.ProjectorAlgorithm}","page":"Library","title":"PEPSKit.decomposition_algorithm","text":"decomposition_algorithm(alg::ProjectorAlgorithm)\ndecomposition_algorithm(alg::ProjectorAlgorithm, (dir, r, c))\n\nReturn the tensor decomposition algorithm of the alg projector algorithm. Additionally, the multi-index (dir, r, c) can be supplied which will return the decomposition performed at that index, e.g. when using FixedEig or FixedSVD.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.dtmap-Tuple","page":"Library","title":"PEPSKit.dtmap","text":"dtmap(args...; kwargs...)\n\nDifferentiable wrapper around [OhMyThreads.tmap].\n\nAll calls of dtmap inside of PEPSKit use the threading scheduler stored inside Defaults.scheduler which can be modified using set_scheduler!.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.eachcoordinate","page":"Library","title":"PEPSKit.eachcoordinate","text":"eachcoordinate(x, [dirs=1:4])\n\nEnumerate all (dir, row, col) pairs.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.edge_transfer_left-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{<:Any, S, N₂, 1}, TensorKit.AbstractTensorMap{<:Any, S, N₂, 1}}} where {S, N₁, N₂}","page":"Library","title":"PEPSKit.edge_transfer_left","text":"edge_transfer_left(v, Et, Eb)\n\nApply an edge transfer matrix to the left.\n\n ┌─Et─\n-v │\n └─qƎ─\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.edge_transfer_left-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, 3, 1}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), TensorKit.AbstractTensorMap{<:Any, S, 3, 1}, TensorKit.AbstractTensorMap{<:Any, S, 3, 1}}} where S","page":"Library","title":"PEPSKit.edge_transfer_left","text":"edge_transfer_left(v, O, Et, Eb)\n\nApply an edge transfer matrix to the left.\n\n ┌──Et─\n │  │\n v──O──\n │  │\n └──qƎ─\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.edge_transfer_left-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, 4, 1}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), TensorKit.AbstractTensorMap{<:Any, S, 3, 1}, TensorKit.AbstractTensorMap{<:Any, S, 3, 1}}} where S","page":"Library","title":"PEPSKit.edge_transfer_left","text":"edge_transfer_left(v, O, Et, Eb)\n\nApply an edge transfer matrix to the left on an excited vector.\n\n ┌──Et─\n │  │\n-v──O──\n │  │\n └──qƎ─\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.edge_transfer_right-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{<:Any, S, N₂, 1}, TensorKit.AbstractTensorMap{<:Any, S, N₂, 1}}} where {S, N₁, N₂}","page":"Library","title":"PEPSKit.edge_transfer_right","text":"edge_transfer_right(v, Et, Eb)\n\nApply an edge transfer matrix to the right.\n\n─Et─┐\n │  v-\n─qƎ─┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.edge_transfer_right-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, 3, 1}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), TensorKit.AbstractTensorMap{<:Any, S, 3, 1}, TensorKit.AbstractTensorMap{<:Any, S, 3, 1}}} where S","page":"Library","title":"PEPSKit.edge_transfer_right","text":"transfer_right(v, Et, Eb)\n\nApply an edge transfer matrix to the right.\n\n──Et─┐\n  │  │\n──O──v\n  │  │\n──qƎ─┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.edge_transfer_spectrum-Union{Tuple{E}, Tuple{Vector{E}, Vector{E}}} where E<:(TensorKit.AbstractTensorMap{T, S, N, 1} where {T, S, N})","page":"Library","title":"PEPSKit.edge_transfer_spectrum","text":"edge_transfer_spectrum(top::Vector{E}, bot::Vector{E}; tol=Defaults.tol, num_vals=20,\n                       sector=one(sectortype(E))) where {E<:CTMRGEdgeTensor}\n\nCalculate the partial spectrum of the left edge transfer matrix corresponding to the given top vector of edges and a bot vector of edge. The sector keyword argument can be used to specify a non-trivial total charge for the transfer matrix eigenvectors. Specifically, an auxiliary space ℂ[typeof(sector)](sector => 1)' will be added to the domain of each eigenvector. The tol and num_vals keyword arguments are passed to KrylovKit.eigolve.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_northeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_northeast_corner","text":"enlarge_northeast_corner(E_north, C_northeast, E_east, A)\n\n\nContract the enlarged northeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n    out-- E_north -- C_northeast\n             |             |\n       --    A    --    E_east\n             |             |\n                           in\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_northwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_northwest_corner","text":"enlarge_northwest_corner(E_west, C_northwest, E_north, A)\n\n\nContract the enlarged northwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n    C_northwest -- E_north --in\n         |            |\n      E_west    --    A    --\n         |            |\n        out\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_southeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_southeast_corner","text":"enlarge_southeast_corner(E_east, C_southeast, E_south, A)\n\n\nContract the enlarged southeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n                         out\n            |             |\n      --    A    --    E_east\n            |             |\n    in-- E_south -- C_southeast\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_southwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.enlarge_southwest_corner","text":"enlarge_southwest_corner(E_south, C_southwest, E_west, A)\n\n\nContract the enlarged southwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.\n\n         in\n          |           |\n       E_west   --    A    --\n          |           |\n    C_southwest -- E_south --out\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fidelity","text":"fidelity(benv, b1, b2)\n\n\nGiven the bond environment benv, calculate the fidelity between two states specified by the bond matrices b1, b2\n\n    F(b1, b2) = (⟨b1|b2⟩ ⟨b2|b1⟩) / (⟨b1|b1⟩ ⟨b2|b2⟩)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fidelity","text":"fidelity(benv, a1b1, a2b2)\n\n\nCalculate the fidelity between two evolution steps\n\n        |⟨a1,b1|a2,b2⟩|^2\n    --------------------------\n    ⟨a1,b1|a1,b1⟩⟨a2,b2|a2,b2⟩\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}","page":"Library","title":"PEPSKit.fix_gauge_corner","text":"fix_gauge_corner(corner, σ_out, σ_in)\n\n\nMultiply corner tensor with incoming and outgoing gauge signs.\n\n    corner -- σ_in --in\n      |\n     σ_out\n      |\n     out\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_edge","text":"fix_gauge_east_edge(, env, signs)\n\n\nApply fix_gauge_edge to the east edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_left_vecs","text":"fix_gauge_east_left_vecs(, U, signs)\n\n\nMultiply east left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_right_vecs","text":"fix_gauge_east_right_vecs(, V, signs)\n\n\nMultiply east right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_edge-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}} where {T, S, N}","page":"Library","title":"PEPSKit.fix_gauge_edge","text":"fix_gauge_edge(edge, σ_out, σ_in)\n\n\nMultiply edge tensor with incoming and outgoing gauge signs.\n\n    out-- σ_out -- edge -- σ_in --in\n                    |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_edge","text":"fix_gauge_north_edge(, env, signs)\n\n\nApply fix_gauge_edge to the north edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_left_vecs","text":"fix_gauge_north_left_vecs(, U, signs)\n\n\nMultiply north left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_right_vecs","text":"fix_gauge_north_right_vecs(, V, signs)\n\n\nMultiply north right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northeast_corner","text":"fix_gauge_northeast_corner(, env, signs)\n\n\nApply fix_gauge_corner to the northeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northwest_corner","text":"fix_gauge_northwest_corner(, env, signs)\n\n\nApply fix_gauge_corner to the northwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_edge","text":"fix_gauge_south_edge(, env, signs)\n\n\nApply fix_gauge_edge to the south edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_left_vecs","text":"fix_gauge_south_left_vecs(, U, signs)\n\n\nMultiply south left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_right_vecs","text":"fix_gauge_south_right_vecs(, V, signs)\n\n\nMultiply south right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southeast_corner","text":"fix_gauge_southeast_corner(, env, signs)\n\n\nApply fix_gauge_corner to the southeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southwest_corner","text":"fix_gauge_southwest_corner(, env, signs)\n\n\nApply fix_gauge_corner to the southwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_edge","text":"fix_gauge_west_edge(, env, signs)\n\n\nApply fix_gauge_edge to the west edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_left_vecs","text":"fix_gauge_west_left_vecs(, U, signs)\n\n\nMultiply west left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_right_vecs","text":"fix_gauge_west_right_vecs(, V, signs)\n\n\nMultiply west right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_global_phases-Tuple{CTMRGEnv, CTMRGEnv}","page":"Library","title":"PEPSKit.fix_global_phases","text":"fix_global_phases(envfix, envprev)\n\n\nFix global multiplicative phase of the environment tensors. To that end, the dot products between all corners and all edges are computed to obtain the global phase which is then divided out.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fixedpoint-Tuple{Any, InfinitePEPS, Any}","page":"Library","title":"PEPSKit.fixedpoint","text":"fixedpoint(operator, peps₀::InfinitePEPS, env₀; kwargs...) -> peps_final, env_final, cost_final, info\n# expert version:\nfixedpoint(operator, peps₀::InfinitePEPS, env₀, alg::PEPSOptimize; finalize!=OptimKit._finalize!)\n\nFind the fixed point of operator (i.e. the ground state) starting from peps₀ according to the supplied optimization parameters. The initial environment env₀ serves as an initial guess for the first boundary contraction run. By default, a random initial environment is used.\n\nThe optimization parameters can be supplied via the keyword arguments or directly as a PEPSOptimize struct. The following keyword arguments are supported:\n\nKeyword arguments\n\nGeneral settings\n\ntol::Real=0.0001 : Overall tolerance for gradient norm convergence of the optimizer. Sets related tolerance such as the boundary and boundary-gradient tolerances to sensible defaults unless they are explictly specified.\nverbosity::Int=1 : Overall output information verbosity level, should be one of the following:\nSuppress all output\nOnly print warnings\nInitialization and convergence info\nIteration info\nDebug info including AD outputs\nreuse_env::Bool=true : If true, the current optimization step is initialized on the previous environment, otherwise a random environment is used.\nsymmetrization::Union{Nothing,SymmetrizationStyle}=nothing : Accepts nothing or a SymmetrizationStyle, in which case the PEPS and PEPS gradient are symmetrized after each optimization iteration.\n(finalize!)=OptimKit._finalize! : Inserts a finalize! function call after each optimization step by utilizing the finalize! kwarg of OptimKit.optimize. The function maps (peps, env), f, g = finalize!((peps, env), f, g, numiter).\n\nBoundary algorithm\n\nSupply boundary algorithm parameters via boundary_alg using either a NamedTuple of keyword arguments or a boundary algorithm instance directly. See leading_boundary for a description of all possible keyword arguments. By default, a CTMRG tolerance of tol=1e-4tol and is used.\n\nGradient algorithm\n\nSupply gradient algorithm parameters via gradient_alg::Union{NamedTuple,Nothing,<:GradMode} using either a NamedTuple of keyword arguments, nothing, or a GradMode struct directly. Pass nothing to fully differentiate the CTMRG run, meaning that all iterations will be taken into account, instead of differentiating the fixed point. The supported NamedTuple keyword arguments are:\n\ntol::Real=1e-2tol : Convergence tolerance for the fixed-point gradient iteration.\nmaxiter::Int=30 : Maximal number of gradient problem iterations.\nalg::Symbol=:eigsolver : Gradient algorithm variant, can be one of the following:\n:geomsum : Compute gradient directly from the geometric sum, see GeomSum\n:manualiter : Iterate gradient geometric sum manually, see ManualIter\n:linsolver : Solve fixed-point gradient linear problem using iterative solver, see LinSolver\n:eigsolver : Determine gradient via eigenvalue formulation of its Sylvester equation, see EigSolver\nverbosity::Int : Gradient output verbosity, ≤0 by default to disable too verbose printing. Should only be >0 for debug purposes.\niterscheme::Symbol=:fixed : CTMRG iteration scheme determining mode of differentiation. This can be:\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\n\nOptimizer settings\n\nSupply the optimizer algorithm via optimizer_alg::Union{NamedTuple,<:OptimKit.OptimizationAlgorithm} using either a NamedTuple of keyword arguments or a OptimKit.OptimizationAlgorithm directly. By default, OptimKit.LBFGS is used in combination with a HagerZhangLineSearch. The supported keyword arguments are:\n\nalg::Symbol=:lbfgs : Optimizer algorithm, can be one of the following:\n:gradientdescent : Gradient descent algorithm, see the OptimKit README\n:conjugategradient : Conjugate gradient algorithm, see the OptimKit README\n:lbfgs : L-BFGS algorithm, see the OptimKit README\ntol::Real=tol : Gradient norm tolerance of the optimizer.\nmaxiter::Int=100 : Maximal number of optimization steps.\nverbosity::Int=3 : Optimizer output verbosity.\nls_maxiter::Int=10 : Maximal number of linesearch iterations.\nls_maxfg::Int=20 : Maximal number of function-gradient evaluations during linesearch.\nlbfgs_memory::Int=20 : Size of limited memory representation of BFGS Hessian matrix.\n\nReturn values\n\nThe function returns the final PEPS, CTMRG environment and cost value, as well as an information NamedTuple which contains the following entries:\n\nlast_gradient : Last gradient of the cost function.\nfg_evaluations : Number of evaluations of the cost and gradient function.\ncosts : History of cost values.\ngradnorms : History of gradient norms.\ncontraction_metrics : History of boundary-algorithm-specific contraction information, e.g. truncation errors and condition numbers.\ngradnorms_unitcell : History of gradient norms for each respective unit cell entry.\ntimes : History of optimization step execution times.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fixgauge_benv-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fixgauge_benv","text":"Use QR decomposition to fix gauge of the half bond environment Z. The reduced bond tensors a, b and Z are arranged as\n\n    ┌---------------┐\n    |               |\n    └---Z---a---b---┘\n        |   ↓   ↓\n        ↓\n\nReference: \n\nPhysical Review B 90, 064425 (2014)\nPhysical Review B 92, 035142 (2015)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fpgrad","page":"Library","title":"PEPSKit.fpgrad","text":"fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)\n\nCompute the gradient of the CTMRG fixed point by solving the following equation:\n\ndx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA\n\nwhere ∂F∂x is the gradient of the cost function with respect to the PEPS tensors, ∂f∂x is the partial gradient of the CTMRG iteration with respect to the environment tensors, ∂f∂A is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and y0 is the initial guess for the fixed-point iteration. The function returns the gradient dx of the fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.full_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, NTuple{4, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}","page":"Library","title":"PEPSKit.full_infinite_environment","text":"full_infinite_environment(quadrant1, quadrant2, quadrant3, quadrant4)\nfull_infinite_environment(half1, half2)\nfull_infinite_environment(C_1, C_2, C_3, C_4, E_1, E_2, E_3, E_4, E_5, E_6, E_7, E_8, A_1, A_2, A_3, A_4)\nfull_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x, A_1, A_2, A_3, A_4)\nfull_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2, A_3, A_4)\n\nContract four quadrants (enlarged corners) to form a full-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n      |     |        |     |\n     out             |     |\n                     |     |\n     in              |     |\n      |     |        |     |\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant4|    |quadrant3|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n\nIn the same manner two halfs can be used to contract the full-infinite environment.\n\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n    |         half1          |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n      |     |        |     |\n     out             |     |\n                     |     |\n     in              |     |\n      |     |        |     |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n    |         half2          |\n    |~~~~~~~~~~~~~~~~~~~~~~~~|\n\nThe environment can also be contracted directly from all its constituent tensors.\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      |\n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n    out            |      |\n                   |      |\n    in      |      |      |\n     |      |      |      |\n    E_8 -- A_4 -- A_3 -- E_5\n     |      |      |      |\n    C_4 -- E_7 -- E_6 -- C_3\n\nAlternatively, contract the environment with a vector x acting on it\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      |\n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n    out            |      |\n                   |      |\n    [~~~~x~~~]     |      |\n     |      |      |      |\n    E_8 -- A_4 -- A_3 -- E_5\n     |      |      |      |\n    C_4 -- E_7 -- E_6 -- C_3\n\n\nor contract the adjoint environment with x, e.g. as needed for iterative solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fullenv_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}, FullEnvTruncation}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fullenv_truncate","text":"fullenv_truncate(benv::BondEnv{T,S}, b0::AbstractTensorMap{T,S,1,1}, alg::FullEnvTruncation) -> U, S, V, info\n\nPerform full environment truncation algorithm from Phys. Rev. B 98, 085155 (2018) on benv.\n\nGiven a fixed state |b0⟩ with bond matrix b0 and the corresponding positive-definite bond environment benv,  find the state |b⟩ with truncated bond matrix b = u s v† that maximizes the fidelity (not normalized by ⟨b0|b0⟩)\n\n    F(b) = ⟨b|b0⟩⟨b0|b⟩ / ⟨b|b⟩\n\n            ┌----------------------┐  ┌-----------------------┐\n            |   ┌----┐             |  |   ┌----┐              |\n            └---|    |---- b0 -----┘  └---|    |- u ← s ← v† -┘\n                |benv|                    |benv|\n            ┌---|    |-u† → s → v -┐  ┌---|    |----- b0† ----┐\n            |   └----┘             |  |   └----┘              |\n            └----------------------┘  └-----------------------┘\n        = ───────────────────────────────────────────────────────\n                        ┌-----------------------┐\n                        |   ┌----┐              |\n                        └---|    |- u ← s ← v† -┘\n                            |benv|\n                        ┌---|    |- u† → s → v -┐\n                        |   └----┘              |\n                        └-----------------------┘\n\nThe singular value spectrum s is truncated to desired dimension,  and normalized such that the maximum is 1. Note that benv is contracted to b0 using @tensor,  instead of acting on b0 as a linear map.\n\nThe algorithm iteratively optimizes the vectors l, r\n\n    --- l -←-  =  --- u ← s -←-  ,  -←- r ---  =  -←- s ← v† ---\n\nOptimization of r\n\nDefine the vector p and the positive map B as\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-←   --┘   └---|    |- u ←      ---┘\n            | p†|         =     |benv|\n        ┌---|   |-------┐   ┌---|    |----- b0† ----┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-←   --┘   └---|    |- u ←      ---┘\n            | B |         =     |benv|\n        ┌---|   |-→   --┐   ┌---|    |- u†→      ---┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\nThen (each index corresponds to a pair of fused indices)\n\n    F(r,r†) = |p† r|² / (r† B r)\n            = (r† p) (p† r) / (r† B r)\n\nwhich is maximized when\n\n    ∂F/∂r̄ * (r† B r)²\n    = p (p† r) (r† B r) - |p† r|² (B r) = 0\n\nNote that B is positive (consequently B† = B).  Then the solution for the vector r is\n\n    r = B⁻¹ p\n\nWe can verify that (using B† = B)\n\n    ∂F/∂r̄ * (r† B r)²\n    = p (p† B⁻¹ p) (p† B⁻¹ B B⁻¹ p) - |p† B⁻¹ p|² (B B⁻¹ p) \n    = 0\n\nThen the bond matrix u s v† is updated by truncated SVD:\n\n    - u ← r -    ==>    - u ← s ← v† -\n\nOptimization of l\n\nThe process is entirely similar.  Define the vector p and the positive map B as\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-  ←-o-┘   └---|    |--   ←-o- v† -┘\n            | p†|         =     |benv|\n        ┌---|   |-------┐   ┌---|    |----- b0† ----┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\n        ┌---------------┐   ┌-----------------------┐\n        |   ┌---┐       |   |   ┌----┐              |\n        └---|   |-  ←-o-┘   └---|    |--    ←-o- v†-┘\n            | B |         =     |benv|\n        ┌---|   |-  →-o-┐   ┌---|    |--    →-o- v -┐\n        |   └---┘       |   |   └----┘              |\n        └---------------┘   └-----------------------┘\n\nHere o is the parity tensor (twist) necessary for fermions.  Then (each index corresponds to a pair of fused indices)\n\n    F(l,l†) = |p† l|² / (l† B l)\n\nwhich is maximized when\n\n    l = B⁻¹ p\n\nThen the bond matrix u s v† is updated by SVD:\n\n    - l ← v† -   ==>    - u ← s ← v† -\n\nReturn values\n\nReturns the SVD result of the new bond matrix U, S, V, as well as an information NamedTuple containing the following fields:\n\nfid : Last fidelity.\nΔfid : Last fidelity difference.\nΔs : Last singular value difference.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fuse_physicalspaces-Tuple{TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.fuse_physicalspaces","text":"fuse_physicalspaces(O)\n\n\nFuse the physical indices of a PEPO tensor, obtaining a PEPS tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.gate_to_mpo3-Union{Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, Any}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.gate_to_mpo3","text":"Convert a 3-site gate to MPO form by SVD,  in which the axes are ordered as\n\n    2               3               3\n    ↓               ↓               ↓\n    g1 ←- 3    1 ←- g2 ←- 4    1 ←- g3\n    ↓               ↓               ↓\n    1               2               2\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.gauge_fix-Tuple{InfinitePEPS, BPGauge, BPEnv}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(psi::Union{InfinitePEPS, InfinitePEPO}, alg::BPGauge, env::BPEnv)\n\nFix the gauge of psi (which can be an InfinitePEPS, or an InfinitePEPO interpreted as purified state with two physical legs)  using fixed point environment env of belief propagation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.gauge_fix-Tuple{PEPSKit.CTMRGAlgorithm, Any, Any}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(alg::CTMRGAlgorithm, signs, info)\ngauge_fix(alg::ProjectorAlgorithm, signs, info)\n\nFix the free gauges of the tensor decompositions associated with alg.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.gauge_fix-Tuple{Union{InfinitePEPO, InfinitePEPS}, SUGauge}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(psi::Union{InfinitePEPS, InfinitePEPO}, alg::SUGauge)\n\nFix the gauge of psi using trivial simple update.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}, PEPSKit.ScramblingEnvGauge}} where {C, T}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(envfinal, envprev, _)\n\n\nFix the gauge of envfinal based on the previous environment envprev. This assumes that the envfinal is the result of one CTMRG iteration on envprev. Given that the CTMRG run is converged, the returned environment will be element-wise converged to envprev.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_3site_se-Tuple{Union{InfinitePEPO, InfinitePEPS}, SUWeight, Int64, Int64}","page":"Library","title":"PEPSKit.get_3site_se","text":"Obtain the 3-site cluster in the \"southeast corner\" of a square plaquette.\n\n    r-1         M3\n                |\n                ↓\n    r   M1 -←- M2\n        c      c+1\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_expham-Tuple{LocalOperator, Number}","page":"Library","title":"PEPSKit.get_expham","text":"get_expham(H::LocalOperator, dt::Number)\n\nCompute exp(-dt * op) for each term op in H, and combine them into a new LocalOperator. Each op in H must be a single TensorMap.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_gateterm-Tuple{LocalOperator, Tuple{CartesianIndex{2}, CartesianIndex{2}}}","page":"Library","title":"PEPSKit.get_gateterm","text":"get_gateterm(gate::LocalOperator, bond::NTuple{2,CartesianIndex{2}})\n\nGet the term of a 2-site gate acting on a certain bond. Input gate should only include one term for each nearest neighbor bond.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.half_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}","page":"Library","title":"PEPSKit.half_infinite_environment","text":"half_infinite_environment(quadrant1, quadrant2)\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2)\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x, A_1, A_2)\nhalf_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2)\n\nContract two quadrants (enlarged corners) to form a half-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| -- |~~~~~~~~~|\n      |     |        |     |\n     out                   in\n\nThe environment can also be contracted directly from all its constituent tensors.\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      |\n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n    out                   in\n\nAlternatively, contract the environment with a vector x acting on it\n\n    C_1 -- E_2 -- E_3 -- C_2\n     |      |      |      |\n    E_1 -- A_1 -- A_2 -- E_4\n     |      |      |      |\n    out           [~~~x~~~~]\n\nor contract the adjoint environment with x, e.g. as needed for iterative solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}","page":"Library","title":"PEPSKit.hook_pullback","text":"hook_pullback(f, args...; alg_rrule=nothing, kwargs...)\n\nWrapper function to customize the pullback of a function f. This function is equivalent to f(args...; kwargs...), but the pullback can be customized by implementing the following function:\n\n_rrule(alg_rrule, config, f, args...; kwargs...) -> NoTangent(), ∂f, ∂args...\n\nThis function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nSee also _rrule.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.initialize_mps-Tuple{Union{MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), O<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}, MPSKit.MultilineMPO{<:MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace), O<:(TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace)}}}, Any}","page":"Library","title":"PEPSKit.initialize_mps","text":"initialize_mps(\n    f=randn,\n    T=scalartype(O),\n    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,1}\n)\ninitialize_mps(\n    f=randn,\n    T=scalartype(O),\n    O::Union{MultilineTransferPEPS,MultilineTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,2}\n)\n\nInialize a boundary MPS for the transfer operator O by specifying an array of virtual spaces consistent with the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.initialize_random_c4v_env-Tuple{Any, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.initialize_random_c4v_env","text":"initialize_random_c4v_env([f=randn, T=scalartype(state)], state, Venv::ElementarySpace)\n\nInitialize a C₄ᵥ-symmetric CTMRGEnv on virtual spaces Venv with random entries created by f and scalartype T.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.initialize_singlet_c4v_env-Tuple{InfinitePEPS, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.initialize_singlet_c4v_env","text":"initialize_singlet_c4v_env([T=scalartype(state)], state::InfinitePEPS, Venv::ElementarySpace)\n\nInitialize a C₄ᵥ-symmetric CTMRGEnv with a singlet corner of dimension dim(Venv) and an identity edge from id(T, Venv ⊗ Vpeps).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.inner_prod","text":"inner_prod(benv, b1, b2)\n\n\nGiven the bond environment benv, calculate the inner product between two states specified by the bond matrices b1, b2\n\n            ┌--------------------┐\n            |   ┌----┐           |\n            └---|    |---- b2 ---┘\n    ⟨b1|b2⟩ =   |benv|\n            ┌---|    |---- b1†---┐\n            |   └----┘           |\n            └--------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T<:Number, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.inner_prod","text":"inner_prod(benv, a1b1, a2b2)\n\n\nCalculate the inner product <a1,b1|a2,b2>\n\n    ┌--------------------------------┐\n    |   ┌----┐                       |\n    └---|    |- DX0 - (a2 b2) - DY0 -┘\n        |    |        ↓    ↓\n        |benv|        da   db\n        |    |        ↓    ↓\n    ┌---|    |- DX1 - (a1 b1)†- DY1 -┐\n    |   └----┘                       |\n    └--------------------------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.is_equivalent_bond-Tuple{Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{Int64, Int64}}","page":"Library","title":"PEPSKit.is_equivalent_bond","text":"is_equivalent_bond(bond1::NTuple{2,CartesianIndex{2}}, bond2::NTuple{2,CartesianIndex{2}}, (Nrow, Ncol)::NTuple{2,Int})\n\nCheck if two 2-site bonds are related by a (periodic) lattice translation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.is_nearest_neighbour-Tuple{LocalOperator}","page":"Library","title":"PEPSKit.is_nearest_neighbour","text":"is_nearest_neighbour(H::LocalOperator)\n\nCheck if an operator H contains only nearest neighbor terms.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.j1_j2_model-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.j1_j2_model","text":"j1_j2_model([elt::Type{T}, symm::Type{S},] lattice::InfiniteSquare;\n            J1=1.0, J2=1.0, spin=1//2, sublattice=true)\n\nSquare lattice J_1text-J_2 model, defined by the Hamiltonian\n\nH = J_1 sum_langle ij rangle vecS_i cdot vecS_j\n+ J_2 sum_langlelangle ij ranglerangle vecS_i cdot vecS_j\n\nwhere vecS_i = (S_i^x S_i^y S_i^z). We denote the nearest and next-nearest neighbor terms using langle ij rangle and langlelangle ij ranglerangle, respectively. The sublattice kwarg enables a single-site unit cell ground state via a unitary sublattice rotation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.left_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.left_projector","text":"left_projector(E_1, C, E_2, V, isqS, A)\n\n\nContract the CTMRG left projector with the higher-dimensional subspace facing to the left.\n\n     C  --  E_2    -- |~~|\n     |       |        |V'| -- isqS --in\n    E_1 --   A     -- |~~|\n     |       |\n    out\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.lq_through-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{T, S, 4, 1} where T, TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.lq_through","text":"Perform LQ decomposition through a tensor\n\n             ╱            ╱\n    -←-L0-←-Q-←-  <=  -←-M-←-L1-←-\n          ╱ |          ╱ |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.nearest_neighbour_hamiltonian-Union{Tuple{T}, Tuple{S}, Tuple{Matrix{S}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {S, T}","page":"Library","title":"PEPSKit.nearest_neighbour_hamiltonian","text":"nearest_neighbour_hamiltonian(lattice::Matrix{S}, h::AbstractTensorMap{T,S,2,2}) where {S,T}\n\nCreate a nearest neighbor LocalOperator by specifying the 2-site interaction term h which acts both in horizontal and vertical direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.network_value-Tuple{InfiniteSquareNetwork, CTMRGEnv}","page":"Library","title":"PEPSKit.network_value","text":"network_value(network::InfiniteSquareNetwork, env::CTMRGEnv)\n\nReturn the value (per unit cell) of a given contractible network contracted using a given CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.norm_preserving_retract-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.norm_preserving_retract","text":"norm_preserving_retract(A, η, α)\n\n\nPerforms a norm-preserving retraction of vector A along the direction η with step size α, giving a new vector A´,\n\nA  cos ( α η  A ) A + sin ( α η  A ) A η  η\n\nand corresponding directional derivative ξ,\n\nξ = cos ( α η  A ) η - sin ( α η  A ) η A  A\n\nsuch that  A ξ  = 0 and A = A.\n\nnote: Note\nThe vectors A and η should satisfy the interface specified by VectorInterface.jl\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.norm_preserving_transport!-NTuple{5, Any}","page":"Library","title":"PEPSKit.norm_preserving_transport!","text":"norm_preserving_transport!(ξ, A, η, α, A´)\n\n\nTransports a direction ξ at A to a valid direction at A´ corresponding to the norm-preserving retraction of A along η with step size α. In particular, starting from a direction η of the form\n\nξ =  η  η ξ  η  η + Δξ\n\nwhere  Δξ A  =  Δξ η  = 0, it returns\n\nξ(α) =  η  η ξ  ( cos ( α η  A ) η  η - sin ( α η  A ) A  A ) + Δξ\n\nsuch that ξ(α) = ξ  A ξ(α)  = 0.\n\nnote: Note\nThe vectors A and η should satisfy the interface specified by VectorInterface.jl\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.peps_normalize-Tuple{InfinitePEPS}","page":"Library","title":"PEPSKit.peps_normalize","text":"peps_normalize(A::InfinitePEPS)\n\nNormalize the individual tensors in the unit cell of an InfinitePEPS such that they each have unit Euclidean norm.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.peps_retract-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.peps_retract","text":"peps_retract(x, η, α)\n\n\nPerforms a norm-preserving retraction of an infinite PEPS A = x[1] along η with step size α, giving a new PEPS A´,\n\nA  cos ( α η  A ) A + sin ( α η  A ) A η  η\n\nand corresponding directional derivative ξ,\n\nξ = cos ( α η  A ) η - sin ( α η  A ) η A  A\n\nsuch that  A ξ  = 0 and A = A.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.peps_transport!-NTuple{5, Any}","page":"Library","title":"PEPSKit.peps_transport!","text":"peps_transport!(ξ, x, η, α, x´)\n\n\nTransports a direction at A = x[1] to a valid direction at A´ = x´[1] corresponding to the norm-preserving retraction of A along η with step size α. In particular, starting from a direction η of the form\n\nξ =  η  η ξ  η  η + Δξ\n\nwhere  Δξ A  =  Δξ η  = 0, it returns\n\nξ(α) =  η  η ξ  ( cos ( α η  A ) η  η - sin( α η  A ) A  A ) + Δξ\n\nsuch that ξ(α) = ξ  A ξ(α)  = 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.positive_approx-Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2} where {T<:Number, S<:TensorKit.ElementarySpace}}","page":"Library","title":"PEPSKit.positive_approx","text":"Replace bond environment benv by its positive approximant Z† Z (returns the \"half environment\" Z)\n\n    ┌-----------------┐     ┌---------------┐\n    | ┌----┐          |     |               |\n    └-|    |-- 3  4 --┘     └-- Z -- 3  4 --┘\n      |benv|            =       ↓\n    ┌-|    |-- 1  2 --┐     ┌-- Z†-- 1  2 --┐\n    | └----┘          |     |               |\n    └-----------------┘     └---------------┘\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.product_peps-Tuple","page":"Library","title":"PEPSKit.product_peps","text":"product_peps(peps_args...; unitcell=(1, 1), noise_amp=1e-2, state_vector=nothing)\n\nInitialize a normalized random product PEPS with noise. The given arguments are passed on to the InfinitePEPS constructor.\n\nThe noise intensity can be tuned with noise_amp. The product state coefficients can be specified using the state_vector kwarg in the form of a matrix of size unitcell containing vectors that match the PEPS physical dimensions. If nothing is provided, random Gaussian coefficients are used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.pwave_superconductor-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.pwave_superconductor","text":"pwave_superconductor([T=ComplexF64,] lattice::InfiniteSquare; t=1, μ=2, Δ=1)\n\nSquare lattice p-wave superconductor model, defined by the Hamiltonian\n\n    H = -sum_langle ij rangle left( t c_i^dagger c_j +\n    Delta c_i c_j + texthc right) - mu sum_i n_i\n\nwhere t is the hopping amplitude, Delta specifies the superconducting gap, mu is the chemical potential, and n_i = c_i^dagger c_i is the fermionic number operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.qr_through-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}, TensorKit.AbstractTensorMap{T, S, 4, 1} where T}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.qr_through","text":"Perform QR decomposition through a PEPS tensor\n\n             ╱            ╱\n    -←-R0-←-M-←-  =>  ---Q-←-R1-←-\n          ╱ |          ╱ |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.random_dual!-Union{Tuple{AbstractMatrix{E}}, Tuple{E}} where E<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.random_dual!","text":"Randomly take the dual of ElementarySpaces in Vs with propability p\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.reduced_densitymatrix","page":"Library","title":"PEPSKit.reduced_densitymatrix","text":"Construct the reduced density matrix ρ of PEPS or PEPO (representing PEPS with ancilla legs) ket, bra with open indices inds using the environment env. Alternatively, construct the reduced density matrix ρ of a mixed state specified by the density matrix PEPO state with open indices inds using the environment env.\n\nThis works by generating the appropriate contraction on a rectangular patch with its corners specified by inds. The result is normalized such that tr(ρ) = 1. \n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.renormalize_corner-Union{Tuple{N}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, N, N}, TensorKit.AbstractTensorMap{<:Any, S, N, 1}, TensorKit.AbstractTensorMap{<:Any, S, 1, N}}} where {S, N}","page":"Library","title":"PEPSKit.renormalize_corner","text":"renormalize_corner(quadrant, P_left, P_right)\n\n\nApply projectors to each side of a quadrant.\n\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --in\n    |~~~~~~~~| -- |~~~~~~|\n     |     |\n    [P_right]\n        |\n       out\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_east_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_east_edge","text":"renormalize_east_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_east_edge(E_east, P_left, P_right, A::P)\n\nAbsorb a local effective tensor into the east edge using the given projectors and environment tensors.\n\n          out\n           |\n      [~P_right~]\n       |       |\n    -- A -- E_east\n       |       |\n      [~~P_left~]\n           |\n           in\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_north_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_north_edge","text":"renormalize_north_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_north_edge(E_north, P_left, P_right, A::P)\n\nAbsorb a local effective tensor A into the north edge using the given projectors and environment tensors.\n\n          |~~~~~~~| -- E_north -- |~~~~~~|\n    out-- |P_right|       |       |P_left| --in\n          |~~~~~~~| --    A    -- |~~~~~~|\n                          |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northeast_corner","text":"renormalize_northeast_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_northeast_corner(quadrant, P_left, P_right)\nrenormalize_northeast_corner(E_north, C_northeast, E_east, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged northeast corner.\n\n          |~~~~~~~| -- |~~~~~~~~|\n    out-- |P_right|    |quadrant|\n          |~~~~~~~| -- |~~~~~~~~|\n                         |    |\n                        [P_left]\n                            |\n                            in\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n          |~~~~~~~| -- E_north -- C_northeast\n    out-- |P_right|       |            |\n          |~~~~~~~| --    A    --    E_east\n                          |            |\n                        [~~~~~P_left~~~~~]\n                                 |\n                                 in\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northwest_corner","text":"renormalize_northwest_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_northwest_corner(quadrant, P_left, P_right)\nrenormalize_northwest_corner(E_west, C_northwest, E_north, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged northwest corner.\n\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --in\n    |~~~~~~~~| -- |~~~~~~|\n     |     |\n    [P_right]\n        |\n       out\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n    C_northwest -- E_north -- |~~~~~~|\n         |           |        |P_left| --in\n      E_west    --   A     -- |~~~~~~|\n         |           |\n      [~~~~~P_right~~~~]\n               |\n              out\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_northwest_corner","text":"renormalize_northwest_corner((row, col), env, projectors)\nrenormalize_northwest_corner(C_northwest, E_north, P_right)\n\nApply right projector to northwest corner and north edge.\n\n     C --- E --in\n     |     |\n    [P_right]\n        |\n       out\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_sequentially-Tuple{Int64, Any, Any, Any}","page":"Library","title":"PEPSKit.renormalize_sequentially","text":"renormalize_sequentially(col::Int, projectors, network, env)\n\nRenormalize one column of the CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_simultaneously-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_simultaneously","text":"renormalize_simultaneously(\n    enlarged_corners,\n    projectors,\n    network,\n    env\n)\n\n\nRenormalize all enlarged corners and edges simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_south_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_south_edge","text":"renormalize_south_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_south_edge(E_south, P_left, P_right, A::P)\n\nAbsorb a local effective tensor into the south edge using the given projectors and environment tensors.\n\n                        |\n         |~~~~~~| --    A    -- |~~~~~~~|\n    in-- |P_left|       |       |P_right| --out\n         |~~~~~~| -- E_south -- |~~~~~~~|\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southeast_corner","text":"renormalize_southeast_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_southeast_corner(quadrant, P_left, P_right)\nrenormalize_southeast_corner(E_east, C_southeast, E_south, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged southeast corner.\n\n                         out\n                          |\n                      [P_right]\n                        |   |\n         |~~~~~~| -- |~~~~~~~~|\n    in-- |P_left|    |quadrant|\n         |~~~~~~| -- |~~~~~~~~|\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n                             out\n                              |\n                      [~~~~P_right~~~~]\n                        |           |\n         |~~~~~~| --    A    --   E_east\n    in-- |P_left|       |           |\n         |~~~~~~| -- E_south -- C_southeast\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southwest_corner","text":"renormalize_southwest_corner((row, col), enlarged_env, P_left, P_right)\nrenormalize_southwest_corner(quadrant, P_left, P_right)\nrenormalize_southwest_corner(E_south, C_southwest, E_west, P_left, P_right, A)\n\nApply renormalize_corner to the enlarged southwest corner.\n\n         in\n         |\n     [P_left]\n      |    |\n    |~~~~~~~~| -- |~~~~~~~|\n    |quadrant|    |P_right| --out\n    |~~~~~~~~| -- |~~~~~~~|\n\nAlternatively, provide the constituent tensors and perform the complete contraction.\n\n               in\n               |\n       [~~~~~P_left~~~~~]\n         |            |\n       E_west   --    A    -- |~~~~~~~|\n         |            |       |P_right| --out\n    C_southwest -- E_south -- |~~~~~~~|\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_southwest_corner","text":"renormalize_southwest_corner((r, c), env, projectors)\nrenormalize_southwest_corner(C_southwest, E_south, P_left)\n\nApply left projector to southwest corner and south edge.\n\n        in\n        |\n    [P_left]\n     |    |\n     C -- E --out\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_west_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}","page":"Library","title":"PEPSKit.renormalize_west_edge","text":"renormalize_west_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})\nrenormalize_west_edge(E_west, P_left, P_right, A::P)\n\nAbsorb a local effective tensor into the west edge using the given projectors and environment tensors.\n\n          in\n          |\n     [~~P_left~]\n      |       |\n    E_west -- A --\n      |       |\n     [~P_right~]\n          |\n         out\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.right_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T<:(TensorKit.AbstractTensorMap{<:Any, S, 1, 4} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.right_projector","text":"right_projector(E_1, C, E_2, U, isqS, A)\n\n\nContract the CTMRG right projector with the higher-dimensional subspace facing to the right.\n\n                  |~~| --   E_2   --  C\n    out-- isqS -- |U'|      |         |\n                  |~~| --   A     -- E_1\n                            |         |\n                                      in\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.rotate_north-Tuple{Any, Any}","page":"Library","title":"PEPSKit.rotate_north","text":"rotate_north(t, dir)\n\n\nRotate the dir direction of t to face north by successive applications of rotl90.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.sdiag_pow-Tuple{TensorKit.DiagonalTensorMap, Real}","page":"Library","title":"PEPSKit.sdiag_pow","text":"sdiag_pow(s, pow::Real; tol::Real=eps(real(scalartype(s)))^(3 / 4))\n\nCompute s^pow for a diagonal matrix s.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.select_algorithm","page":"Library","title":"PEPSKit.select_algorithm","text":"select_algorithm(func_or_alg, args...; kwargs...) -> Algorithm\n\nParse arguments and keyword arguments to the algorithm struct corresponding to func_or_alg and return an algorithm instance. To that end, we use a general interface where all keyword arguments that can be algorithm themselves can be specified using\n\nalg::Algorithm : an instance of the algorithm struct or\n(; alg::Symbol, alg_kwargs...) : a NamedTuple where the algorithm is specified by a Symbol and the algorithm keyword arguments \n\nA full description of the keyword argument can be found in the respective function or algorithm struct docstrings.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.sequential_projectors-Tuple{Int64, Any, CTMRGEnv, PEPSKit.ProjectorAlgorithm}","page":"Library","title":"PEPSKit.sequential_projectors","text":"sequential_projectors(col::Int, network, env::CTMRGEnv, alg::ProjectorAlgorithm)\nsequential_projectors(coordinate::NTuple{3,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :sequential scheme either for an entire column col or for a specific coordinate (where dir=WEST is already implied in the :sequential scheme).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.simultaneous_projectors-Union{Tuple{E}, Tuple{Array{E, 3}, CTMRGEnv, PEPSKit.ProjectorAlgorithm}} where E","page":"Library","title":"PEPSKit.simultaneous_projectors","text":"simultaneous_projectors(enlarged_corners::Array{E,3}, env::CTMRGEnv, alg::ProjectorAlgorithm)\nsimultaneous_projectors(coordinate, enlarged_corners::Array{E,3}, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :simultaneous scheme either for all provided enlarged corners or on a specific coordinate.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.str-Tuple{TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit.str","text":"str(t)\n\nFermionic supertrace by using @tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.su_iter-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, SimpleUpdate, SUWeight}","page":"Library","title":"PEPSKit.su_iter","text":"One iteration of simple update\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}","page":"Library","title":"PEPSKit.symmetrize!","text":"symmetrize!(peps::InfinitePEPS, ::SymmetrizationStyle)\n\nSymmetrize a PEPS using the given SymmetrizationStyle in-place.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize_retract_and_finalize!","page":"Library","title":"PEPSKit.symmetrize_retract_and_finalize!","text":"symmetrize_retract_and_finalize!(symm::SymmetrizationStyle, [retract, finalize!])\n\nReturn the retract and finalize! function for symmetrizing the peps and grad tensors.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.trace_physicalspaces-Tuple{TensorKit.AbstractTensorMap{<:Any, S, 2, 4} where S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.trace_physicalspaces","text":"trace_physicalspaces(O)\n\n\nTrace out the physical indices of a PEPO tensor, obtaining a partition function tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.trmul-Union{Tuple{N}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{<:Any, S, N, N}, TensorKit.AbstractTensorMap{<:Any, S, N, N}}} where {S, N}","page":"Library","title":"PEPSKit.trmul","text":"trmul(H, ρ)\n\nCompute tr(H * ρ) without forming H * ρ.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.twistdual!-Tuple{TensorKit.AbstractTensorMap, Int64}","page":"Library","title":"PEPSKit.twistdual!","text":"twistdual(t::AbstractTensorMap, i)\ntwistdual!(t::AbstractTensorMap, i)\n\nTwist the i-th leg of a tensor t if it represents a dual space.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.update_message-Tuple{CartesianIndex{3}, InfiniteSquareNetwork, BPEnv}","page":"Library","title":"PEPSKit.update_message","text":"Update the BP message in env.messages[I].\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.@autoopt-Tuple{Any}","page":"Library","title":"PEPSKit.@autoopt","text":"autoopt(ex)\n\nPreprocessor macro for @tensor which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with d, D, or χ are automatically inserted with the corresponding costs.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@fwdthreads-Tuple{Any}","page":"Library","title":"PEPSKit.@fwdthreads","text":"@fwdthreads(ex)\n\nApply Threads.@threads only in the forward pass of the program.\n\nIt works by wrapping the for-loop expression in an if statement where in the forward pass the loop in computed in parallel using Threads.@threads, whereas in the backwards pass the Threads.@threads is omitted in order to make the expression differentiable.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@showtypeofgrad-Tuple{Any}","page":"Library","title":"PEPSKit.@showtypeofgrad","text":"@showtypeofgrad(x)\n\nMacro utility to show to type of the gradient that is about to accumulate for x.\n\nSee also Zygote.@showgrad.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.Defaults","page":"Library","title":"PEPSKit.Defaults","text":"module Defaults\n\nModule containing default algorithm parameter values and arguments.\n\nCTMRG\n\nctmrg_tol=1.0e-8 : Tolerance checking singular value and norm convergence.\nctmrg_maxiter=100 : Maximal number of CTMRG iterations per run.\nctmrg_miniter=4 : Minimal number of CTMRG carried out.\nctmrg_alg=:simultaneous : Default CTMRG algorithm variant.\n:simultaneous : Simultaneous expansion and renormalization of all sides.\n:sequential : Sequential application of left moves and rotations.\nctmrg_verbosity=2 : CTMRG output information verbosity\n\nSVD forward & reverse\n\ntrunc=:fixedspace : Truncation scheme for SVDs and other decompositions.\n:fixedspace : Keep virtual spaces fixed during projection\n:notrunc : No singular values are truncated and the performed SVDs are exact\n:truncerror : Additionally supply error threshold η; truncate to the maximal virtual dimension of η\n:truncrank : Additionally supply truncation dimension η; truncate such that the 2-norm of the truncated values is smaller than η\n:truncspace : Additionally supply truncation space η; truncate according to the supplied vector space \n:trunctol : Additionally supply singular value cutoff η; truncate such that every retained singular value is larger than η\nrrule_degeneracy_atol=1.0e-13 : Broadening amplitude which smoothens the divergent term in the retained contributions of an SVD or eigh pullback, in case of (pseudo) degenerate singular values\nsvd_fwd_alg=:sdd : SVD algorithm that is used in the forward pass.\n:sdd : MatrixAlgebraKit's LAPACK_DivideAndConquer\n:svd : MatrixAlgebraKit's LAPACK_QRIteration\n:iterative : Iterative SVD only computing the specifed number of singular values and vectors, see IterSVD\nsvd_rrule_tol=1.0e-8 : Accuracy of SVD reverse-rule.\nsvd_rrule_min_krylovdim=48 : Minimal Krylov dimension of the reverse-rule algorithm (if it is a Krylov algorithm).\nsvd_rrule_verbosity=-1 : SVD gradient output verbosity.\nsvd_rrule_alg=:full : Reverse-rule algorithm for the SVD gradient.\n:full : Uses a modified version of MatrixAlgebraKit's reverse-rule for svd_compact which doesn't solve any linear problem and instead requires access to the full SVD, see PEPSKit.FullSVDPullback.\n:trunc : MatrixAlgebraKit's svd_trunc_pullback! solving a Sylvester equation on the truncated subspace and therefore only requires access to the truncated SVD.\n:gmres : GMRES iterative linear solver, see the KrylovKit docs for details\n:bicgstab : BiCGStab iterative linear solver, see the KrylovKit docs for details\n:arnoldi : Arnoldi Krylov algorithm, see the KrylovKit docs for details\n\neigh forward & reverse\n\neigh_fwd_alg=:qriteration : eigh algorithm that is used in the forward pass.\n:qriteration : MatrixAlgebraKit's LAPACK_QRIteration.\n:bisection : MatrixAlgebraKit's LAPACK_Bisection.\n:divideandconquer : MatrixAlgebraKit's LAPACK_DivideAndConquer.\n:multiple : MatrixAlgebraKit's LAPACK_MultipleRelativelyRobustRepresentations. \n:lanczos : Lanczos algorithm, see KrylovKit.Lanczos for details.\n:blocklanczos : Block Lanczos algorithm, see KrylovKit.BlockLanczos for details.\neigh_rrule_alg=:full : Reverse-rule algorithm for the eigh gradient.\n:full : Full pullback algorithm for eigendecompositions, see PEPSKit.FullEighPullback.\n:trunc : Truncated reverse-mode algorithm for eigendecompositions, see PEPSKit.TruncEighPullback.\neigh_rrule_verbosity=0 : eigh gradient output verbosity.\n\nProjectors\n\nprojector_alg=:halfinfinite : Default variant of the CTMRG projector algorithm.\n:halfinfinite : Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.\n:fullinfinite : Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.\nprojector_verbosity=0 : Projector output information verbosity.\n\nFixed-point gradient\n\ngradient_tol=1.0e-6 : Convergence tolerance for the fixed-point gradient iteration.\ngradient_maxiter=30 : Maximal number of iterations for computing the CTMRG fixed-point gradient.\ngradient_verbosity=-1 : Gradient output information verbosity.\ngradient_linsolver=:bicgstab : Default linear solver for the LinSolver gradient algorithm.\n:gmres : GMRES iterative linear solver, see KrylovKit.GMRES for details\n:bicgstab : BiCGStab iterative linear solver, see KrylovKit.BiCGStab for details\ngradient_eigsolver=:arnoldi : Default eigensolver for the EigSolver gradient algorithm.\n:arnoldi : Arnoldi Krylov algorithm, see KrylovKit.Arnoldi for details\ngradient_eigsolver_eager=true : Enables EigSolver algorithm to finish before the full Krylov dimension is reached.\ngradient_iterscheme=:fixed : Scheme for differentiating one CTMRG iteration.\n:fixed : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges\n:diffgauge : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well\ngradient_alg=:eigsolver : Algorithm variant for computing the gradient fixed-point.\n\nOptimization\n\nreuse_env=true : If true, the current optimization step is initialized on the previous environment, otherwise a random environment is used.\noptimizer_tol=0.0001 : Gradient norm tolerance of the optimizer.\noptimizer_maxiter=100 : Maximal number of optimization steps.\noptimizer_verbosity=3 : Optimizer output information verbosity.\noptimizer_alg=:lbfgs : Default OptimKit.OptimizerAlgorithm for PEPS optimization.\n:gradientdescent : Gradient descent algorithm, see the OptimKit README\n:conjugategradient : Conjugate gradient algorithm, see the OptimKit README\n:lbfgs : L-BFGS algorithm, see the OptimKit README\nls_maxiter=10 : Maximum number of iterations for the line search in each step of the optimization.\nls_maxfg=20 : Maximum number of function evaluations for the line search in each step of the optimization.\nlbfgs_memory=20 : Size of limited memory representation of BFGS Hessian matrix.\n\nOhMyThreads scheduler\n\nscheduler=Ref{Scheduler}(...) : Multithreading scheduler which can be accessed via set_scheduler!.\n\n\n\n\n\n","category":"module"},{"location":"lib/lib/#PEPSKit.Defaults.set_scheduler!","page":"Library","title":"PEPSKit.Defaults.set_scheduler!","text":"set_scheduler!([scheduler]; kwargs...)\n\nSet OhMyThreads multithreading scheduler parameters.\n\nThe function either accepts a scheduler as an OhMyThreads.Scheduler or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via\n\nset_scheduler!(StaticScheduler(; ntasks=4, chunking=true))\n\nor equivalently with \n\nset_scheduler!(:static; ntasks=4, chunking=true)\n\nFor a detailed description of all schedulers and their keyword arguments consult the OhMyThreads documentation.\n\nIf no scheduler is passed and only kwargs are provided, the DynamicScheduler constructor is used with the provided kwargs.\n\nTo reset the scheduler to its default value, one calls set_scheduler! without passing arguments which then uses the default DynamicScheduler(). If the number of used threads is just one it falls back to SerialScheduler().\n\n\n\n\n\n","category":"function"},{"location":"examples/fermi_hubbard/","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/fermi_hubbard/#Fermi-Hubbard-model-with-f\\mathbb{Z}_2-\\boxtimes-U(1)-symmetry,-at-large-U-and-half-filling","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","text":"In this example, we will demonstrate how to handle fermionic PEPS tensors and how to optimize them. To that end, we consider the two-dimensional Hubbard model\n\nH = -t sum_langle ij rangle sum_sigma left( c_isigma^+ c_jsigma^- -\nc_isigma^- c_jsigma^+ right) + U sum_i n_iuparrown_idownarrow - mu sum_i n_i\n\nwhere sigma in uparrowdownarrow and n_isigma = c_isigma^+ c_isigma^- is the fermionic number operator. As in previous examples, using fermionic degrees of freedom is a matter of creating tensors with the right symmetry sectors - the rest of the simulation workflow remains the same.\n\nFirst though, we make the example deterministic by seeding the RNG, and we make our imports:\n\nusing Random\nusing TensorKit, PEPSKit\nusing MPSKit: add_physical_charge\nRandom.seed!(2928528937);","category":"section"},{"location":"examples/fermi_hubbard/#Defining-the-fermionic-Hamiltonian","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Defining the fermionic Hamiltonian","text":"Let us start by fixing the parameters of the Hubbard model. We're going to use a hopping of t=1 and a large U=8 on a 2 times 2 unit cell:\n\nt = 1.0\nU = 8.0\nlattice = InfiniteSquare(2, 2);\n\nIn order to create fermionic tensors, one needs to define symmetry sectors using TensorKit's FermionParity. Not only do we want use fermion parity but we also want our particles to exploit the global U(1) symmetry. The combined product sector can be obtained using the Deligne product, called through ⊠ which is obtained by typing \\boxtimes+TAB. We will not impose any extra spin symmetry, so we have:\n\nfermion = fℤ₂\nparticle_symmetry = U1Irrep\nspin_symmetry = Trivial\nS = fermion ⊠ particle_symmetry\n\nTensorKitSectors.ProductSector{Tuple{TensorKitSectors.FermionParity, TensorKitSectors.U1Irrep}}\n\nThe next step is defining graded virtual PEPS and environment spaces using S. Here we also use the symmetry sector to impose half-filling. That is all we need to define the Hubbard Hamiltonian:\n\nD, χ = 1, 1\nV_peps = Vect[S]((0, 0) => 2 * D, (1, 1) => D, (1, -1) => D)\nV_env = Vect[S](\n    (0, 0) => 4 * χ, (1, -1) => 2 * χ, (1, 1) => 2 * χ, (0, 2) => χ, (0, -2) => χ\n)\nS_aux = S((1, 1))\nH₀ = hubbard_model(ComplexF64, particle_symmetry, spin_symmetry, lattice; t, U)\nH = add_physical_charge(H₀, fill(S_aux, size(H₀.lattice)...));","category":"section"},{"location":"examples/fermi_hubbard/#Finding-the-ground-state","page":"Fermi-Hubbard model with fmathbbZ_2 boxtimes U(1) symmetry, at large U and half-filling","title":"Finding the ground state","text":"Again, the procedure of ground state optimization is very similar to before. First, we define all algorithmic parameters:\n\nboundary_alg = (; tol = 1.0e-8, alg = :simultaneous, trunc = (; alg = :fixedspace))\ngradient_alg = (; tol = 1.0e-6, alg = :eigsolver, maxiter = 10, iterscheme = :diffgauge)\noptimizer_alg = (; tol = 1.0e-4, alg = :lbfgs, maxiter = 80, ls_maxiter = 3, ls_maxfg = 3)\n\n(tol = 0.0001, alg = :lbfgs, maxiter = 80, ls_maxiter = 3, ls_maxfg = 3)\n\nSecond, we initialize a PEPS state and environment (which we converge) constructed from symmetric physical and virtual spaces:\n\nphysical_spaces = physicalspace(H)\nvirtual_spaces = fill(V_peps, size(lattice)...)\npeps₀ = InfinitePEPS(randn, ComplexF64, physical_spaces, virtual_spaces)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, V_env), peps₀; boundary_alg...);\n\n[ Info: CTMRG init:\tobj = +5.484842275412e+04 +4.469243203539e+04im\terr = 1.0000e+00\n[ Info: CTMRG conv 26:\tobj = +8.371681846538e+04 -3.790437403950e-07im\terr = 7.4963849845e-09\ttime = 15.96 sec\n\n\nAnd third, we start the ground state search (this does take quite long):\n\npeps, env, E, info = fixedpoint(\n    H, peps₀, env₀; boundary_alg, gradient_alg, optimizer_alg, verbosity = 3\n)\n@show E;\n\n[ Info: LBFGS: initializing with f = 6.680719803101e+00, ‖∇f‖ = 9.5851e+00\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -1.49e-01, ϕ - ϕ₀ = -2.88e+00\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/linesearches.jl:148\n[ Info: LBFGS: iter    1, Δt  1.53 m: f = 3.801336895973e+00, ‖∇f‖ = 2.3457e+01, α = 2.50e+01, m = 0, nfg = 4\n┌ Warning: Linesearch not converged after 1 iterations and 4 function evaluations:\n│ α = 2.50e+01, dϕ = -5.73e-03, ϕ - ϕ₀ = -3.81e+00\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/linesearches.jl:148\n[ Info: LBFGS: iter    2, Δt  1.37 m: f = -9.717028383144e-03, ‖∇f‖ = 3.2049e+00, α = 2.50e+01, m = 0, nfg = 4\n[ Info: LBFGS: iter    3, Δt 17.57 s: f = -1.151937236622e-01, ‖∇f‖ = 2.7846e+00, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    4, Δt 17.11 s: f = -6.164097155293e-01, ‖∇f‖ = 2.3680e+00, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    5, Δt 15.95 s: f = -8.177983978529e-01, ‖∇f‖ = 1.9112e+00, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    6, Δt 15.19 s: f = -9.902797572194e-01, ‖∇f‖ = 2.3790e+00, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    7, Δt 14.17 s: f = -1.142781184740e+00, ‖∇f‖ = 1.5680e+00, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    8, Δt 13.65 s: f = -1.238252408083e+00, ‖∇f‖ = 3.5020e+00, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    9, Δt 12.48 s: f = -1.438152725373e+00, ‖∇f‖ = 1.3366e+00, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter   10, Δt 13.47 s: f = -1.523106558123e+00, ‖∇f‖ = 1.3495e+00, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   11, Δt 26.36 s: f = -1.619309116769e+00, ‖∇f‖ = 1.1948e+00, α = 1.72e-01, m = 9, nfg = 2\n[ Info: LBFGS: iter   12, Δt 26.04 s: f = -1.681436583910e+00, ‖∇f‖ = 9.4842e-01, α = 2.37e-01, m = 10, nfg = 2\n[ Info: LBFGS: iter   13, Δt 12.48 s: f = -1.720664454158e+00, ‖∇f‖ = 1.4227e+00, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   14, Δt 12.26 s: f = -1.770786360300e+00, ‖∇f‖ = 6.2727e-01, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   15, Δt 13.32 s: f = -1.807472248475e+00, ‖∇f‖ = 5.1285e-01, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   16, Δt 12.57 s: f = -1.859749170859e+00, ‖∇f‖ = 7.1361e-01, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   17, Δt 13.31 s: f = -1.893132064727e+00, ‖∇f‖ = 6.7317e-01, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   18, Δt 12.54 s: f = -1.923092873621e+00, ‖∇f‖ = 5.5354e-01, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   19, Δt 12.31 s: f = -1.948135800861e+00, ‖∇f‖ = 4.7674e-01, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   20, Δt 13.62 s: f = -1.969521619354e+00, ‖∇f‖ = 4.1602e-01, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   21, Δt 13.66 s: f = -1.982569428626e+00, ‖∇f‖ = 4.5188e-01, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   22, Δt 12.60 s: f = -1.994023085799e+00, ‖∇f‖ = 3.1544e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, Δt 13.62 s: f = -2.002841834328e+00, ‖∇f‖ = 3.0502e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, Δt 12.82 s: f = -2.014066311349e+00, ‖∇f‖ = 3.3498e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, Δt 12.94 s: f = -2.022003037531e+00, ‖∇f‖ = 4.3896e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, Δt 13.76 s: f = -2.030108714915e+00, ‖∇f‖ = 2.0527e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, Δt 12.75 s: f = -2.035064144013e+00, ‖∇f‖ = 1.6295e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, Δt 15.33 s: f = -2.038644461742e+00, ‖∇f‖ = 1.6908e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, Δt 12.77 s: f = -2.041287673888e+00, ‖∇f‖ = 2.4233e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, Δt 13.59 s: f = -2.044963019661e+00, ‖∇f‖ = 1.2134e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, Δt 12.74 s: f = -2.046709219209e+00, ‖∇f‖ = 9.5293e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, Δt 13.57 s: f = -2.048704716271e+00, ‖∇f‖ = 1.0554e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, Δt 12.57 s: f = -2.049753790375e+00, ‖∇f‖ = 1.7672e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, Δt 13.56 s: f = -2.051012658206e+00, ‖∇f‖ = 6.4429e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, Δt 12.58 s: f = -2.051487366864e+00, ‖∇f‖ = 4.8991e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, Δt 13.58 s: f = -2.051906996297e+00, ‖∇f‖ = 6.2050e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, Δt 12.63 s: f = -2.052351425024e+00, ‖∇f‖ = 9.2730e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, Δt 13.59 s: f = -2.052848309962e+00, ‖∇f‖ = 4.8571e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, Δt 12.59 s: f = -2.053135862188e+00, ‖∇f‖ = 3.5616e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, Δt 13.38 s: f = -2.053405790304e+00, ‖∇f‖ = 4.2302e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, Δt 12.68 s: f = -2.053600752187e+00, ‖∇f‖ = 5.7965e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, Δt 13.39 s: f = -2.053812277599e+00, ‖∇f‖ = 3.2230e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, Δt 12.45 s: f = -2.054009905439e+00, ‖∇f‖ = 3.1640e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, Δt 13.44 s: f = -2.054189832249e+00, ‖∇f‖ = 4.1575e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, Δt 12.65 s: f = -2.054332729403e+00, ‖∇f‖ = 6.9193e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   46, Δt 13.44 s: f = -2.054519398221e+00, ‖∇f‖ = 2.9113e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, Δt 12.47 s: f = -2.054613030010e+00, ‖∇f‖ = 2.5330e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, Δt 13.46 s: f = -2.054720911227e+00, ‖∇f‖ = 3.1755e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, Δt 12.45 s: f = -2.054879191651e+00, ‖∇f‖ = 3.4648e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, Δt 13.68 s: f = -2.054968269730e+00, ‖∇f‖ = 8.4873e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   51, Δt 12.51 s: f = -2.055240587980e+00, ‖∇f‖ = 3.1534e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, Δt 13.35 s: f = -2.055381123762e+00, ‖∇f‖ = 2.5668e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, Δt 12.81 s: f = -2.055572801679e+00, ‖∇f‖ = 3.8027e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, Δt 12.65 s: f = -2.055872564535e+00, ‖∇f‖ = 4.6489e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, Δt 13.70 s: f = -2.056396561541e+00, ‖∇f‖ = 8.8064e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   56, Δt 13.92 s: f = -2.056856024867e+00, ‖∇f‖ = 8.3599e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, Δt 12.73 s: f = -2.057479287674e+00, ‖∇f‖ = 4.4470e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, Δt 13.75 s: f = -2.057912193743e+00, ‖∇f‖ = 5.9314e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, Δt 12.73 s: f = -2.058287076203e+00, ‖∇f‖ = 6.0139e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, Δt 12.71 s: f = -2.058998629347e+00, ‖∇f‖ = 6.2208e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, Δt 26.47 s: f = -2.059475226949e+00, ‖∇f‖ = 1.0081e-01, α = 4.82e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   62, Δt 13.76 s: f = -2.060082547535e+00, ‖∇f‖ = 6.8334e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, Δt 12.90 s: f = -2.060482651966e+00, ‖∇f‖ = 7.3285e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, Δt 13.92 s: f = -2.060740773412e+00, ‖∇f‖ = 9.5341e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   65, Δt 12.84 s: f = -2.061312903626e+00, ‖∇f‖ = 7.1673e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, Δt 13.74 s: f = -2.061710661630e+00, ‖∇f‖ = 5.4950e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, Δt 12.78 s: f = -2.062078845926e+00, ‖∇f‖ = 5.4629e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, Δt 13.77 s: f = -2.062377274080e+00, ‖∇f‖ = 7.1202e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, Δt 26.56 s: f = -2.062699328045e+00, ‖∇f‖ = 9.7057e-02, α = 5.00e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   70, Δt 12.80 s: f = -2.063167668617e+00, ‖∇f‖ = 7.1650e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, Δt 13.99 s: f = -2.063929597328e+00, ‖∇f‖ = 9.0355e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, Δt 12.76 s: f = -2.064218059719e+00, ‖∇f‖ = 8.2741e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, Δt 13.82 s: f = -2.064664984361e+00, ‖∇f‖ = 7.7230e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, Δt 12.90 s: f = -2.065239846433e+00, ‖∇f‖ = 1.0121e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, Δt 13.86 s: f = -2.066014135860e+00, ‖∇f‖ = 9.7697e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, Δt 12.98 s: f = -2.066932040862e+00, ‖∇f‖ = 1.6559e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, Δt 15.54 s: f = -2.067203376711e+00, ‖∇f‖ = 3.9032e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, Δt 13.03 s: f = -2.067518198272e+00, ‖∇f‖ = 2.6538e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, Δt 14.04 s: f = -2.069457237771e+00, ‖∇f‖ = 1.1802e-01, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 80 iterations and time 27.43 m: f = -2.071174488368e+00, ‖∇f‖ = 2.2576e-01\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/lbfgs.jl:199\nE = -2.0711744883679684\n\n\nFinally, let's compare the obtained energy against a reference energy from a QMC study by Qin et al.. With the parameters specified above, they obtain an energy of E_textref approx 4 times -05244140625 = -209765625 (the factor 4 comes from the 2 times 2 unit cell that we use here). Thus, we find:\n\nE_ref = -2.09765625\n@show (E - E_ref) / E_ref;\n\n(E - E_ref) / E_ref = -0.012624452472625886\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"man/symmetries/#Symmetric-and-fermionic-tensors","page":"Symmetric and fermionic tensors","title":"Symmetric and fermionic tensors","text":"note: Note\nThis section is still under construction.","category":"section"},{"location":"examples/heisenberg_su/","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/heisenberg_su/#Simple-update-for-the-Heisenberg-model","page":"Simple update for the Heisenberg model","title":"Simple update for the Heisenberg model","text":"In this example, we will use SimpleUpdate imaginary time evolution to treat the two-dimensional Heisenberg model once again:\n\nH = sum_langle ij rangle J_x S^x_i S^x_j + J_y S^y_i S^y_j + J_z S^z_i S^z_j\n\nIn order to simulate the antiferromagnetic order of the Hamiltonian on a single-site unit cell one typically applies a unitary sublattice rotation. Here, we will instead use a 2 times 2 unit cell and set J_x = J_y = J_z = 1.\n\nLet's get started by seeding the RNG and importing all required modules:\n\nusing Random\nimport Statistics: mean\nusing TensorKit, PEPSKit\nimport MPSKitModels: S_x, S_y, S_z, S_exchange\nRandom.seed!(0);","category":"section"},{"location":"examples/heisenberg_su/#Defining-the-Hamiltonian","page":"Simple update for the Heisenberg model","title":"Defining the Hamiltonian","text":"To construct the Heisenberg Hamiltonian as just discussed, we'll use heisenberg_XYZ and, in addition, make it real (real and imag works for LocalOperators) since we want to use PEPS and environments with real entries. We can either initialize the Hamiltonian with no internal symmetries (symm = Trivial) or use the global spin U(1) symmetry (symm = U1Irrep):\n\nsymm = Trivial ## ∈ {Trivial, U1Irrep}\nNr, Nc = 2, 2\nH = real(heisenberg_XYZ(ComplexF64, symm, InfiniteSquare(Nr, Nc); Jx = 1, Jy = 1, Jz = 1));","category":"section"},{"location":"examples/heisenberg_su/#Simple-updating","page":"Simple update for the Heisenberg model","title":"Simple updating","text":"We proceed by initializing a random PEPS that will be evolved. The weights used for simple update are initialized as identity matrices. First though, we need to define the appropriate (symmetric) spaces:\n\nDbond = 4\nχenv = 16\nif symm == Trivial\n    physical_space = ℂ^2\n    bond_space = ℂ^Dbond\n    env_space = ℂ^χenv\nelseif symm == U1Irrep\n    physical_space = ℂ[U1Irrep](1 // 2 => 1, -1 // 2 => 1)\n    bond_space = ℂ[U1Irrep](0 => Dbond ÷ 2, 1 // 2 => Dbond ÷ 4, -1 // 2 => Dbond ÷ 4)\n    env_space = ℂ[U1Irrep](0 => χenv ÷ 2, 1 // 2 => χenv ÷ 4, -1 // 2 => χenv ÷ 4)\nelse\n    error(\"not implemented\")\nend\n\npeps = InfinitePEPS(rand, Float64, physical_space, bond_space; unitcell = (Nr, Nc));\nwts = SUWeight(peps);\n\nNext, we can start the SimpleUpdate routine, successively decreasing the time intervals and singular value convergence tolerances. Note that TensorKit allows to combine SVD truncation schemes, which we use here to set a maximal bond dimension and at the same time fix a truncation error (if that can be reached by remaining below Dbond):\n\ndts = [1.0e-2, 1.0e-3, 4.0e-4]\ntols = [1.0e-6, 1.0e-8, 1.0e-8]\nnstep = 10000\ntrunc_peps = truncerror(; atol = 1.0e-10) & truncrank(Dbond)\nalg = SimpleUpdate(; trunc = trunc_peps, bipartite = true)\nfor (dt, tol) in zip(dts, tols)\n    global peps, wts, = time_evolve(peps, H, dt, nstep, alg, wts; tol, check_interval = 500)\nend\n\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1      : dt = 0.01, |Δλ| = 1.683e+00. Time = 16.029 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 500    : dt = 0.01, |Δλ| = 3.917e-06. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 597    : dt = 0.01, |Δλ| = 9.938e-07. Time = 0.003 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 18.10 s\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1      : dt = 0.001, |Δλ| = 2.135e-03. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 500    : dt = 0.001, |Δλ| = 9.631e-07. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1000   : dt = 0.001, |Δλ| = 2.415e-07. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1500   : dt = 0.001, |Δλ| = 6.291e-08. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 2000   : dt = 0.001, |Δλ| = 1.683e-08. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 2205   : dt = 0.001, |Δλ| = 9.981e-09. Time = 0.003 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 7.01 s\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1      : dt = 0.0004, |Δλ| = 1.418e-04. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 500    : dt = 0.0004, |Δλ| = 6.377e-08. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1000   : dt = 0.0004, |Δλ| = 3.544e-08. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 1500   : dt = 0.0004, |Δλ| = 2.013e-08. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 2000   : dt = 0.0004, |Δλ| = 1.157e-08. Time = 0.003 s/it\n[ Info: Space of x-weight at [1, 1] = ℂ^4\n[ Info: SU iter 2133   : dt = 0.0004, |Δλ| = 9.999e-09. Time = 0.003 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 6.74 s\n","category":"section"},{"location":"examples/heisenberg_su/#Computing-the-ground-state-energy-and-magnetizations","page":"Simple update for the Heisenberg model","title":"Computing the ground-state energy and magnetizations","text":"In order to compute observable expectation values, we need to converge a CTMRG environment on the evolved PEPS. Let's do so:\n\nnormalize!.(peps.A, Inf)\nenv₀ = CTMRGEnv(rand, Float64, peps, env_space)\ntrunc_env = truncerror(; atol = 1.0e-10) & truncrank(χenv)\nenv, = leading_boundary(\n    env₀,\n    peps;\n    alg = :sequential,\n    projector_alg = :fullinfinite,\n    tol = 1.0e-10,\n    trunc = trunc_env,\n);\n\n[ Info: CTMRG init:\tobj = +1.852686271621e-15\terr = 1.0000e+00\n[ Info: CTMRG conv 14:\tobj = +1.297823093603e+00\terr = 4.2791045109e-11\ttime = 7.73 sec\n\n\nFinally, we'll measure the energy and different magnetizations. For the magnetizations, the plan is to compute the expectation values unit cell entry-wise in different spin directions:\n\nfunction compute_mags(peps::InfinitePEPS, env::CTMRGEnv)\n    lattice = collect(space(t, 1) for t in peps.A)\n\n    # detect symmetry on physical axis\n    symm = sectortype(space(peps.A[1, 1]))\n    if symm == Trivial\n        S_ops = real.([S_x(symm), im * S_y(symm), S_z(symm)])\n    elseif symm == U1Irrep\n        S_ops = real.([S_z(symm)]) ## only Sz preserves <Sz>\n    end\n\n    return map(Iterators.product(axes(peps, 1), axes(peps, 2), S_ops)) do (r, c, S)\n        expectation_value(peps, LocalOperator(lattice, (CartesianIndex(r, c),) => S), env)\n    end\nend\n\nE = expectation_value(peps, H, env) / (Nr * Nc)\nMs = compute_mags(peps, env)\nM_norms = map(\n    rc -> norm(Ms[rc[1], rc[2], :]), Iterators.product(axes(peps, 1), axes(peps, 2))\n)\n@show E Ms M_norms;\n\nE = -0.667468537043687\nMs = [0.02728716257542508 -0.025087419805416306; -0.025087419894948337 0.027287162545045957;;; -2.3992008033046908e-11 2.6495396154846418e-11; -4.827289089293085e-11 4.5508758220180745e-11;;; 0.37596759542523767 -0.3761207830204173; -0.37612078301296753 0.37596759542925773]\nM_norms = [0.37695652541274954 0.3769565254142512; 0.3769565254127766 0.37695652541455993]\n\n\nTo assess the results, we will benchmark against data from Corboz, which use manual gradients to perform a variational optimization of the Heisenberg model. In particular, for the energy and magnetization they find E_textref = -06675 and M_textref = 03767. Looking at the relative errors, we find general agreement, although the accuracy is limited by the methodological limitations of the simple update algorithm as well as finite bond dimension effects and a lacking extrapolation:\n\nE_ref = -0.6675\nM_ref = 0.3767\n@show (E - E_ref) / abs(E_ref)\n@show (mean(M_norms) - M_ref) / M_ref;\n\n(E - E_ref) / abs(E_ref) = 4.7135515075588574e-5\n(mean(M_norms) - M_ref) / M_ref = 0.0006809806572453966\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/heisenberg/","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/heisenberg/#examples_heisenberg","page":"Optimizing the 2D Heisenberg model","title":"Optimizing the 2D Heisenberg model","text":"In this example we want to provide a basic rundown of PEPSKit's optimization workflow for PEPS. To that end, we will consider the two-dimensional Heisenberg model on a square lattice\n\nH = sum_langle ij rangle left ( J_x S^x_i S^x_j + J_y S^y_i S^y_j + J_z S^z_i S^z_j right )\n\nHere, we want to set J_x = J_y = J_z = 1 where the Heisenberg model is in the antiferromagnetic regime. Due to the bipartite sublattice structure of antiferromagnetic order one needs a PEPS ansatz with a 2 times 2 unit cell. This can be circumvented by performing a unitary sublattice rotation on all B-sites resulting in a change of parameters to (J_x J_y J_z)=(-1 1 -1). This gives us a unitarily equivalent Hamiltonian (with the same spectrum) with a ground state on a single-site unit cell.\n\nLet us get started by fixing the random seed of this example to make it deterministic:\n\nusing Random\nRandom.seed!(123456789);\n\nWe're going to need only two packages: TensorKit, since we use that for all the underlying tensor operations, and PEPSKit itself. So let us import these:\n\nusing TensorKit, PEPSKit","category":"section"},{"location":"examples/heisenberg/#Defining-the-Heisenberg-Hamiltonian","page":"Optimizing the 2D Heisenberg model","title":"Defining the Heisenberg Hamiltonian","text":"To create the sublattice rotated Heisenberg Hamiltonian on an infinite square lattice, we use the heisenberg_XYZ method from MPSKitModels which is redefined for the InfiniteSquare and reexported in PEPSKit:\n\nH = heisenberg_XYZ(InfiniteSquare(); Jx = -1, Jy = 1, Jz = -1)\n\nLocalOperator{Tuple{Pair{Tuple{CartesianIndex{2}, CartesianIndex{2}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}, Pair{Tuple{CartesianIndex{2}, CartesianIndex{2}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}}, TensorKit.ComplexSpace}(TensorKit.ComplexSpace[ℂ^2;;], ((CartesianIndex(1, 1), CartesianIndex(1, 2)) => TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}(ComplexF64[-0.25 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, -0.5 + 0.0im, 0.0 + 0.0im, 0.25 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.25 + 0.0im, 0.0 + 0.0im, -0.5 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, -0.25 + 0.0im], (ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)), (CartesianIndex(1, 1), CartesianIndex(2, 1)) => TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}(ComplexF64[-0.25 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, -0.5 + 0.0im, 0.0 + 0.0im, 0.25 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.25 + 0.0im, 0.0 + 0.0im, -0.5 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, -0.25 + 0.0im], (ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2))))","category":"section"},{"location":"examples/heisenberg/#Setting-up-the-algorithms-and-initial-guesses","page":"Optimizing the 2D Heisenberg model","title":"Setting up the algorithms and initial guesses","text":"Next, we set the simulation parameters. During optimization, the PEPS will be contracted using CTMRG and the PEPS gradient will be computed by differentiating through the CTMRG routine using AD. Since the algorithmic stack that implements this is rather elaborate, the amount of settings one can configure is also quite large. To reduce this complexity, PEPSKit defaults to (presumably) reasonable settings which also dynamically adapts to the user-specified parameters.\n\nFirst, we set the bond dimension Dbond of the virtual PEPS indices and the environment dimension χenv of the virtual corner and transfer matrix indices.\n\nDbond = 2\nχenv = 16;\n\nTo configure the CTMRG algorithm, we create a NamedTuple containing different keyword arguments. To see a description of all arguments, see the docstring of leading_boundary. Here, we want to converge the CTMRG environments up to a specific tolerance and during the CTMRG run keep all index dimensions fixed:\n\nboundary_alg = (; tol = 1.0e-10, trunc = (; alg = :fixedspace));\n\nLet us also configure the optimizer algorithm. We are going to optimize the PEPS using the L-BFGS optimizer from OptimKit. Again, we specify the convergence tolerance (for the gradient norm) as well as the maximal number of iterations and the BFGS memory size (which is used to approximate the Hessian):\n\noptimizer_alg = (; alg = :lbfgs, tol = 1.0e-4, maxiter = 100, lbfgs_memory = 16);\n\nAdditionally, during optimization, we want to reuse the previous CTMRG environment to initialize the CTMRG run of the current optimization step using the reuse_env argument. And to control the output information, we set the verbosity:\n\nreuse_env = true\nverbosity = 3;\n\nNext, we initialize a random PEPS which will be used as an initial guess for the optimization. To get a PEPS with physical dimension 2 (since we have a spin-1/2 Hamiltonian) with complex-valued random Gaussian entries, we set:\n\npeps₀ = InfinitePEPS(randn, ComplexF64, ℂ^2, ℂ^Dbond)\n\nInfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}(ComplexF64[0.07382174258286094 + 0.12820373667088403im, 0.2553716885006697 - 0.4358399804354269im, 0.7897519397510839 + 0.9113654266438473im, -1.0272416446076236 - 0.12635062198157215im, 0.16833628450178303 - 0.10088950122180829im, -1.6804460553576506 + 0.29081053879369084im, -0.9702030532300809 + 0.010730752411986726im, 0.6844811667615024 + 0.09101537356941222im, 0.5085938050744258 + 0.3786892551842583im, -0.6153328223084331 + 0.10417896606055738im, 1.0020057959636561 - 1.4704891009758718im, 0.6024931811537675 - 1.0348374874397468im, -0.027201695938305456 + 0.5778042099380925im, 1.0707115218777772 - 0.5747168579241235im, 0.09232089635078945 + 0.6143070126937361im, -0.5819741818511422 - 0.9842624134267605im, 1.2332543810053822 - 1.7783531996396438im, 1.2251189302516847 - 0.6853683793073324im, 0.8887723728085348 + 0.7809798723615474im, 1.5333834584675397 - 0.13856216581406375im, 0.1406381347783769 + 0.6630243440357264im, 0.7212056487788236 + 0.24320971945037498im, -0.7294596235434386 + 0.40327909254711103im, 0.9991347929322827 + 0.0017902515981375842im, 0.34282910982693904 - 0.4865238029567361im, -0.7437083517319159 - 0.6895708849529253im, 0.9380949844871762 - 0.6985342237892025im, -0.8981092940164176 + 0.9720706252141459im, -0.8897079923413616 - 0.7145412189457411im, -1.6099412157243007 + 0.8855200965611144im, 0.07771261045117502 - 0.6400190994609709im, 0.7357380595021633 + 0.4626916850143416im], ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)'));;])\n\nThe last thing we need before we can start the optimization is an initial CTMRG environment. Typically, a random environment which we converge on peps₀ serves as a good starting point. To contract a PEPS starting from an environment using CTMRG, we call leading_boundary:\n\nenv_random = CTMRGEnv(randn, ComplexF64, peps₀, ℂ^χenv);\nenv₀, info_ctmrg = leading_boundary(env_random, peps₀; boundary_alg...);\n\n[ Info: CTMRG init:\tobj = -2.749614463601e+00 +3.639628057806e+00im\terr = 1.0000e+00\n[ Info: CTMRG conv 27:\tobj = +9.727103564786e+00\terr = 2.6201795901e-11\ttime = 7.98 sec\n\n\nBesides the converged environment, leading_boundary also returns a NamedTuple of informational quantities such as the last maximal truncation error - that is, the SVD approximation error incurred in the last CTMRG iteration, maximized over all spatial directions and unit cell entries:\n\n@show info_ctmrg.truncation_error;\n\ninfo_ctmrg.truncation_error = 0.0008076332823860801\n","category":"section"},{"location":"examples/heisenberg/#Ground-state-search","page":"Optimizing the 2D Heisenberg model","title":"Ground state search","text":"Finally, we can start the optimization by calling fixedpoint on H with our settings for the boundary (CTMRG) algorithm and the optimizer. This might take a while (especially the precompilation of AD code in this case):\n\npeps, env, E, info_opt = fixedpoint(\n    H, peps₀, env₀; boundary_alg, optimizer_alg, reuse_env, verbosity\n);\n\n[ Info: LBFGS: initializing with f = 6.016453104343e-04, ‖∇f‖ = 9.3548e-01\n[ Info: LBFGS: iter    1, Δt  4.52 s: f = -4.897965192207e-01, ‖∇f‖ = 6.0022e-01, α = 5.94e+01, m = 0, nfg = 5\n[ Info: LBFGS: iter    2, Δt  1.55 s: f = -5.019846341173e-01, ‖∇f‖ = 5.3738e-01, α = 2.80e-01, m = 1, nfg = 2\n[ Info: LBFGS: iter    3, Δt 328.4 ms: f = -5.231639258984e-01, ‖∇f‖ = 3.9927e-01, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, Δt 842.4 ms: f = -5.386543628560e-01, ‖∇f‖ = 4.1552e-01, α = 2.29e-01, m = 3, nfg = 2\n[ Info: LBFGS: iter    5, Δt  2.49 s: f = -5.498211821771e-01, ‖∇f‖ = 4.4002e-01, α = 6.90e-02, m = 4, nfg = 4\n[ Info: LBFGS: iter    6, Δt 850.0 ms: f = -5.690169518488e-01, ‖∇f‖ = 4.8450e-01, α = 2.26e-01, m = 5, nfg = 2\n[ Info: LBFGS: iter    7, Δt 325.7 ms: f = -5.871277303926e-01, ‖∇f‖ = 4.1970e-01, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    8, Δt 319.8 ms: f = -6.001554483426e-01, ‖∇f‖ = 2.1792e-01, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter    9, Δt 305.8 ms: f = -6.068835686463e-01, ‖∇f‖ = 1.9566e-01, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   10, Δt 276.9 ms: f = -6.250397748968e-01, ‖∇f‖ = 3.0330e-01, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, Δt 282.8 ms: f = -6.391659645908e-01, ‖∇f‖ = 2.3075e-01, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, Δt 392.4 ms: f = -6.471793388973e-01, ‖∇f‖ = 2.6051e-01, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, Δt 724.4 ms: f = -6.503370671505e-01, ‖∇f‖ = 1.6112e-01, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, Δt 322.8 ms: f = -6.546061020085e-01, ‖∇f‖ = 7.7751e-02, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, Δt 237.3 ms: f = -6.559626422861e-01, ‖∇f‖ = 5.1323e-02, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, Δt 261.0 ms: f = -6.570346071528e-01, ‖∇f‖ = 5.6661e-02, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, Δt 263.3 ms: f = -6.586101879490e-01, ‖∇f‖ = 4.5250e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, Δt 248.0 ms: f = -6.594209589994e-01, ‖∇f‖ = 4.8923e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   19, Δt 263.4 ms: f = -6.595831316360e-01, ‖∇f‖ = 5.7833e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   20, Δt 268.8 ms: f = -6.598106808006e-01, ‖∇f‖ = 1.7741e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   21, Δt 256.8 ms: f = -6.598737940556e-01, ‖∇f‖ = 1.4673e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   22, Δt 264.8 ms: f = -6.600721854328e-01, ‖∇f‖ = 1.9298e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   23, Δt 254.1 ms: f = -6.602319074023e-01, ‖∇f‖ = 1.7538e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   24, Δt 273.3 ms: f = -6.603792430521e-01, ‖∇f‖ = 2.3872e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   25, Δt 263.2 ms: f = -6.604617775509e-01, ‖∇f‖ = 2.3385e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   26, Δt 258.8 ms: f = -6.605536696759e-01, ‖∇f‖ = 1.2672e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   27, Δt 257.1 ms: f = -6.606169735172e-01, ‖∇f‖ = 1.0506e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   28, Δt 285.6 ms: f = -6.608141517158e-01, ‖∇f‖ = 1.8075e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   29, Δt 305.3 ms: f = -6.609609491552e-01, ‖∇f‖ = 1.7508e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   30, Δt 796.4 ms: f = -6.610389180525e-01, ‖∇f‖ = 1.1325e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   31, Δt 328.4 ms: f = -6.610873060103e-01, ‖∇f‖ = 1.0269e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   32, Δt 254.5 ms: f = -6.611212029182e-01, ‖∇f‖ = 8.8756e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   33, Δt 281.7 ms: f = -6.611799456772e-01, ‖∇f‖ = 1.1435e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   34, Δt 553.2 ms: f = -6.612071690766e-01, ‖∇f‖ = 8.8858e-03, α = 5.30e-01, m = 16, nfg = 2\n[ Info: LBFGS: iter   35, Δt 285.6 ms: f = -6.612262681103e-01, ‖∇f‖ = 6.4795e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   36, Δt 295.0 ms: f = -6.612605080039e-01, ‖∇f‖ = 5.8879e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   37, Δt 285.7 ms: f = -6.612675983705e-01, ‖∇f‖ = 1.2007e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   38, Δt 278.1 ms: f = -6.612837466720e-01, ‖∇f‖ = 4.9256e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   39, Δt 275.6 ms: f = -6.612924155095e-01, ‖∇f‖ = 4.6090e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   40, Δt 273.9 ms: f = -6.613078556647e-01, ‖∇f‖ = 6.2724e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   41, Δt 282.3 ms: f = -6.613407946569e-01, ‖∇f‖ = 8.9187e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   42, Δt 293.4 ms: f = -6.614147324894e-01, ‖∇f‖ = 1.6921e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   43, Δt 310.8 ms: f = -6.614896605795e-01, ‖∇f‖ = 2.7701e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   44, Δt 289.7 ms: f = -6.616600115097e-01, ‖∇f‖ = 2.0288e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   45, Δt 377.8 ms: f = -6.618744649549e-01, ‖∇f‖ = 2.2589e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   46, Δt 739.3 ms: f = -6.619293873126e-01, ‖∇f‖ = 2.6087e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   47, Δt 320.0 ms: f = -6.620580680546e-01, ‖∇f‖ = 1.8561e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   48, Δt 607.9 ms: f = -6.621418094892e-01, ‖∇f‖ = 2.1694e-02, α = 5.08e-01, m = 16, nfg = 2\n[ Info: LBFGS: iter   49, Δt 299.7 ms: f = -6.622424140119e-01, ‖∇f‖ = 1.4693e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   50, Δt 317.6 ms: f = -6.623561643274e-01, ‖∇f‖ = 1.5643e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   51, Δt 325.3 ms: f = -6.624189189954e-01, ‖∇f‖ = 1.2526e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   52, Δt 322.8 ms: f = -6.624484647013e-01, ‖∇f‖ = 7.7875e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   53, Δt 302.8 ms: f = -6.624620825387e-01, ‖∇f‖ = 7.2801e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   54, Δt 297.0 ms: f = -6.624761506291e-01, ‖∇f‖ = 5.6893e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   55, Δt 302.8 ms: f = -6.624920797996e-01, ‖∇f‖ = 7.4763e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   56, Δt 618.9 ms: f = -6.624974230146e-01, ‖∇f‖ = 3.9289e-03, α = 5.46e-01, m = 16, nfg = 2\n[ Info: LBFGS: iter   57, Δt 288.3 ms: f = -6.624993982624e-01, ‖∇f‖ = 3.0506e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   58, Δt 284.2 ms: f = -6.625033254432e-01, ‖∇f‖ = 2.2061e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   59, Δt 300.0 ms: f = -6.625068780651e-01, ‖∇f‖ = 2.0862e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   60, Δt 812.0 ms: f = -6.625094238841e-01, ‖∇f‖ = 3.0782e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   61, Δt 314.7 ms: f = -6.625108313560e-01, ‖∇f‖ = 1.9160e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   62, Δt 248.5 ms: f = -6.625115537204e-01, ‖∇f‖ = 8.6226e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   63, Δt 261.4 ms: f = -6.625118952372e-01, ‖∇f‖ = 7.1198e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   64, Δt 273.4 ms: f = -6.625122637335e-01, ‖∇f‖ = 6.9776e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   65, Δt 263.1 ms: f = -6.625125878909e-01, ‖∇f‖ = 1.1757e-03, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   66, Δt 278.5 ms: f = -6.625129012017e-01, ‖∇f‖ = 6.1076e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   67, Δt 275.1 ms: f = -6.625131620795e-01, ‖∇f‖ = 6.7509e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   68, Δt 287.4 ms: f = -6.625134659017e-01, ‖∇f‖ = 7.4076e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   69, Δt 585.2 ms: f = -6.625136173027e-01, ‖∇f‖ = 1.0650e-03, α = 4.63e-01, m = 16, nfg = 2\n[ Info: LBFGS: iter   70, Δt 297.3 ms: f = -6.625138093900e-01, ‖∇f‖ = 5.3214e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   71, Δt 267.8 ms: f = -6.625138941594e-01, ‖∇f‖ = 4.9455e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   72, Δt 275.5 ms: f = -6.625139584721e-01, ‖∇f‖ = 4.6079e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   73, Δt 270.4 ms: f = -6.625140156102e-01, ‖∇f‖ = 3.5058e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   74, Δt 280.5 ms: f = -6.625140884579e-01, ‖∇f‖ = 7.7069e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   75, Δt 282.6 ms: f = -6.625141400523e-01, ‖∇f‖ = 6.5839e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   76, Δt 267.8 ms: f = -6.625141806040e-01, ‖∇f‖ = 3.1793e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   77, Δt 822.8 ms: f = -6.625142155106e-01, ‖∇f‖ = 2.0830e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   78, Δt 263.1 ms: f = -6.625142398464e-01, ‖∇f‖ = 1.8962e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   79, Δt 253.8 ms: f = -6.625142606414e-01, ‖∇f‖ = 2.6019e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   80, Δt 262.8 ms: f = -6.625142658376e-01, ‖∇f‖ = 2.4559e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: converged after 81 iterations and time  5.83 m: f = -6.625142736963e-01, ‖∇f‖ = 9.4632e-05\n\n\nNote that fixedpoint returns the final optimized PEPS, the last converged environment, the final energy estimate as well as a NamedTuple of diagnostics. This allows us to, e.g., analyze the number of cost function calls or the history of gradient norms to evaluate the convergence rate:\n\n@show info_opt.fg_evaluations info_opt.gradnorms[1:10:end];\n\ninfo_opt.fg_evaluations = 96\ninfo_opt.gradnorms[1:10:end] = [0.9354752030131099, 0.3033019277899899, 0.017741463681835545, 0.01132472701425422, 0.006272379430806119, 0.015643014849711687, 0.003078240790192421, 0.000532137892512568, 0.0002455878974975024]\n\n\nLet's now compare the optimized energy against an accurate Quantum Monte Carlo estimate by Sandvik, where the energy per site was found to be E_textref=06694421. From our simple optimization we find:\n\n@show E;\n\nE = -0.6625142736962993\n\n\nWhile this energy is in the right ballpark, there is still quite some deviation from the accurate reference energy. This, however, can be attributed to the small bond dimension - an optimization with larger bond dimension would approach this value much more closely.\n\nA more reasonable comparison would be against another finite bond dimension PEPS simulation. For example, Juraj Hasik's data from J_1text-J_2 PEPS simulations yields E_D=2chi=16=-0660231dots which is more in line with what we find here.","category":"section"},{"location":"examples/heisenberg/#Compute-the-correlation-lengths-and-transfer-matrix-spectra","page":"Optimizing the 2D Heisenberg model","title":"Compute the correlation lengths and transfer matrix spectra","text":"In practice, in order to obtain an accurate and variational energy estimate, one would need to compute multiple energies at different environment dimensions and extrapolate in, e.g., the correlation length or the second gap of the transfer matrix spectrum. For that, we would need the correlation_length function, which computes the horizontal and vertical correlation lengths and transfer matrix spectra for all unit cell coordinates:\n\nξ_h, ξ_v, λ_h, λ_v = correlation_length(peps, env)\n@show ξ_h ξ_v;\n\nξ_h = [1.0345801030391306]\nξ_v = [1.0245361358882241]\n","category":"section"},{"location":"examples/heisenberg/#Computing-observables","page":"Optimizing the 2D Heisenberg model","title":"Computing observables","text":"As a last thing, we want to see how we can compute expectation values of observables, given the optimized PEPS and its CTMRG environment. To compute, e.g., the magnetization, we first need to define the observable as a TensorMap:\n\nσ_z = TensorMap([1.0 0.0; 0.0 -1.0], ℂ^2, ℂ^2)\n\n2←2 TensorMap{Float64, TensorKit.ComplexSpace, 1, 1, Vector{Float64}}:\n codomain: ⊗(ℂ^2)\n domain: ⊗(ℂ^2)\n\n\nIn order to be able to contract it with the PEPS and environment, we define need to define a LocalOperator and specify on which physical spaces and sites the observable acts. That way, the PEPS-environment-operator contraction gets automatically generated (also works for multi-site operators!). See the LocalOperator docstring for more details. The magnetization is just a single-site observable, so we have:\n\nM = LocalOperator(fill(ℂ^2, 1, 1), (CartesianIndex(1, 1),) => σ_z)\n\nLocalOperator{Tuple{Pair{Tuple{CartesianIndex{2}}, TensorKit.TensorMap{Float64, TensorKit.ComplexSpace, 1, 1, Vector{Float64}}}}, TensorKit.ComplexSpace}(TensorKit.ComplexSpace[ℂ^2;;], ((CartesianIndex(1, 1),) => TensorMap{Float64, TensorKit.ComplexSpace, 1, 1, Vector{Float64}}([1.0, 0.0, 0.0, -1.0], ℂ^2 ← ℂ^2),))\n\nFinally, to evaluate the expecation value on the LocalOperator, we call:\n\n@show expectation_value(peps, M, env);\n\nexpectation_value(peps, M, env) = -0.7533445046064892 - 1.5265566588595902e-16im\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"man/environments/#Environments","page":"Environments","title":"Environments","text":"note: Note\nThis section is still under construction.","category":"section"},{"location":"examples/2d_ising_partition_function/","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/2d_ising_partition_function/#e_2d_ising","page":"The 2D classical Ising model using CTMRG","title":"The 2D classical Ising model using CTMRG","text":"While PEPSKit has a lot of use in quantum systems, describing states using InfinitePEPS that can be contracted via CTMRG or boundary MPS techniques, here we shift our focus to classical physics. We consider the 2D classical Ising model and compute its partition function defined as:\n\nmathcalZ(beta) = sum_s exp(-beta H(s)) text with  H(s) = -J sum_langle i j rangle s_i s_j \n\nwhere the classical spins s_i in +1 -1 are located on the vertices i of a 2D square lattice. The idea is to encode the partition function as an infinite square network consisting of local rank-4 tensors, which can then be contracted using CTMRG. An infinite square network of these rank-4 tensors can be represented as an InfinitePartitionFunction object, as we will see.\n\nBut first, let's seed the RNG and import all required modules:\n\nusing Random, LinearAlgebra\nusing TensorKit, PEPSKit\nusing QuadGK\nRandom.seed!(234923);","category":"section"},{"location":"examples/2d_ising_partition_function/#Defining-the-partition-function","page":"The 2D classical Ising model using CTMRG","title":"Defining the partition function","text":"The first step is to define the rank-4 tensor that, when contracted on a square lattice, evaluates to the partition function value at a given beta. This is done through a fairly generic procedure where the interaction weights are distributed among vertex tensors in an appropriate way. Concretely, here we first define a 'link' matrix containing the Boltzmann weights associated to all possible spin configurations across a given link on the lattice. Next, we define site tensors as delta-tensors that ensiure that the spin value on all adjacent links is the same. Since we only want tensors on the sites in the end, we can symmetrically absorb the link weight tensors into the site tensors, which gives us exactly the kind of network we're looking for. Since we later want to compute the magnetization and energy to check our results, we define the appropriate rank-4 tensors here as well while we're at it.\n\nfunction classical_ising(; beta = log(1 + sqrt(2)) / 2, J = 1.0)\n    K = beta * J\n\n    # Boltzmann weights\n    t = ComplexF64[exp(K) exp(-K); exp(-K) exp(K)]\n    r = eigen(t)\n    nt = r.vectors * sqrt(Diagonal(r.values)) * r.vectors\n\n    # local partition function tensor\n    O = zeros(2, 2, 2, 2)\n    O[1, 1, 1, 1] = 1\n    O[2, 2, 2, 2] = 1\n    @tensor o[-1 -2; -3 -4] := O[3 4; 2 1] * nt[-3; 3] * nt[-4; 4] * nt[-2; 2] * nt[-1; 1]\n\n    # magnetization tensor\n    M = copy(O)\n    M[2, 2, 2, 2] *= -1\n    @tensor m[-1 -2; -3 -4] := M[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * nt[-3; 3] * nt[-4; 4]\n\n    # bond interaction tensor and energy-per-site tensor\n    e = ComplexF64[-J J; J -J] .* nt\n    @tensor e_hor[-1 -2; -3 -4] :=\n        O[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * nt[-3; 3] * e[-4; 4]\n    @tensor e_vert[-1 -2; -3 -4] :=\n        O[1 2; 3 4] * nt[-1; 1] * nt[-2; 2] * e[-3; 3] * nt[-4; 4]\n    e = e_hor + e_vert\n\n    # fixed tensor map space for all three\n    TMS = ℂ^2 ⊗ ℂ^2 ← ℂ^2 ⊗ ℂ^2\n\n    return TensorMap(o, TMS), TensorMap(m, TMS), TensorMap(e, TMS)\nend;\n\nSo let's initialize these tensors at inverse temperature beta=06, check that they are indeed rank-4 and construct the corresponding InfinitePartitionFunction:\n\nbeta = 0.6\nO, M, E = classical_ising(; beta)\n@show space(O)\nZ = InfinitePartitionFunction(O)\n\nInfinitePartitionFunction{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 2, Vector{ComplexF64}}[TensorMap((ℂ^2 ⊗ ℂ^2) ← (ℂ^2 ⊗ ℂ^2)):\n[:, :, 1, 1] =\n  3.169519816780443 + 0.0im  0.4999999999999995 + 0.0im\n 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im\n\n[:, :, 2, 1] =\n 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im\n 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im\n\n[:, :, 1, 2] =\n 0.4999999999999995 + 0.0im  0.1505971059561009 + 0.0im\n 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im\n\n[:, :, 2, 2] =\n 0.1505971059561009 + 0.0im  0.4999999999999995 + 0.0im\n 0.4999999999999995 + 0.0im   3.169519816780443 + 0.0im\n;;])","category":"section"},{"location":"examples/2d_ising_partition_function/#Contracting-the-partition-function","page":"The 2D classical Ising model using CTMRG","title":"Contracting the partition function","text":"Next, we can contract the partition function as per usual by constructing a CTMRGEnv with a specified environment virtual space and calling leading_boundary with appropriate settings:\n\nVenv = ℂ^20\nenv₀ = CTMRGEnv(Z, Venv)\nenv, = leading_boundary(env₀, Z; tol = 1.0e-8, maxiter = 500);\n\n[ Info: CTMRG init:\tobj = +1.784252138312e+00 -1.557258880375e+00im\terr = 1.0000e+00\n[ Info: CTMRG conv 63:\tobj = +3.353928644031e+00\terr = 4.6032264022e-09\ttime = 5.74 sec\n\n\nNote that CTMRG environments for partition functions differ from the PEPS environments only by the edge tensors. Instead of two legs connecting the edges and the PEPS-PEPS sandwich, there is only one leg connecting the edges and the partition function tensor, meaning that the edge tensors are now rank-3:\n\nspace.(env.edges)\n\n4×1×1 Array{TensorKit.TensorMapSpace{TensorKit.ComplexSpace, 2, 1}, 3}:\n[:, :, 1] =\n (ℂ^20 ⊗ ℂ^2) ← ℂ^20\n (ℂ^20 ⊗ ℂ^2) ← ℂ^20\n (ℂ^20 ⊗ (ℂ^2)') ← ℂ^20\n (ℂ^20 ⊗ (ℂ^2)') ← ℂ^20\n\nTo compute the value of the partition function, we have to contract Z with the converged environment using network_value. Additionally, we will compute the magnetization and energy (per site), again using expectation_value but this time also specifying the index in the unit cell where we want to insert the local tensor:\n\nλ = network_value(Z, env)\nm = expectation_value(Z, (1, 1) => M, env)\ne = expectation_value(Z, (1, 1) => E, env)\n@show λ m e;\n\nλ = 3.353928644031378 + 7.047583922370844e-16im\nm = 0.9736086674403002 + 0.0im\ne = -1.8637796145082448 + 1.4610281815259345e-16im\n","category":"section"},{"location":"examples/2d_ising_partition_function/#Comparing-against-the-exact-Onsager-solution","page":"The 2D classical Ising model using CTMRG","title":"Comparing against the exact Onsager solution","text":"In order to assess our results, we will compare against the exact Onsager solution of the 2D classical Ising model. To that end, we compute the exact free energy, magnetization and energy per site (where we use quadgk to perform integrals of an auxiliary variable from 0 to pi2):\n\nfunction classical_ising_exact(; beta = log(1 + sqrt(2)) / 2, J = 1.0)\n    K = beta * J\n\n    k = 1 / sinh(2 * K)^2\n    F = quadgk(\n        theta -> log(cosh(2 * K)^2 + 1 / k * sqrt(1 + k^2 - 2 * k * cos(2 * theta))), 0, pi\n    )[1]\n    f = -1 / beta * (log(2) / 2 + 1 / (2 * pi) * F)\n\n    m = 1 - (sinh(2 * K))^(-4) > 0 ? (1 - (sinh(2 * K))^(-4))^(1 / 8) : 0\n\n    E = quadgk(theta -> 1 / sqrt(1 - (4 * k) * (1 + k)^(-2) * sin(theta)^2), 0, pi / 2)[1]\n    e = -J * cosh(2 * K) / sinh(2 * K) * (1 + 2 / pi * (2 * tanh(2 * K)^2 - 1) * E)\n\n    return f, m, e\nend\n\nf_exact, m_exact, e_exact = classical_ising_exact(; beta);\n\nAnd indeed, we do find agreement between the exact and CTMRG values (keeping in mind that energy accuracy is limited by the environment dimension and the lack of proper extrapolation):\n\n@show (-log(λ) / beta - f_exact) / f_exact\n@show (abs(m) - abs(m_exact)) / abs(m_exact)\n@show (e - e_exact) / e_exact;\n\n(-(log(λ)) / beta - f_exact) / f_exact = -8.807417386354037e-16 + 1.736415096112634e-16im\n(abs(m) - abs(m_exact)) / abs(m_exact) = -3.420952570843561e-16\n(e - e_exact) / e_exact = -0.02373206809908996 - 7.653023727290916e-17im\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"man/multithreading/#Multithreading","page":"Multithreading","title":"Multithreading","text":"Before detailing the multithreading capabilities of PEPSKit, there are some general remarks to be made about parallelism in Julia. In particular, it is important to know the interaction of Julia threads and BLAS threads, and that the BLAS thread behavior is inconsistent among different vendors. Since these details have been explained many times elsewhere, we here want to point towards the MPSKit docs, which provide a good rundown of the threading behavior and what to be aware of.\n\nPEPSKit's multithreading features are provided through OhMyThreads.jl. In addition, we also supply a differentiable parallel map, which parallelizes not only the forward pass but also the reverse pass of the map application, see PEPSKit.dtmap. The threading behaviour can be specified through a global scheduler that is interfaced through the set_scheduler! function:\n\nBy default, the OhMyThreads machinery will be used to parallelize certain parts of the code, if Julia started with multiple threads. Cases where PEPSKit can leverage parallel threads are:\n\nCTMRG steps using the :simultaneous scheme, where we parallelize over all unit cell coordinates and spatial directions\nThe reverse pass of these parallelized CTMRG steps\nEvaluating expectation values of observables, where we parallelize over the terms contained in the LocalOperator","category":"section"},{"location":"man/multithreading/#PEPSKit.Defaults.set_scheduler!","page":"Multithreading","title":"PEPSKit.Defaults.set_scheduler!","text":"set_scheduler!([scheduler]; kwargs...)\n\nSet OhMyThreads multithreading scheduler parameters.\n\nThe function either accepts a scheduler as an OhMyThreads.Scheduler or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via\n\nset_scheduler!(StaticScheduler(; ntasks=4, chunking=true))\n\nor equivalently with \n\nset_scheduler!(:static; ntasks=4, chunking=true)\n\nFor a detailed description of all schedulers and their keyword arguments consult the OhMyThreads documentation.\n\nIf no scheduler is passed and only kwargs are provided, the DynamicScheduler constructor is used with the provided kwargs.\n\nTo reset the scheduler to its default value, one calls set_scheduler! without passing arguments which then uses the default DynamicScheduler(). If the number of used threads is just one it falls back to SerialScheduler().\n\n\n\n\n\n","category":"function"},{"location":"examples/#e_overview","page":"Overview","title":"Overview","text":"Here we provide a number of commented example pages that serve as short tutorials on how to use PEPSKit in various situations. Applications span from two-dimensional quantum models, including fermionic Hamiltonians, to classical three-dimensional statistical mechanics:","category":"section"},{"location":"examples/#Optimization","page":"Overview","title":"Optimization","text":"Pages = Main.examples_optimization\nDepth = 1","category":"section"},{"location":"examples/#Time-Evolution","page":"Overview","title":"Time Evolution","text":"Pages = Main.examples_time_evolution\nDepth = 1","category":"section"},{"location":"examples/#Partition-Functions","page":"Overview","title":"Partition Functions","text":"Pages = Main.examples_partition_functions\nDepth = 1","category":"section"},{"location":"examples/#Boundary-MPS","page":"Overview","title":"Boundary MPS","text":"Pages = Main.examples_boundary_mps\nDepth = 1","category":"section"},{"location":"man/precompilation/#Precompilation-using-PrecompileTools.jl","page":"Precompilation using PrecompileTools.jl","title":"Precompilation using PrecompileTools.jl","text":"For certain PEPSKit applications, the \"time to first execution\" (TTFX) can be quite long. If frequent recompilation is required this can become a significant time sink. Especially in simulations involving AD code, the precompilation times of Zygote tend to be particularly bad.\n\nFortunately, there is an easy way out using PrecompileTools. By writing a precompilation script that executes and precompiles a toy problem which is suited to one's personal problem, one can cut down significantly on the TTFX. To see how that works in the context of PEPSKit, we will closely follow the PrecompileTools docs.\n\nLet's say we have a project where we want to speed up the TTFX, located in a project environment called YourProject. Inside that project folder, we generate a Startup module which will contain the toy problem that we want to precompile:\n\n(YourProject) pkg> generate Startup\n  Generating  project Startup:\n    Startup/Project.toml\n    Startup/src/Startup.jl\n\n(YourProject) pkg> dev ./Startup\n   Resolving package versions...\n    Updating `/YourProject/Project.toml`\n  [e9c42744] + Startup v0.1.0 `Startup`\n    Updating `/tmp/Project1/Manifest.toml`\n  [e9c42744] + Startup v0.1.0 `Startup`\n\n(YourProject) pkg> activate Startup/\n  Activating project at `/YourProject/Startup`\n\n(Startup) pkg> add PrecompileTools YourPackages...\n\nThe Startup module should depend on PrecompileTools as well as all the packages (YourPackages...) that are required to run the precompilation toy problem. Next, we edit the Startup/src/Startup.jl file and add to it all the code which we want PrecompileTools to compile. We will here provide a basic example featuring Zygote AD code on various algorithmic combinations:\n\nmodule Startup\n\nusing Random\nusing TensorKit, KrylovKit, OptimKit\nusing ChainRulesCore, Zygote\nusing MPSKit, MPSKitModels\nusing PEPSKit\nusing PrecompileTools\n\n@setup_workload begin\n    t₀ = time_ns()\n    Random.seed!(20918352394)\n\n    # Hyperparameters\n    Dbond = 2\n    χenv = 4\n    gradtol = 1e-3\n    maxiter = 4\n    verbosity = -1\n    H = heisenberg_XYZ(InfiniteSquare())\n\n    # Algorithmic settings\n    ctmrg_algs = [\n        SimultaneousCTMRG(; maxiter, projector_alg=:halfinfinite, verbosity),\n        SequentialCTMRG(; maxiter, projector_alg=:halfinfinite, verbosity),\n    ]\n    gradient_algs = [\n        LinSolver(; solver_alg=BiCGStab(; tol=gradtol), iterscheme=:fixed),\n        LinSolver(; solver_alg=BiCGStab(; tol=gradtol), iterscheme=:diffgauge),\n        EigSolver(; solver_alg=Arnoldi(; tol=gradtol, eager=true), iterscheme=:fixed),\n    ]\n\n    # Initialize OhMyThreads scheduler (precompilation occurs before __init__ call)\n    set_scheduler!()\n\n    @compile_workload begin\n        # Initialize PEPS and environments with different unit cells, number types and symmetries\n        @info \"Precompiling workload: initializing PEPSs and environments\"\n        peps = InfinitePEPS(randn, ComplexF64, ComplexSpace(Dbond), ComplexSpace(Dbond))\n\n        env, = leading_boundary(CTMRGEnv(peps, ComplexSpace(χenv)), peps; verbosity)\n\n        # CTMRG\n        @info \"Precompiling workload: CTMRG leading_boundary\"\n        for ctmrg_alg in ctmrg_algs\n            leading_boundary(env, peps, ctmrg_alg)\n        end\n\n        # Differentiate CTMRG leading_boundary\n        @info \"Precompiling workload: backpropagation of leading_boundary\"\n        for alg_rrule in gradient_algs\n            Zygote.withgradient(peps) do ψ\n                env′, = PEPSKit.hook_pullback(\n                    leading_boundary, env, ψ, SimultaneousCTMRG(; verbosity); alg_rrule\n                )\n                return cost_function(ψ, env′, H)\n            end\n        end\n\n        # Optimize via fixedpoint using LBFGS\n        @info \"Precompiling workload: LBFGS fixedpoint optimization\"\n        fixedpoint(H, peps, env, opt_alg; tol=gradtol, maxiter, verbosity)\n\n        # Compute correlation length\n        @info \"Precompiling workload: correlation_length\"\n        correlation_length(peps, env)\n    end\n\n    duration = round((time_ns() - t₀) * 1e-9 / 60; digits=2) # minutes\n    @info \"Precompiling workload: finished after $duration min\"\nend\n\nend\n\nFinally, activate YourProject again - where we want to benefit from the shortened execution times - and run using Startup. That way, all packages will be loaded with their precompiled code. Of course, we may also have multiple start-up routines where the precompiled code is tailored towards the needs of the respective projects.","category":"section"},{"location":"man/states/#States","page":"States","title":"States","text":"note: Note\nThis section is still under construction.","category":"section"},{"location":"man/peps_optimization/#PEPS-optimization","page":"PEPS optimization","title":"PEPS optimization","text":"note: Note\nThis section is still under construction.","category":"section"},{"location":"man/models/#Models","page":"Models","title":"Models","text":"PEPSKit implements physical models through the MPSKitModels.jl package as PEPSKit.LocalOperator structs. Here, we want to explain how users can define their own Hamiltonians and provide a list of already implemented models.","category":"section"},{"location":"man/models/#Implementing-custom-models","page":"Models","title":"Implementing custom models","text":"In order to define custom Hamiltonians, we leverage several of the useful tools provided in MPSKitModels. In particular, we use many of the pre-defined operators, which is especially useful when defining models with symmetric and fermionic tensors, since most of these operators can take a symmetry as an argument, returning the appropriate symmetric TensorMap. In order to specify the lattice on which the Hamiltonian is defined, we construct two-dimensional lattices as subtypes of MPSKitModels.AbstractLattice. Note that so far, all models are defined on infinite square lattices, see InfiniteSquare, but in the future, we plan to support other lattice geometries as well. In order to specify tensors acting on particular lattice sites, there are a couple of handy methods that we want to point to: see vertices, nearest_neighbors and next_nearest_neighbors defined here.\n\nFor a simple example on how to implement a custom model, let's look at the implementation of the MPSKitModels.transverse_field_ising model:\n\nfunction MPSKitModels.transverse_field_ising(\n    T::Type{<:Number},\n    S::Union{Type{Trivial},Type{Z2Irrep}},\n    lattice::InfiniteSquare;\n    J=1.0,\n    g=1.0,\n)\n    ZZ = rmul!(σᶻᶻ(T, S), -J)\n    X = rmul!(σˣ(T, S), g * -J)\n    spaces = fill(domain(X)[1], (lattice.Nrows, lattice.Ncols))\n    return LocalOperator(\n        spaces,\n        (neighbor => ZZ for neighbor in nearest_neighbours(lattice))...,\n        ((idx,) => X for idx in vertices(lattice))...,\n    )\nend\n\nThis provides a good recipe for defining a model:\n\nDefine the locally-acting tensors as TensorMaps.\nConstruct a matrix of the physical spaces these TensorMaps act on based on the lattice geometry.\nReturn a LocalOperator where we specify on which sites (e.g. on-site, nearest neighbor, etc.) the local tensors act.\n\nFor more model implementations, check the PEPSKit repository.","category":"section"},{"location":"man/models/#Implemented-models","page":"Models","title":"Implemented models","text":"While PEPSKit provides an interface for specifying custom Hamiltonians, it also provides a number of pre-defined models. Some of these are models already defined in MPSKitModels, which are overloaded for two-dimensional lattices and re-exported, but there are new additions as well. The following models are provided:","category":"section"},{"location":"man/models/#MPSKitModels.jl-models","page":"Models","title":"MPSKitModels.jl models","text":"","category":"section"},{"location":"man/models/#PEPSKit.jl-models","page":"Models","title":"PEPSKit.jl models","text":"","category":"section"},{"location":"man/models/#MPSKitModels.transverse_field_ising","page":"Models","title":"MPSKitModels.transverse_field_ising","text":"transverse_field_ising([elt::Type{<:Number}], [symmetry::Type{<:Sector}],\n                       [lattice::AbstractLattice]; J=1.0, g=1.0)\n\nMPO for the hamiltonian of the one-dimensional Transverse-field Ising model, as defined by\n\nH = -Jleft(sum_langle ij rangle sigma^z_i sigma^z_j + g sum_i sigma^x_i right)\n\nwhere the sigma^i are the spin-1/2 Pauli operators. Possible values for the symmetry are Trivial, Z2Irrep or FermionParity.\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, with Trivial symmetry and with ComplexF64 entries of the tensors.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.heisenberg_XYZ","page":"Models","title":"MPSKitModels.heisenberg_XYZ","text":"heisenberg_XYZ([elt::Type{<:Number}], [lattice::AbstractLattice];\n    Jx=1.0, Jy=1.0, Jz=1.0, spin=1)\n\nMPO for the hamiltonian of the XYZ Heisenberg model, defined by\n\nH = sum_langle ij rangle left( J^x S_i^x S_j^x + J^y S_i^y S_j^y + J^z S_i^z S_j^z right)\n\nBy default, the model is defined on an infinite chain with unit lattice spacing and with ComplexF64 entries of the tensors.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.heisenberg_XXZ","page":"Models","title":"MPSKitModels.heisenberg_XXZ","text":"heisenberg_XXZ([elt::Type{<:Number}], [symmetry::Type{<:Sector}],\n               [lattice::AbstractLattice]; J=1.0, Delta=1.0, spin=1)\n\nMPO for the hamiltonian of the XXZ Heisenberg model, as defined by\n\nH = J left( sum_langle ij rangle S_i^x S_j^x + S_i^y S_j^y + Delta S_i^z S_j^z right)\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, without any symmetries and with ComplexF64 entries of the tensors.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.hubbard_model","page":"Models","title":"MPSKitModels.hubbard_model","text":"hubbard_model([elt::Type{<:Number}], [particle_symmetry::Type{<:Sector}],\n              [spin_symmetry::Type{<:Sector}], [lattice::AbstractLattice];\n              t, U, mu, n)\n\nMPO for the hamiltonian of the Hubbard model, as defined by\n\nH = -t sum_langle ij rangle sum_sigma left( e_isigma^+ e_jsigma^- + c_isigma^- c_jsigma^+ right) + U sum_i n_iuparrown_idownarrow - sum_i mu n_i\n\nwhere sigma is a spin index that can take the values uparrow or downarrow and n is the fermionic number operator e_number.\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, without any symmetries and with ComplexF64 entries of the tensors. If the particle_symmetry is not Trivial, a fixed particle number density n can be imposed.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.bose_hubbard_model","page":"Models","title":"MPSKitModels.bose_hubbard_model","text":"bose_hubbard_model([elt::Type{<:Number}], [symmetry::Type{<:Sector}],\n                   [lattice::AbstractLattice];\n                   cutoff, t, U, mu, n)\n\nMPO for the hamiltonian of the Bose-Hubbard model, as defined by\n\nH = -t sum_langle ij rangle left( a_i^+ a_j^- + a_i^- a_j^+ right) - mu sum_i N_i + fracU2 sum_i N_i(N_i - 1)\n\nwhere N is the bosonic number operator a_number.\n\nBy default, the model is defined on an infinite chain with unit lattice spacing, without any symmetries and with ComplexF64 entries of the tensors. The Hilbert space is truncated such that at maximum of cutoff bosons can be at a single site. If the symmetry is not Trivial, a fixed (halfinteger) particle number density n can be imposed.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#MPSKitModels.tj_model","page":"Models","title":"MPSKitModels.tj_model","text":"tj_model([elt::Type{<:Number}], [particle_symmetry::Type{<:Sector}],\n              [spin_symmetry::Type{<:Sector}], [lattice::AbstractLattice];\n              t, J, mu, slave_fermion::Bool=false)\n\nMPO for the hamiltonian of the t-J model, as defined by\n\nH = -t sum_langle ij rangle sigma\n    (tildee^dagger_isigma tildee_jsigma + hc)\n    + J sum_langle ij rangle(mathbfS_i cdot mathbfS_j - frac14 n_i n_j)\n    - mu sum_i n_i\n\nwhere tildee_isigma is the electron operator with spin sigma restrict to the no-double-occupancy subspace. \n\n\n\n\n\n","category":"function"},{"location":"man/models/#PEPSKit.j1_j2_model","page":"Models","title":"PEPSKit.j1_j2_model","text":"j1_j2_model([elt::Type{T}, symm::Type{S},] lattice::InfiniteSquare;\n            J1=1.0, J2=1.0, spin=1//2, sublattice=true)\n\nSquare lattice J_1text-J_2 model, defined by the Hamiltonian\n\nH = J_1 sum_langle ij rangle vecS_i cdot vecS_j\n+ J_2 sum_langlelangle ij ranglerangle vecS_i cdot vecS_j\n\nwhere vecS_i = (S_i^x S_i^y S_i^z). We denote the nearest and next-nearest neighbor terms using langle ij rangle and langlelangle ij ranglerangle, respectively. The sublattice kwarg enables a single-site unit cell ground state via a unitary sublattice rotation.\n\n\n\n\n\n","category":"function"},{"location":"man/models/#PEPSKit.pwave_superconductor","page":"Models","title":"PEPSKit.pwave_superconductor","text":"pwave_superconductor([T=ComplexF64,] lattice::InfiniteSquare; t=1, μ=2, Δ=1)\n\nSquare lattice p-wave superconductor model, defined by the Hamiltonian\n\n    H = -sum_langle ij rangle left( t c_i^dagger c_j +\n    Delta c_i c_j + texthc right) - mu sum_i n_i\n\nwhere t is the hopping amplitude, Delta specifies the superconducting gap, mu is the chemical potential, and n_i = c_i^dagger c_i is the fermionic number operator.\n\n\n\n\n\n","category":"function"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.\n\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"changelog/#Guidelines-for-updating-this-changelog","page":"Changelog","title":"Guidelines for updating this changelog","text":"When making changes to this project, please update the \"Unreleased\" section with your changes under the appropriate category:\n\nAdded for new features.\nChanged for changes in existing functionality.\nDeprecated for soon-to-be removed features.\nRemoved for now removed features.\nFixed for any bug fixes.\nPerformance for performance improvements.\n\nWhen releasing a new version, move the \"Unreleased\" changes to a new version section with the release date.","category":"section"},{"location":"changelog/#[Unreleased](https://github.com/quantumkithub/pepskit.jl/compare/v0.7.0...HEAD)","page":"Changelog","title":"Unreleased","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/#Changed","page":"Changelog","title":"Changed","text":"Bump OptimKit.jl compatibility to v0.4","category":"section"},{"location":"changelog/#Deprecated","page":"Changelog","title":"Deprecated","text":"","category":"section"},{"location":"changelog/#Removed","page":"Changelog","title":"Removed","text":"Unused implementations of LinearAlgebra methods for CTRMGEnv and InfinitePEPS","category":"section"},{"location":"changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/#Performance","page":"Changelog","title":"Performance","text":"","category":"section"},{"location":"changelog/#[0.7.0](https://github.com/quantumkithub/pepskit.jl/compare/v0.6.1...v0.7.0)-2025-11-17","page":"Changelog","title":"0.7.0 - 2025-11-17","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Changelog","title":"Added","text":"Real time and finite-temperature evolution functionality for simple update\nCorrelator for mixed state InfinitePEPO\nSUWeight to CTMRGEnv conversion (as InfinitePEPS environment)\nSimple update for PEPO (including 3-site version)\nSingle-layer and double-layer PEPO reduced density matrix\nspacetype method for InfinitePartitionFunction\nSupport for SU2Irrep symmetry in j1_j2_model","category":"section"},{"location":"changelog/#Changed-2","page":"Changelog","title":"Changed","text":"A unified interface for Trotter-based time evolution algorithms. The old su_iter, simpleupdate functions should be replaced by timestep, time_evolve respectively\nDefault fixed-point gradient algorithm changed to :eigsolver\nBoundaryMPS methods now have their own custom transfer functions, avoiding a double conjugation and twist issues for fermions\nphysicalspace and related functions now correctly handle periodic indexing for infinite networks\nUpdated compatibility with TensorKit v0.15\nRunic formatter","category":"section"},{"location":"changelog/#Removed-2","page":"Changelog","title":"Removed","text":"InfiniteWeightPEPS and mirror_antidiag\nSupport for integer space specifiers in state and environment constructors\nRemoved redefinition of tensorexpr\nSupport for dual physical spaces for non-bosonic symmetries","category":"section"},{"location":"changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"Add unit normalization of the half and full infinite environments before the projector computation, fixing an issue with the gradient accuracy\nFix sporadic test timeouts when running variational optimization after simple update for the Heisenberg model by switching to a GMRES-based gradient solver\nRotation of iPEPO is now done correctly\nFix rotl90, rotr90 and rot180 for LocalOperator\nFix XXZ model convention\nFix add_physical_charge for fermionic operators\nFix maxiter behavior for fallback gradient linear solver\nFix gauge fixing in :fixed mode for non-uniform unit cells from full SVD","category":"section"},{"location":"changelog/#Performance-2","page":"Changelog","title":"Performance","text":"Avoid @autoopt for partition function calculations\nMultithreaded scheduler now correctly taken into account for the reverse rules.","category":"section"},{"location":"examples/3d_ising_partition_function/","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/3d_ising_partition_function/#e_3d_ising","page":"The 3D classical Ising model","title":"The 3D classical Ising model","text":"In this example, we will showcase how one can use PEPSKit to study 3D classical statistical mechanics models. In particular, we will consider a specific case of the 3D classical Ising model, but the same techniques can be applied to other 3D classical models as well.\n\nAs compared to simulations of 2D partition functions, the workflow presented in this example is a bit more experimental and less 'black-box'. Therefore, it also serves as a demonstration of some of the more internal functionality of PEPSKit, and how one can adapt it to less 'standard' kinds of problems.\n\nLet us consider the partition function of the classical Ising model,\n\nmathcalZ(beta) = sum_s exp(-beta H(s)) text with  H(s) = -J sum_langle i j rangle s_i s_j \n\nwhere the classical spins s_i in +1 -1 are located on the vertices i of a 3D cubic lattice. The partition function of this model can be represented as a 3D tensor network with a rank-6 tensor at each vertex of the lattice. Such a network can be contracted by finding the fixed point of the corresponding transfer operator, in exactly the same spirit as the boundary MPS methods demonstrated in another example.\n\nLet's start by making the example deterministic and importing the required packages:\n\nusing Random\nusing LinearAlgebra\nusing PEPSKit, TensorKit\nusing KrylovKit, OptimKit, Zygote\n\nRandom.seed!(81812781144);","category":"section"},{"location":"examples/3d_ising_partition_function/#Defining-the-partition-function","page":"The 3D classical Ising model","title":"Defining the partition function","text":"Just as in the 2D case, the first step is to define the partition function as a tensor network. The procedure is exactly the same as before, the only difference being that now every spin participates in interactions associated to six links adjacent to that site. This means that the partition function can be written as an infinite 3D network with a single constituent rank-6 PEPSKit.PEPOTensor O located at each site of the cubic lattice. To verify our example we will check the magnetization and energy, so we also define the corresponding rank-6 tensors M and E while we're at it.\n\nfunction three_dimensional_classical_ising(; beta, J = 1.0)\n    K = beta * J\n\n    # Boltzmann weights\n    t = ComplexF64[exp(K) exp(-K); exp(-K) exp(K)]\n    r = eigen(t)\n    q = r.vectors * sqrt(LinearAlgebra.Diagonal(r.values)) * r.vectors\n\n    # local partition function tensor\n    O = zeros(2, 2, 2, 2, 2, 2)\n    O[1, 1, 1, 1, 1, 1] = 1\n    O[2, 2, 2, 2, 2, 2] = 1\n    @tensor o[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n\n    # magnetization tensor\n    M = copy(O)\n    M[2, 2, 2, 2, 2, 2] *= -1\n    @tensor m[-1 -2; -3 -4 -5 -6] :=\n        M[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n\n    # bond interaction tensor and energy-per-site tensor\n    e = ComplexF64[-J J; J -J] .* q\n    @tensor e_x[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * e[-4; 4] * q[-5; 5] * q[-6; 6]\n    @tensor e_y[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * e[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n    @tensor e_z[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * e[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n    e = e_x + e_y + e_z\n\n    # fixed tensor map space for all three\n    TMS = ℂ^2 ⊗ (ℂ^2)' ← ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)'\n\n    return TensorMap(o, TMS), TensorMap(m, TMS), TensorMap(e, TMS)\nend;\n\nLet's initialize these tensors at inverse temperature beta=02391, which corresponds to a slightly lower temperature than the critical value beta_c=02216544\n\nbeta = 0.2391\nO, M, E = three_dimensional_classical_ising(; beta)\nO isa PEPSKit.PEPOTensor\n\ntrue","category":"section"},{"location":"examples/3d_ising_partition_function/#Contracting-the-partition-function","page":"The 3D classical Ising model","title":"Contracting the partition function","text":"To contract our infinite 3D partition function, we first reinterpret it as an infinite power of a slice-to-slice transfer operator mathbbT, where mathbbT can be seen as an infinite 2D projected entangled-pair operator (PEPO) which consists of the rank-6 tensor O at each site of an infinite 2D square lattice,\n\n<center>\n<img src=\"../../assets/figures/pepo.svg\" alt=\"pepo\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>\n\nTo contract the original infinite network, all we need to do is to find the leading eigenvector of the PEPO mathbbT, The fixed point of such a PEPO can be parametrized as a PEPS psi, which should then satisfy the eigenvalue equation mathbbT psirangle = Lambda psirangle, or diagrammatically:\n\n<center>\n<img src=\"../../assets/figures/pepo_fixedpoint_equation.svg\" alt=\"pepo fixedpoint equation\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>\n\nFor a Hermitian transfer operator mathbbT we can characterize the fixed point PEPS psirangle which satisfies the eigenvalue equation mathbbT psirangle = Lambda psirangle corresponding to the largest magnitude eigenvalue Lambda as the solution of a variational problem\n\npsirangle = textargmin_psirangle left ( lim_N to  - frac1N log left( fraclangle psi  mathbbT  psi ranglelangle psi  psi rangle right) right ) \n\nwhere N is the diverging number of sites of the 2D transfer operator mathbbT. The function minimized in this expression is exactly the free energy per site of the partition function. This means we can directly find the fixed-point PEPS by variationally minimizing the free energy.","category":"section"},{"location":"examples/3d_ising_partition_function/#Defining-the-cost-function","page":"The 3D classical Ising model","title":"Defining the cost function","text":"Using PEPSKit.jl, this cost function and its gradient can be computed, after which we can use OptimKit.jl to actually optimize it. We can immediately recognize the denominator langle psi  psi rangle as the familiar PEPS norm, where we can compute the norm per site as the network_value of the corresponding InfiniteSquareNetwork by contracting it with the CTMRG algorithm. Similarly, the numerator langle psi  mathbbT  psi rangle is nothing more than an InfiniteSquareNetwork consisting of three layers corresponding to the ket, transfer operator and bra objects. This object can also be constructed and contracted in a straightforward way, so we can again compute its network_value.\n\nTo define our cost function, we then need to construct the transfer operator as an InfinitePEPO, construct the two infinite 2D contractible networks for the numerator and denominator from the current PEPS and this transfer operator, and specify a contraction algorithm we can use to compute the values of these two networks. In addition, we'll specify the specific reverse rule algorithm that will be used to compute the gradient of this cost function.\n\nboundary_alg = SimultaneousCTMRG(; maxiter = 150, tol = 1.0e-8, verbosity = 1)\nrrule_alg = EigSolver(;\n    solver_alg = KrylovKit.Arnoldi(; maxiter = 30, tol = 1.0e-6, eager = true), iterscheme = :diffgauge\n)\nT = InfinitePEPO(O)\n\nfunction pepo_costfun((peps, env_double_layer, env_triple_layer))\n    # use Zygote to compute the gradient automatically\n    E, gs = withgradient(peps) do ψ\n        # construct the PEPS norm network\n        n_double_layer = InfiniteSquareNetwork(ψ)\n        # contract this network\n        env_double_layer′, info = PEPSKit.hook_pullback(\n            leading_boundary,\n            env_double_layer,\n            n_double_layer,\n            boundary_alg;\n            alg_rrule = rrule_alg,\n        )\n        # construct the PEPS-PEPO-PEPS overlap network\n        n_triple_layer = InfiniteSquareNetwork(ψ, T)\n        # contract this network\n        env_triple_layer′, info = PEPSKit.hook_pullback(\n            leading_boundary,\n            env_triple_layer,\n            n_triple_layer,\n            boundary_alg;\n            alg_rrule = rrule_alg,\n        )\n        # update the environments for reuse\n        PEPSKit.ignore_derivatives() do\n            PEPSKit.update!(env_double_layer, env_double_layer′)\n            PEPSKit.update!(env_triple_layer, env_triple_layer′)\n        end\n        # compute the network values per site\n        λ3 = network_value(n_triple_layer, env_triple_layer)\n        λ2 = network_value(n_double_layer, env_double_layer)\n        # use this to compute the actual cost function\n        return -log(real(λ3 / λ2))\n    end\n    g = only(gs)\n    return E, g\nend;\n\nThere are a few things to note about this cost function definition. Since we will pass it to the OptimKit.optimize, we require it to return both our cost function and the corresponding gradient. To do this, we simply use the withgradient method from Zygote.jl to automatically compute the gradient of the cost function straight from the primal computation. Since our cost function involves contractions using leading_boundary, we also have to specify exactly how Zygote should handle the backpropagation of the gradient through this function. This can be done using the PEPSKit.hook_pullback function from PEPSKit.jl, which allows to hook into the pullback of a given function by specifying a specific algorithm for the pullback computation. Here, we opted to use an Arnoldi method to solve the linear problem defining the gradient of the network contraction at its fixed point. This is exactly the workflow that internally underlies PEPSKit.fixedpoint, and more info on particular gradient algorithms can be found in the corresponding docstrings.","category":"section"},{"location":"examples/3d_ising_partition_function/#Characterizing-the-optimization-manifold","page":"The 3D classical Ising model","title":"Characterizing the optimization manifold","text":"In order to make the best use of OptimKit.jl, we should specify some properties of the manifold on which we are optimizing. Looking at our cost function defined above, a point on our optimization manifold corresponds to a Tuple of three objects. The first is an InfinitePEPS encoding the fixed point we are actually optimizing, while the second and third are CTMRGEnv objects corresponding to the environments of the double and triple layer networks langle psi  psi rangle and langle psi  T  psi rangle respectively. While the environments are just there so we can reuse them between subsequent contractions and we don't need to think about them much, optimizing over the manifold of InfinitePEPS requires a bit more care.\n\nIn particular, we need to define two kinds of operations on this manifold: a retraction and a transport. The retraction, corresponding to the retract keyword argument of OptimKit.optimize, specifies how to move from a point on a manifold along a given descent direction to obtain a new manifold point. The transport, corresponding to the transport! keyword argument of OptimKit.optimize, specifies how to transport a descent direction at a given manifold point to a valid descent direction at a different manifold point according to the appropriate metric. For a more detailed explanation we refer to the OptimKit.jl README. In PEPSKit.jl, these two procedures are defined through the PEPSKit.peps_retract and PEPSKit.peps_transport! methods. While it is instructive to read the corresponding docstrings in order to understand what these actually do, here we can just blindly reuse them where the only difference is that we have to pass along an extra environment since our cost function requires two distinct contractions as opposed to the setting of Hamiltonian PEPS optimization which only requires a double-layer contraction.\n\nfunction pepo_retract((peps, env_double_layer, env_triple_layer), η, α)\n    (peps´, env_double_layer´), ξ = PEPSKit.peps_retract((peps, env_double_layer), η, α)\n    env_triple_layer´ = deepcopy(env_triple_layer)\n    return (peps´, env_double_layer´, env_triple_layer´), ξ\nend\nfunction pepo_transport!(\n        ξ,\n        (peps, env_double_layer, env_triple_layer),\n        η,\n        α,\n        (peps´, env_double_layer´, env_triple_layer´),\n    )\n    return PEPSKit.peps_transport!(\n        ξ, (peps, env_double_layer), η, α, (peps´, env_double_layer´)\n    )\nend;","category":"section"},{"location":"examples/3d_ising_partition_function/#Finding-the-fixed-point","page":"The 3D classical Ising model","title":"Finding the fixed point","text":"All that is left then is to specify the virtual spaces of the PEPS and the two environments, initialize them in the appropriate way, choose an optimization algortithm and call the optimize function from OptimKit.jl to get our desired PEPS fixed point.\n\nVpeps = ℂ^2\nVenv = ℂ^12\n\npsi0 = initializePEPS(T, Vpeps)\nenv2_0 = CTMRGEnv(InfiniteSquareNetwork(psi0), Venv)\nenv3_0 = CTMRGEnv(InfiniteSquareNetwork(psi0, T), Venv)\n\noptimizer_alg = LBFGS(32; maxiter = 100, gradtol = 1.0e-5, verbosity = 3)\n\n(psi_final, env2_final, env3_final), f, = optimize(\n    pepo_costfun,\n    (psi0, env2_0, env3_0),\n    optimizer_alg;\n    inner = PEPSKit.real_inner,\n    retract = pepo_retract,\n    (transport!) = (pepo_transport!),\n);\n\n[ Info: LBFGS: initializing with f = -0.554073395182, ‖∇f‖ = 7.7844e-01\n┌ Warning: CTMRG cancel 150:\tobj = +1.702942228759e+01 +1.443123606306e-07im\terr = 2.4386740905e-05\ttime = 2.49 sec\n└ @ PEPSKit ~/PEPSKit.jl/src/algorithms/ctmrg/ctmrg.jl:152\n[ Info: LBFGS: iter    1, time  154.68 s: f = -0.777080930369, ‖∇f‖ = 3.1305e-02, α = 7.10e+02, m = 0, nfg = 7\n[ Info: LBFGS: iter    2, time  156.09 s: f = -0.784111515961, ‖∇f‖ = 2.0103e-02, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    3, time  156.40 s: f = -0.792705733484, ‖∇f‖ = 2.3327e-02, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, time  156.65 s: f = -0.796289732476, ‖∇f‖ = 2.2475e-02, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    5, time  156.86 s: f = -0.799674902374, ‖∇f‖ = 7.0288e-03, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    6, time  157.05 s: f = -0.800082100121, ‖∇f‖ = 1.2717e-03, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    7, time  157.27 s: f = -0.800110603125, ‖∇f‖ = 1.3384e-03, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    8, time  157.45 s: f = -0.800262201996, ‖∇f‖ = 2.4945e-03, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter    9, time  157.64 s: f = -0.800450505448, ‖∇f‖ = 2.9259e-03, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   10, time  157.85 s: f = -0.800764917087, ‖∇f‖ = 1.7221e-03, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, time  158.07 s: f = -0.800876048838, ‖∇f‖ = 2.2475e-03, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, time  158.26 s: f = -0.801100867467, ‖∇f‖ = 1.5561e-03, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, time  158.48 s: f = -0.801317048856, ‖∇f‖ = 1.1561e-03, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, time  158.69 s: f = -0.801373050545, ‖∇f‖ = 7.1300e-04, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, time  158.89 s: f = -0.801388615264, ‖∇f‖ = 2.8462e-04, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, time  159.10 s: f = -0.801394633333, ‖∇f‖ = 2.7607e-04, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, time  159.28 s: f = -0.801408061564, ‖∇f‖ = 3.6096e-04, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, time  159.53 s: f = -0.801509542169, ‖∇f‖ = 1.9822e-03, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   19, time  159.77 s: f = -0.801578405251, ‖∇f‖ = 1.8040e-03, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   20, time  160.69 s: f = -0.801694524424, ‖∇f‖ = 2.9356e-03, α = 5.48e-01, m = 19, nfg = 3\n[ Info: LBFGS: iter   21, time  161.31 s: f = -0.801761920683, ‖∇f‖ = 1.1993e-03, α = 3.82e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   22, time  161.60 s: f = -0.801797785494, ‖∇f‖ = 6.0337e-04, α = 1.00e+00, m = 21, nfg = 1\n[ Info: LBFGS: iter   23, time  162.21 s: f = -0.801808747834, ‖∇f‖ = 3.7053e-04, α = 5.24e-01, m = 22, nfg = 2\n[ Info: LBFGS: iter   24, time  162.50 s: f = -0.801812729173, ‖∇f‖ = 3.0781e-04, α = 1.00e+00, m = 23, nfg = 1\n[ Info: LBFGS: iter   25, time  162.80 s: f = -0.801816445211, ‖∇f‖ = 2.9994e-04, α = 1.00e+00, m = 24, nfg = 1\n[ Info: LBFGS: iter   26, time  163.09 s: f = -0.801824713130, ‖∇f‖ = 3.6496e-04, α = 1.00e+00, m = 25, nfg = 1\n[ Info: LBFGS: iter   27, time  163.41 s: f = -0.801839673823, ‖∇f‖ = 5.4222e-04, α = 1.00e+00, m = 26, nfg = 1\n[ Info: LBFGS: iter   28, time  163.74 s: f = -0.801857478904, ‖∇f‖ = 2.7917e-04, α = 1.00e+00, m = 27, nfg = 1\n[ Info: LBFGS: iter   29, time  164.06 s: f = -0.801864555224, ‖∇f‖ = 1.2319e-04, α = 1.00e+00, m = 28, nfg = 1\n[ Info: LBFGS: iter   30, time  164.37 s: f = -0.801865598736, ‖∇f‖ = 8.6048e-05, α = 1.00e+00, m = 29, nfg = 1\n[ Info: LBFGS: iter   31, time  164.68 s: f = -0.801867571755, ‖∇f‖ = 8.8636e-05, α = 1.00e+00, m = 30, nfg = 1\n[ Info: LBFGS: iter   32, time  165.00 s: f = -0.801870393528, ‖∇f‖ = 2.6554e-04, α = 1.00e+00, m = 31, nfg = 1\n[ Info: LBFGS: iter   33, time  165.35 s: f = -0.801874797039, ‖∇f‖ = 2.7841e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   34, time  165.70 s: f = -0.801877566644, ‖∇f‖ = 1.8523e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   35, time  166.02 s: f = -0.801878506245, ‖∇f‖ = 2.0638e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   36, time  166.33 s: f = -0.801878995097, ‖∇f‖ = 5.6081e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   37, time  166.64 s: f = -0.801879153573, ‖∇f‖ = 6.2356e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   38, time  166.94 s: f = -0.801879355075, ‖∇f‖ = 6.0528e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   39, time  167.25 s: f = -0.801880115100, ‖∇f‖ = 6.2768e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   40, time  167.60 s: f = -0.801881475065, ‖∇f‖ = 6.2301e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   41, time  167.96 s: f = -0.801882272425, ‖∇f‖ = 9.5267e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   42, time  168.29 s: f = -0.801882600033, ‖∇f‖ = 5.1283e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   43, time  168.61 s: f = -0.801882711875, ‖∇f‖ = 2.6091e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   44, time  168.92 s: f = -0.801882805828, ‖∇f‖ = 2.9316e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   45, time  169.21 s: f = -0.801883027060, ‖∇f‖ = 2.7982e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   46, time  169.52 s: f = -0.801883402178, ‖∇f‖ = 3.8102e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   47, time  169.85 s: f = -0.801883718321, ‖∇f‖ = 5.3658e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   48, time  170.17 s: f = -0.801883962887, ‖∇f‖ = 2.8728e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   49, time  170.51 s: f = -0.801884158085, ‖∇f‖ = 3.0680e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   50, time  170.84 s: f = -0.801884385940, ‖∇f‖ = 4.1973e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   51, time  171.20 s: f = -0.801884810459, ‖∇f‖ = 6.8881e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   52, time  171.54 s: f = -0.801885011014, ‖∇f‖ = 3.8651e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   53, time  171.87 s: f = -0.801885126625, ‖∇f‖ = 1.9013e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   54, time  172.21 s: f = -0.801885186489, ‖∇f‖ = 3.2919e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   55, time  172.56 s: f = -0.801885309713, ‖∇f‖ = 4.8521e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   56, time  172.91 s: f = -0.801885491631, ‖∇f‖ = 1.1478e-04, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   57, time  173.29 s: f = -0.801885912857, ‖∇f‖ = 7.7221e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   58, time  173.66 s: f = -0.801886451980, ‖∇f‖ = 6.5316e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   59, time  174.01 s: f = -0.801886639803, ‖∇f‖ = 5.1567e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   60, time  174.69 s: f = -0.801886699372, ‖∇f‖ = 4.5540e-05, α = 3.68e-01, m = 32, nfg = 2\n[ Info: LBFGS: iter   61, time  174.99 s: f = -0.801886723992, ‖∇f‖ = 2.1992e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   62, time  175.28 s: f = -0.801886735202, ‖∇f‖ = 1.8064e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   63, time  175.61 s: f = -0.801886771395, ‖∇f‖ = 3.8651e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   64, time  175.93 s: f = -0.801886801952, ‖∇f‖ = 4.2630e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   65, time  176.24 s: f = -0.801886837856, ‖∇f‖ = 3.9318e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   66, time  176.55 s: f = -0.801886916783, ‖∇f‖ = 3.8747e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   67, time  176.88 s: f = -0.801887030054, ‖∇f‖ = 3.7140e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   68, time  177.23 s: f = -0.801887141197, ‖∇f‖ = 5.7017e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   69, time  177.94 s: f = -0.801887199203, ‖∇f‖ = 3.0700e-05, α = 5.24e-01, m = 32, nfg = 2\n[ Info: LBFGS: iter   70, time  178.28 s: f = -0.801887246612, ‖∇f‖ = 1.3885e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   71, time  178.61 s: f = -0.801887263715, ‖∇f‖ = 1.5769e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   72, time  178.95 s: f = -0.801887319463, ‖∇f‖ = 2.1423e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   73, time  179.30 s: f = -0.801887406143, ‖∇f‖ = 1.9895e-05, α = 1.00e+00, m = 32, nfg = 1\n[ Info: LBFGS: iter   74, time  180.00 s: f = -0.801887467460, ‖∇f‖ = 1.9799e-05, α = 3.61e-01, m = 32, nfg = 2\n[ Info: LBFGS: converged after 75 iterations and time 180.33 s: f = -0.801887535670, ‖∇f‖ = 9.9342e-06\n","category":"section"},{"location":"examples/3d_ising_partition_function/#Verifying-the-result","page":"The 3D classical Ising model","title":"Verifying the result","text":"Having found the fixed point, we have essentially contracted the entire partition function and we can start computing observables. The free energy per site for example is just given by the final value of the cost function we have just optimized.\n\n@show f\n\n-0.8018875356702571\n\nAs another check, we can compute the magnetization per site and compare it to a reference value obtaind through Monte-Carlo simulations.\n\nn3_final = InfiniteSquareNetwork(psi_final, T)\nnum = PEPSKit.contract_local_tensor((1, 1, 1), M, n3_final, env3_final)\ndenom = PEPSKit._contract_site((1, 1), n3_final, env3_final)\nm = abs(num / denom)\n\nm_ref = 0.667162\n\n@show abs(m - m_ref)\n\n0.00011315585491944447\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/boundary_mps/","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/boundary_mps/#e_boundary_mps","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions of 2D networks","text":"Instead of using CTMRG to contract the network encoding the norm of an infinite PEPS, one can also use so-called boundary MPS methods to contract this network. In this example, we will demonstrate how to use the VUMPS algorithm to do so.\n\nBefore we start, we'll fix the random seed for reproducability:\n\nusing Random\nRandom.seed!(29384293742893);\n\nBesides TensorKit and PEPSKit, here we also need to load the MPSKit.jl package which implements a host of tools for working with 1D matrix product states (MPS), including the VUMPS algorithm:\n\nusing TensorKit, PEPSKit, MPSKit","category":"section"},{"location":"examples/boundary_mps/#Computing-a-PEPS-norm","page":"Boundary MPS contractions of 2D networks","title":"Computing a PEPS norm","text":"We start by initializing a random infinite PEPS. Let us use normally distributed complex entries using randn:\n\nψ = InfinitePEPS(randn, ComplexF64, ComplexSpace(2), ComplexSpace(2))\n\nInfinitePEPS{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}(TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}[TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}(ComplexF64[-0.5524390176345264 - 0.07357188568178248im, -0.5455245317233405 + 0.8946618856309984im, 0.34014501646081047 - 0.7552574870030472im, 1.249282911658007 + 0.45352274131986825im, 0.33621043661988675 + 0.4400876608299719im, -0.0077250067072679235 + 1.7380910495900947im, -0.9866664087107284 - 0.28688827761325675im, -0.19071062901939098 - 1.1367500834118434im, -0.09149850722392933 + 0.3560942836258964im, -0.19309251474097275 - 0.32363899914302613im, 1.6255618447281441 - 0.5689426732891244im, -0.025356816648697236 + 0.5632279168368712im, 0.07675114584269166 - 0.011479824536308164im, -1.0116302866282385 - 0.9253070687198848im, -0.17779977372973318 + 1.1379201927122535im, 1.1649047337212566 + 0.9936369101208083im, 0.2510676919806213 - 0.182052326055189im, 0.04501645227038913 - 0.8140971172854408im, -0.5792402993550532 - 0.4309109406268341im, -0.5608346802110794 + 0.21262550530307248im, 1.5061767210554262 + 0.17190948125245623im, -0.8176938467062373 - 0.40919675695722396im, -0.8001234458239143 + 0.6764943808639017im, -0.6692181340575689 + 0.6923370271564298im, -0.16556382071485704 + 0.2540132491548349im, -0.29883021417599165 - 0.07229462525164528im, 0.05546115732751907 + 0.3723175507964387im, -1.200173153698329 - 0.45509299328832953im, 0.289873563752043 + 0.44718981087960125im, 0.5128282969211142 - 0.2865462937979091im, 0.018357838612906643 + 0.9634127683557584im, -0.44278618042821827 + 0.2612084385439659im], ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)'));;])\n\nTo compute its norm, we have to contract a double-layer network which encodes the bra-ket PEPS overlap langle ψ  ψ rangle:\n\n<center>\n<img src=\"../../assets/figures/peps_norm_network.svg\" alt=\"peps norm network\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>\n\nIn PEPSKit.jl, this structure is represented as an InfiniteSquareNetwork object, whose effective local rank-4 constituent tensor is given by the contraction of a pair of bra and ket PEPSKit.PEPSTensors across their physical legs. Until now, we have always contracted such a network using the CTMRG algorithm. Here however, we will use another approach.\n\nIf we take out a single row of this infinite norm network, we can interpret it as a 1D row-to-row transfer operator mathbbT,\n\n<center>\n<img src=\"../../assets/figures/peps_transfer_operator.svg\" alt=\"peps transfer operator\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>\n\nThis transfer operator can be seen as an infinite chain of the effective local rank-4 tensors that make up the PEPS norm network. Since the network we want to contract can be interpreted as the infinite power of mathbbT, we can contract it by finding its leading eigenvector as a 1D MPS  psi_textMPS rangle, which we call the boundary MPS. This boundary MPS should satisfy the eigenvalue equation mathbbT  psi_textMPS rangle approx Lambda  psi_textMPS rangle, or diagrammatically:\n\n<center>\n<img src=\"../../assets/figures/peps_transfer_fixedpoint_equation.svg\" alt=\"peps transfer fixedpoint equation\" class=\"color-invertible\" style=\"zoom: 180%\"/>\n</center>\n\nNote that if mathbbT is Hermitian, we can formulate this eigenvalue equation in terms of a variational problem for the free energy,\n\nbeginalign\nf = lim_N to  - frac1N log left( fraclangle psi_textMPS  mathbbT  psi_textMPS ranglelangle psi_textMPS  psi_textMPS rangle right)\n\n= -log(lambda)\nendalign\n\nwhere lambda = Lambda^1N is the 'eigenvalue per site' of mathbbT, giving f the meaning of a free energy density.\n\nSince the contraction of a PEPS norm network is in essence exactly the same problem as the contraction of a 2D classical partition function, we can directly use boundary MPS algorithms designed for 2D statistical mechanics models in this context. In particular, we'll use the the VUMPS algorithm to perform the boundary MPS contraction, and we'll call it through the leading_boundary method from MPSKit.jl. This method precisely finds the MPS fixed point of a 1D transfer operator.","category":"section"},{"location":"examples/boundary_mps/#Boundary-MPS-contractions-with-PEPSKit.jl","page":"Boundary MPS contractions of 2D networks","title":"Boundary MPS contractions with PEPSKit.jl","text":"To use leading_boundary, we first need to contruct the transfer operator mathbbT as an MPSKit.InfiniteMPO object. In PEPSKit.jl, we can directly construct the transfer operator corresponding to a PEPS norm network from a given infinite PEPS as an InfiniteTransferPEPS object, which is a specific kind of MPSKit.InfiniteMPO.\n\nTo construct a 1D transfer operator from a 2D PEPS state, we need to specify which direction should be facing north (dir=1 corresponding to north, counting clockwise) and which row of the network is selected from the north - but since we have a trivial unit cell there is only one row here:\n\ndir = 1 ## does not rotate the partition function\nrow = 1\nT = InfiniteTransferPEPS(ψ, dir, row)\n\nsingle site MPSKit.InfiniteMPO{Tuple{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}}}:\n╷  ⋮\n┼ O[1]: (TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}(ComplexF64[-0.552439-0.0735719im, -0.545525+0.894662im, 0.340145-0.755257im, 1.24928+0.453523im, 0.33621+0.440088im, -0.00772501+1.73809im, -0.986666-0.286888im, -0.190711-1.13675im, -0.0914985+0.356094im, -0.193093-0.323639im, 1.62556-0.568943im, -0.0253568+0.563228im, 0.0767511-0.0114798im, -1.01163-0.925307im, -0.1778+1.13792im, 1.1649+0.993637im, 0.251068-0.182052im, 0.0450165-0.814097im, -0.57924-0.430911im, -0.560835+0.212626im, 1.50618+0.171909im, -0.817694-0.409197im, -0.800123+0.676494im, -0.669218+0.692337im, -0.165564+0.254013im, -0.29883-0.0722946im, 0.0554612+0.372318im, -1.20017-0.455093im, 0.289874+0.44719im, 0.512828-0.286546im, 0.0183578+0.963413im, -0.442786+0.261208im], ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')), TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}(ComplexF64[-0.552439-0.0735719im, -0.545525+0.894662im, 0.340145-0.755257im, 1.24928+0.453523im, 0.33621+0.440088im, -0.00772501+1.73809im, -0.986666-0.286888im, -0.190711-1.13675im, -0.0914985+0.356094im, -0.193093-0.323639im, 1.62556-0.568943im, -0.0253568+0.563228im, 0.0767511-0.0114798im, -1.01163-0.925307im, -0.1778+1.13792im, 1.1649+0.993637im, 0.251068-0.182052im, 0.0450165-0.814097im, -0.57924-0.430911im, -0.560835+0.212626im, 1.50618+0.171909im, -0.817694-0.409197im, -0.800123+0.676494im, -0.669218+0.692337im, -0.165564+0.254013im, -0.29883-0.0722946im, 0.0554612+0.372318im, -1.20017-0.455093im, 0.289874+0.44719im, 0.512828-0.286546im, 0.0183578+0.963413im, -0.442786+0.261208im], ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')))\n╵  ⋮\n\n\nSince we'll find the leading eigenvector of mathbbT as a boundary MPS, we first need to construct an initial guess to supply to our algorithm. We can do this using the initialize_mps function, which constructs a random MPS with a specific virtual space for a given transfer operator. Here, we'll build an initial guess for the boundary MPS with a bond dimension of 20:\n\nmps₀ = initialize_mps(T, [ComplexSpace(20)])\n\nsingle site InfiniteMPS:\n│   ⋮\n│ C[1]: TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 1, Vector{ComplexF64}}(ComplexF64[0.234356+0.0im, 0.0212705-0.0337316im, 0.0318229-0.0172048im, 0.0106074+0.0220482im, -0.00928461-0.0147226im, 0.00853533-0.0306597im, 0.076569+0.0547854im, 0.0205662+0.0166832im, -0.0272919+0.0428239im, 0.0373934-0.0540907im, 0.0395844+0.0268069im, -0.0572591+0.0103843im, 0.0189073-0.0116517im, -0.0404962+0.0055653im, 0.00865115-0.0143122im, 0.00272997-0.0420196im, 0.00756212+0.021323im, -0.00240347+0.00300511im, 0.00234515-0.0216668im, 0.0238947-0.00850638im, 0.0+0.0im, 0.241372+0.0im, -0.0293692+0.00013492im, -0.0312148+0.0210993im, -0.0309568-0.00688094im, -0.0606888+0.0320187im, 0.0220294+0.0206023im, -0.0388606-0.00136903im, 0.0266348-0.00444296im, 0.0243917-0.0574445im, 0.0533777-0.0130581im, -0.0461265+0.025293im, 0.0411931+0.0403917im, 0.00720869-0.00549413im, 0.0172979+0.0114934im, 0.00775068+0.0561936im, -0.0337994+0.00860338im, 0.00282096+0.0049669im, 0.0063244+0.0142169im, -0.0370595-0.0043864im, 0.0+0.0im, 0.0+0.0im, 0.272375+0.0im, -0.048824+0.00149444im, 0.00988957+0.0642391im, -0.024105+0.00772899im, -0.0303077+0.00984222im, -0.0149384-0.0244885im, -0.000723504-0.0308744im, -0.0508001+0.0442191im, -0.0424463+0.00407236im, -0.00743337-0.0193087im, -0.00597474-0.0412327im, 0.00118366+0.0724807im, -0.00574401-0.00650947im, 0.0216742-0.0136799im, 0.00810018-0.00596335im, -0.0157738-0.00417548im, -0.0138594+0.0157553im, 0.0302553-0.0117907im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.23341+0.0im, -0.0632917+0.0224243im, -0.0341307-0.0254159im, 0.0330353-0.000259844im, 0.0358483-0.0211876im, -0.0164493+0.00592492im, -0.0276746-0.0306245im, 0.0189518-0.00194967im, 0.022369+0.0129794im, -0.0119318+0.0159589im, 0.00904637+0.0221428im, -0.0441081+0.00312597im, -0.0159461+0.0200282im, -0.00190887-0.0285507im, -0.0048005-0.00993945im, -0.0189977-0.0385335im, 0.00349792-0.0115025im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.221509+0.0im, -0.00167817-0.0146015im, -0.0348746-0.0127731im, 0.00154438+0.0441856im, 0.0170168-0.00928753im, -0.0252145+0.0211729im, 0.0114643+0.00155899im, -0.0370751-0.00604206im, 0.0302099-0.0336153im, 0.025502+0.0412864im, -0.010013+0.0516961im, -0.0256922-0.00445787im, -0.00820098-0.0177101im, 0.024666+0.0252654im, -0.016457+0.0186234im, -0.0107864-0.015864im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.206396+0.0im, 0.0326829+0.00467695im, -0.0214987+0.0286296im, 0.0265114+0.031677im, 0.00815375+0.0158525im, -0.0220433+0.0172381im, -0.0122144-0.00481985im, 0.0166439-0.0068873im, -0.0397734+0.0151648im, 0.0410901+0.0112302im, 0.0187203-0.0445942im, -0.0469279+0.0417944im, 0.0202793+0.0159603im, -0.0134442+0.00726213im, -0.00692071-0.00356056im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.213466+0.0im, -0.0091073+0.0218044im, 0.0290691+0.0275631im, -0.040523-0.0525484im, -0.00261252-0.00435689im, 0.0155879+0.00127739im, -0.00952859-0.0162637im, -0.00454054+0.0594829im, 0.00135532+0.00162318im, -0.014243-0.022403im, 0.0204494-0.00570079im, -0.0166214-0.0164334im, 0.00754371-0.00073282im, -0.0198283-0.00955622im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.219412+0.0im, -0.00725377+0.0238682im, -0.0018644+0.013657im, -0.0321184-0.0436818im, 0.00952698+0.0115205im, -0.0105352-0.0424367im, -0.00899687+0.0430853im, -0.0347616-0.0358782im, -0.0355974+0.0150113im, 0.0399695+0.0259441im, -0.030832-0.0317401im, 0.0262163+0.00624552im, 0.000846414-0.00450105im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.211231+0.0im, -0.0372715-0.0237126im, 0.00264774-0.0219736im, 0.00415091-0.00441262im, -0.0300395-0.0294876im, 0.0276463+0.00272891im, -0.0120474+0.014648im, 0.025048-0.00424904im, -0.0396437+0.00738125im, 0.0316558+0.0311111im, -0.0294062+0.00386465im, -0.0112709+0.00401856im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.187571+0.0im, -0.00719432-3.02588e-5im, 0.0257648-0.00686996im, 0.0325978+0.0153886im, 0.0375554-0.0192687im, -0.00892462-0.0177806im, -0.0255443-0.0129054im, 0.0273104+0.035986im, -0.0137+0.00935715im, 0.0282057-0.0247425im, 0.00118329-0.0216304im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.182919+0.0im, -0.0054585+0.03591im, 0.0120391+0.0281816im, -0.0394714-0.00493972im, 0.0180715+0.00872848im, 0.0188175+0.0334865im, 0.0138824+0.0180983im, 0.00585616-0.012408im, -0.0148048+0.0143228im, -0.00485632+0.017832im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.169948+0.0im, -0.00952592-0.0122069im, 0.0135961-0.00514806im, 0.0135423-0.0153646im, -0.0371089+0.0378614im, -0.0169651+0.00725948im, -0.00156704-0.00759768im, -0.040398-0.0082199im, 0.00265136-0.00773181im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.197798+0.0im, -0.0616662-0.00139262im, 0.00476274-0.0438607im, -0.0276238+0.00758475im, 0.0308466-0.000113641im, -0.0123988-0.00954547im, 0.010847+0.0029771im, 0.0287164-0.0179098im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.184957+0.0im, 0.0226279-2.57053e-5im, -0.00381893+0.000511265im, 0.0290302-0.0133475im, 0.0299231-0.0226597im, 0.0237424-0.0242994im, 0.00172352+0.0477789im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.1569+0.0im, 0.00297201+0.0126363im, -0.0147574+0.0312698im, 0.0116013-0.00562576im, -0.0136585+0.00240712im, 0.00625334+0.022438im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.163084+0.0im, 0.0049925+0.012133im, -0.0272941+0.0219257im, -0.00964102-0.00836637im, 0.00482696-0.00613394im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.14448+0.0im, 0.0154471+0.0102336im, -0.00351024-0.00280969im, 0.0191697-0.0089761im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.126016+0.0im, -0.00797107+0.044782im, -0.0205783-0.015416im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.143035+0.0im, -0.0132998-0.00532042im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.0+0.0im, 0.144245+0.0im], ℂ^20 ← ℂ^20)\n├── AL[1]: TensorMap{ComplexF64, TensorKit.ComplexSpace, 3, 1, Vector{ComplexF64}}(ComplexF64[0.136121+0.121588im, 0.129565+0.200169im, 0.196963-0.135323im, -0.103459-0.0439544im, -0.0267959+0.15836im, -0.0130199+0.0943586im, -0.00055985+0.0403018im, -0.0934598+0.0562789im, -0.0742595+0.0812902im, 0.0536027+0.00516228im, -0.0188773+0.149846im, -0.0341851-0.078553im, 0.0123726+0.0854757im, -0.0280237+0.0937505im, -0.0219633+0.0618633im, -0.0600852-0.0244291im, -0.0475104-0.00689539im, 0.0332424+0.189458im, 0.0540062+0.0435577im, 0.0154707-0.153004im, 0.00731152-0.0181676im, -0.0261214+0.051512im, 0.062349+0.0794917im, -0.0965706-0.0192423im, -0.0127447+0.0565506im, 0.0638949+0.0162237im, 0.025105-0.108424im, -0.0844481-0.102096im, -0.109341-0.037054im, 0.0107094-0.0288857im, 0.0814537+0.0547293im, 0.00993496+0.0228078im, 0.0645924-0.113238im, -0.102067-0.0381104im, -0.0378216+0.0883587im, -0.0149486+0.117237im, -0.0779578-0.0690837im, -0.102296-0.031384im, 0.0579677-0.07035im, -0.0325416-0.000772604im, -0.0217208+0.106833im, 0.0775837-0.0311124im, -0.0548127+0.147616im, 0.147883+0.111194im, -0.0433126-0.118141im, -0.0350337+0.0857993im, -0.0633134+0.00897624im, 0.0112788-0.086397im, -0.067359-0.0357909im, -0.0500186-0.181712im, 0.143795+0.118604im, -0.0510529+0.0589775im, 0.0252804-0.0108538im, 0.0216257-0.0264792im, -0.0459039+0.101508im, -0.0708778+0.140022im, 0.039813-0.150282im, 0.0700008+0.00609571im, -0.0227728-0.0746765im, -0.0788683+0.026972im, 0.0470769-0.106324im, -0.0140349-0.0161587im, 0.131865+0.00326561im, -0.0663706+0.00326447im, 0.0531021+0.00487155im, -0.0576585+0.115006im, -0.0291557+0.0106906im, 0.0783453-0.0191098im, 0.0130691+0.10668im, -0.124198+0.0730588im, -0.102578-0.0691656im, 0.03281+0.0345717im, 0.0421396-0.162899im, 0.00950283+0.0909844im, 0.0758152+0.0823683im, 0.0686434+0.0838978im, -0.105403-0.0209511im, -0.00566482+0.0524887im, -0.0882759-0.0157131im, 0.0784434+0.0658953im, -0.0622392+0.104928im, 0.0369845+0.00116471im, 0.0815218-0.035597im, -0.00456557+0.12741im, 0.128576-0.0722572im, 0.0155183+0.0790375im, -0.117834-0.00762544im, -0.056875-0.0716231im, -0.160339-0.146179im, -0.0403135+0.0857976im, -0.0696323-0.0103795im, 0.144594+0.0274292im, -0.0775599+0.124597im, 0.0653955-0.0988792im, 7.74689e-5+0.0476693im, -0.0218756+0.00157479im, -0.0180254-0.140412im, -0.0253363-0.0956723im, 0.0140961-0.0660874im, 0.0579831+0.0594347im, 0.0782576-0.147247im, 0.106536-0.198978im, -0.0857864-0.07442im, -0.0035913+0.138125im, -0.136159-0.117562im, 0.149851+0.0891131im, 0.200985-0.00350447im, -0.0927866+0.157882im, -0.074548+0.0740528im, -0.00968871-0.0013758im, 0.17668-0.0921806im, 0.0855481+0.111574im, 0.0220163-0.00920673im, -0.0879432-0.0144397im, 0.107279-0.1571im, 0.0994006+0.0125916im, 0.0457038+0.180188im, -0.0451035-0.0375236im, -0.0903467-0.00913725im, -0.0121251+0.0347935im, -0.142264-0.0399194im, 0.0154336+0.0582933im, -0.0646604-0.125288im, 0.0109934-0.0719858im, 0.0372313-0.0876067im, 0.084785+0.0276929im, 0.0423528-0.0803034im, 0.00267026-0.00728417im, 0.0947477+0.0358154im, -0.00302778+0.0239072im, 0.052455-4.51049e-5im, 0.0307757+0.0746588im, 0.0437461-0.0214921im, 0.189779+0.0835625im, -0.00545052+0.0632426im, -0.0908948+0.159063im, 0.0426858+0.0307606im, 0.0519108-0.02311im, 0.0431396-0.00817234im, 0.0397973+0.0545551im, 0.0191049-0.0844964im, 0.0321359+0.0608174im, 0.0175393-0.0456315im, 0.0580713+0.0835083im, 0.0462935+0.0475345im, 0.0212552+0.0556412im, -0.0566776-0.0527798im, -0.0157422+0.0405767im, 0.0393994-0.0754984im, -0.00698292+0.0298164im, -0.0390893+0.0491533im, -0.0421489+0.0785483im, -0.0811594+0.000170636im, 0.0119335-0.075225im, -0.00973565+0.10678im, -0.0914461+0.063238im, -0.0689283-0.0305852im, 0.00307397-0.0206506im, -0.133615+0.0520854im, 0.0060538-0.104462im, -0.0967152+0.0109718im, 0.0809463+0.00551194im, 0.00608277-0.023301im, 0.0201883+0.0542852im, -0.0554329-0.0695084im, -0.054844+0.0211839im, -0.0819368+0.0274147im, 0.0651355-0.0717371im, 0.0349964+0.00565789im, 0.0588089-0.0802446im, -0.108756+0.030916im, -0.153786-0.091321im, -0.0102347-0.077196im, 0.139532-0.185833im, -0.0676648-0.00828499im, -0.114771+0.107609im, -0.14034-0.175392im, -0.023082-0.0390764im, -0.0175933+0.0191685im, -0.0277238-0.0555474im, -0.123633+0.0157432im, 0.0512383+0.122059im, -0.114523-0.270953im, -0.1338-0.0421874im, 0.126929-0.0832913im, 0.120424+0.0624917im, -0.132194-0.111638im, -0.0770991-0.0895976im, 0.0699247+0.104872im, 0.113051+0.175738im, -0.0308667-0.0503412im, 0.0147754-0.0661542im, 0.0175823-0.0233622im, 0.202616+0.0171092im, -0.00248315-0.0507743im, -0.0186058+0.0648304im, 0.0905077+0.00746546im, -0.0142987+0.155395im, 0.0383391-0.0228143im, 0.0120561-0.0882764im, -0.00948665-0.0581453im, -0.0982228-0.173377im, -0.106001+0.0597963im, 0.0723529+0.0196106im, 0.154882-0.0742821im, 0.059612+0.083792im, -0.0504204-0.0210319im, 0.1046+0.0198224im, -0.0919504+0.0361059im, -0.0765843+0.0367333im, 0.08498+0.004202im, 0.00330879+0.0370361im, 0.132509-0.0232631im, 0.0510136+0.0373242im, -0.0837453+0.0521214im, -0.0461358+0.030424im, 0.0966434-0.0483835im, 0.0513136+0.068im, 0.0131867+0.0141692im, 0.0370047+0.0756529im, -0.0045247+0.0968185im, 0.0316377+0.0302085im, -0.127987+0.122766im, 0.039216+0.0733804im, -0.0604436-0.145414im, 0.0529635+0.0242881im, -0.0481996+0.0549306im, 0.0312981+0.0745282im, -0.0231527+0.0101942im, 0.072139-0.0815798im, -0.0213344-0.0879556im, 0.0497902-0.0999376im, 0.101019-0.0399429im, -0.0777692-0.0750806im, 0.0118171-0.027244im, 0.0536269-0.0214749im, -0.0471118+0.0472983im, 0.00983723-0.0215002im, 0.0598448-0.0221455im, -0.0250992+0.000728288im, 0.0134307+0.0761422im, -0.0867809-0.0516863im, 0.0321746+0.102328im, -0.0773977+0.059573im, 0.0244424+0.0921522im, 0.115208+0.00736622im, -0.0399685+0.106923im, -0.0634704+0.00476423im, -0.115719-0.0451951im, 0.116843+0.100923im, 0.110973+0.0578862im, 0.0208319+0.0299472im, 0.253579-0.0312478im, -0.178354-0.0455164im, 0.0431898-0.226347im, -0.062517-0.0363316im, 0.0037473+0.00212674im, -0.0100546-0.0836843im, 0.0447706+0.0493907im, 0.0332812-0.0507339im, 0.0948693+0.171003im, 0.0356702+0.107119im, 0.0220471-0.105687im, -0.0967698-0.0301894im, 0.112821-0.00475466im, 0.125127-0.134142im, -0.00231742+0.0575692im, 0.0611259+0.00257386im, 0.0192213+0.106313im, 0.117859+0.10392im, 0.0531551+0.0038852im, 0.0119485-0.135029im, -0.00573654+0.0177191im, -0.0792038-0.00969129im, 0.117135-0.0534475im, -0.0386099-0.00936196im, -0.0453741+0.103915im, 0.00566532-0.0526106im, 0.0524397+0.0704171im, -0.0382117+0.0363844im, -0.108447-0.100257im, 0.0641702+0.0182156im, -0.193294-0.00903044im, -0.0115732+0.0139384im, -0.176352+0.0693249im, 0.0375038+0.191045im, 0.00925926+0.12229im, 0.0113023-0.100089im, -0.0845269+0.0620574im, 0.033678-0.0824803im, 0.0409774-0.0862845im, 0.0519996+0.0155625im, 0.00353965+0.0359159im, -0.111611-0.0129767im, -0.0130064-0.0490048im, 0.0390214-0.0536364im, -0.0848124-0.027034im, -0.00235352-0.108179im, 0.0591871+0.0372905im, -0.0186709+0.0413643im, 0.011448-0.00140967im, -0.0836851-0.173332im, 0.00823863+0.0428182im, 0.0811049+0.0471501im, 0.104284+0.0660792im, 0.0784551-0.0195788im, -0.0782944-0.0732636im, 0.00411921-0.038646im, -0.0952301-0.162194im, -0.0204142+0.0069206im, -0.0624585-0.0454288im, 0.00561928+0.0813569im, 0.0866678+0.0320534im, 0.0772012-0.103435im, -0.00959444+0.054921im, -0.106379-0.135619im, 0.0122919-0.0346968im, 0.0845378+0.0446448im, -0.0168043-0.0995741im, -0.0366889+0.0811924im, 0.182126-0.161951im, 0.0402423+0.0891302im, -0.104253+0.0648142im, -0.0572805+0.0222346im, 0.0964641-0.0172135im, -0.0193964-0.0124783im, 0.169345+0.11682im, -0.0842312-0.00881155im, 0.0708265+0.0674849im, -0.0379854-0.173469im, 0.0797922-0.0461901im, -0.0266188+0.0101328im, -0.0272302+0.0667105im, -0.0340988-0.0914786im, 0.00304034-0.0816693im, 0.0114041-0.0142944im, 0.0665099-0.100358im, -0.0489951-0.103699im, -0.0303548+0.0284112im, 0.0469004+0.0237189im, -0.114531+0.0161293im, -0.022628+0.0665752im, 0.151919-0.122561im, 0.0519022+0.145226im, 0.00771471-0.148861im, 0.067321+0.0528171im, -0.0742513+0.250292im, 0.0270765-0.0618182im, 0.00567576+0.0271672im, -0.0295294+0.0123182im, -0.0428096-0.0115194im, -0.0201587+0.00653922im, -0.0375943-0.0529894im, -0.089095+0.0368764im, -0.0135416-0.0940759im, 0.0435697-0.0570936im, 0.0368461-0.00106171im, 0.0265087-0.0724551im, 0.0474966+0.0476304im, -0.0357256-0.0554262im, -0.0212624+0.0703699im, 0.0872531-0.0155483im, 0.0244556-0.00890988im, -0.0756131+0.047555im, -0.0204828-0.0310491im, 0.0466734-0.00866986im, -0.156683-0.010445im, 0.0962959-0.0588334im, 0.0678649-0.148863im, 0.143063-0.0282788im, -0.0496124+0.0379076im, 0.0755446+0.0317511im, -0.0967567-0.0180501im, 0.00572981+0.128048im, 0.177703+0.0733563im, -0.116992-0.0442891im, -0.0333322+0.115112im, 0.0766081+0.0320741im, 0.00535986+0.0178018im, -0.0729475+0.00158409im, -0.0551832-0.12735im, 0.0804296-0.094026im, 0.026437+0.174838im, 0.0809253-0.0363533im, -0.148028-0.133563im, 0.00228319+0.13526im, -0.0458781-0.078951im, 0.0923514-0.0508595im, 0.00638747+0.10171im, 0.0693826-0.0848621im, 0.0200357-0.0740859im, 0.0967151+0.137467im, -0.0237326-0.0437519im, 0.0158092+0.0680226im, -0.00989236-0.0278492im, 0.0449316+0.141535im, -0.147279-0.0366814im, 0.080341+0.00537378im, -0.123682-0.031561im, -0.0753383-0.0305439im, -0.00843693+0.0332203im, 0.0258364-0.123487im, 0.0396043-0.0393723im, -0.002572-0.0572385im, 0.00429391+0.123347im, 0.102565+0.0401373im, -0.118241-0.118809im, 0.00342515+0.306623im, -0.073024-0.0785857im, -0.00304844+0.0822226im, 0.140584-0.0271434im, -0.0288731+0.0598339im, -0.0740575+0.0482932im, -0.065114-0.110342im, -0.0173803-0.0125349im, 0.0191775-0.0908261im, -0.065522+0.0227597im, 0.00167777-0.0358668im, 0.00796204-0.0666058im, 0.00483104-0.136588im, -0.0117982-0.011019im, 0.0313429+0.00786834im, 0.0432912-0.0440159im, 0.0717803+0.110949im, -0.0150037-0.0242573im, 0.113728+0.165805im, -0.0180208+0.00527089im, 0.136308-0.109875im, 0.0818345-0.0113036im, -0.115079+0.0234827im, -0.0419426-0.0898372im, -0.0466415+0.0572685im, -0.079375+0.0875054im, 0.00931198+0.0318451im, 0.0243048-0.0224237im, -0.00947168-0.0402674im, 0.0715374-0.095227im, -0.00276868-0.0279281im, -0.00982616+0.0126019im, 0.0899558-0.0233078im, -0.0357134-0.0227577im, -0.0817276+0.0603453im, 0.114869+0.214596im, 0.0868704+0.114749im, -0.0319138-0.0331764im, 0.0392746+0.0203226im, 0.113348+0.106159im, -0.0507514+0.056448im, 0.0520036-0.0270394im, 0.0156815-0.13488im, 0.0165172-0.0297204im, 0.0784883-0.152431im, 0.105479+0.061191im, -0.0890601-0.167215im, -0.0282722-0.0419026im, -0.116616+0.0176234im, 0.100147-0.00369469im, 0.0134313-0.045494im, 0.0112552+0.122847im, 0.0752651+0.0270074im, -0.0209449+0.0308648im, 0.0428358+0.121617im, -0.0740664+0.0212252im, -0.0419513+0.0675293im, 0.00149856-0.12756im, -0.071531+0.0240948im, 0.12924-0.0102448im, -0.147532-0.107234im, 0.0740611+0.0986942im, -0.0210485-0.186054im, -0.0501981+0.0667447im, -0.0196253+0.103502im, 0.0535151-0.0457582im, 0.038113-0.00181239im, -0.0167711+0.0453142im, -0.112703+0.0290827im, -0.0621266-0.12552im, 0.0842113-0.0200924im, 0.112236-0.0575981im, -0.0803796-0.163522im, -0.0762731+0.0661846im, 0.0275447-0.0732116im, 0.10717-0.0437862im, -0.115943-0.0506525im, 0.13994-0.0560268im, -0.0312019-0.104474im, 0.0602122+0.0308179im, 0.02897+0.0060575im, 0.123645-0.103956im, 0.0133279-0.0619474im, -0.118501+0.0273237im, -0.083673-0.0829617im, 0.0847105-0.00546149im, -0.00621092-0.107444im, 0.0366567-0.117013im, 0.102601-0.0811923im, 0.11854-0.0040393im, -0.0224398-0.0218506im, -0.0696161+0.0713786im, 0.0563076-0.0701702im, 0.000450243+0.130981im, 0.0400962-0.0186007im, -0.188096+0.164409im, 0.0533087-0.0664081im, -0.134121+0.0506188im, -0.011773+0.0110154im, 0.0271452+0.112599im, -0.0908915-0.045429im, -0.118984+0.175889im, -0.0489869-0.107941im, -0.0525498-0.00122892im, -0.0834965-0.0580809im, 0.0955521+0.129292im, -0.149409-0.0796943im, 0.0428166-0.0106288im, 0.137317+0.0358487im, 0.0810025-0.00935979im, -0.0466506+0.0156823im, -0.0476104-0.0169217im, 0.031555+0.0170822im, 0.0572224-0.0573579im, 0.043194+0.082992im, -0.0154804+0.158538im, 0.0802341-0.139046im, -0.0803701+0.0340056im, -0.0521298-0.038465im, -0.0332175-0.0277785im, 0.0824766-0.022828im, 0.0694248+0.00572241im, 0.0422335-0.11015im, 0.00442322-0.0688061im, 0.0181463+0.0512661im, 0.0230961+0.0118987im, -0.0957097+0.0232287im, -0.00985588-0.014989im, -0.0360041-0.0967843im, 0.158594+0.0144972im, 0.0449134+0.143058im, -0.0717116-0.0815677im, 0.0884862-0.100949im, -0.153791+0.04164im, -0.0604951+0.0805051im, 0.119604+0.0367098im, -0.120494+0.0923983im, 0.0213604-0.211073im, 0.0819287+0.068158im, -0.0592149+0.069867im, -0.0956807+0.124182im, -0.0482894-0.105284im, 0.13889+0.161949im, -0.0229008-0.0788255im, 0.0461142+0.0101835im, 0.00579128-0.00710336im, -0.0134669+0.00225621im, 0.0266202+0.0208569im, 0.0523386-0.018525im, -0.0447378-0.00828099im, -0.0863781-0.0307453im, 0.0980583-0.0253375im, -0.0269835-0.0768095im, 0.117815-0.0386499im, -0.0145818-0.0429678im, 0.0536352-0.058086im, -0.179699+0.0202838im, 0.101357-0.0872503im, -0.0583221+0.075152im, 0.00837273+0.147885im, 0.000468636-0.000302216im, -0.0909607-0.0321476im, 0.0431131+0.00394364im, -0.0335198-0.0409824im, -0.0339689-0.018396im, -0.138839-0.0026356im, 0.0501145+0.0395422im, -0.0218228+0.0934838im, 0.0539831-0.138537im, 0.0444583+0.0289353im, 0.0163758-0.0114982im, -0.00559761+0.0293179im, 0.0187958-0.0861902im, 0.0111142+0.0238012im, -0.036377-0.0269855im, -0.0930323-0.0074732im, 0.0353215+0.145208im, 0.0738496-0.107772im, 0.0346007-0.066535im, 0.0911522-0.0418556im, -0.0373848+0.102343im, 0.0511492-0.0367393im, -0.129438+0.0433452im, 0.0649868-0.0503467im, -0.0229191+0.0181313im, -0.174905-0.0944915im, 0.0776703+0.101035im, 0.132888+0.0718731im, -0.046455-0.0198464im, -0.0538066-0.0436773im, 0.0953285-0.0178212im, 0.0392972+0.0751331im, -0.0791452+0.0750643im, 0.0925067-0.154086im, 0.124461-0.0356566im, 0.0173818+0.022008im, -0.0408484+0.180551im, -0.105174+0.0923196im, -0.0621344-0.0362854im, -0.00484525+0.00159553im, -0.0796979+0.035978im, 0.0632068+0.130535im, -0.0211082+0.0942126im, 0.109812+0.055889im, 0.0473478+0.0835453im, 0.138562+0.0834065im, -0.0768235+0.0287545im, 0.0036574-0.00468405im, 0.0260099-0.030823im, -0.0355245+0.0131073im, -0.0265357-0.00349549im, 0.0505338-0.0109327im, -0.00786006-0.094351im, -0.0886392+0.00461305im, 0.150575-0.00280342im, 0.177109+0.212419im, -0.0363533-0.131572im, 0.112904+0.0931695im, 0.112503+0.0531413im, 0.0224843+0.061506im, -0.0459468+0.0697628im, -0.0252572-0.0283438im, -0.00812141-0.0838347im, 0.050774-0.00289918im, -0.113681-0.161724im, 0.262223+0.0477937im, -0.211324+0.0587953im, 0.0291384+0.0380081im, 0.0803005+0.023021im, 0.00659843+0.0862866im, 0.0248372-0.0162592im, 0.063644+0.0164165im, -0.047667-0.0504406im, 0.109122+0.035132im, 0.0167204+0.0327058im, -0.0685064+0.0952752im, -0.0140616-0.0915985im, 0.0404347-0.0722005im, 0.0979206-0.0370712im, 0.111754+0.0133351im, -0.0276243+0.0533232im, -0.0499487-0.0495468im, -0.0151069+0.0518184im, -0.0506178+0.0132652im, -0.239574+0.00148447im, -0.0258949-0.0867603im, 0.0807377+0.0343348im, 0.0681118+0.0856464im, 0.0544967-0.0541303im, 0.00489957+0.0799256im, 0.0207273-0.0424218im, 0.155874+0.0297386im, 0.0158097+0.0575619im, 0.00328446-0.0433359im, 0.0403053-0.213556im, -0.0790785+0.00824602im, 0.0152876-0.0795286im, -0.0292856+0.0637187im, 0.0577344+0.119863im, -0.00330911-0.103771im, 0.0643693-0.0179117im, -0.00479393-0.1435im, -0.0917115+0.0319294im, -0.0181537-0.114761im, -0.0421217+0.0499197im, 0.0778543-0.0724999im, 0.0201526-0.0996115im, 0.00308068+0.00775437im, 0.0557139-0.0158565im, -0.00243831-0.00992284im, -0.00385201-0.0813721im, -0.0287695+0.0206551im, 0.0745584+0.0732051im, 0.214065-0.10951im, -0.0259985-0.131859im, 0.0684753+0.0128642im, 0.0319276+0.0506201im, 0.144882-0.110464im, 0.0196663-0.0800981im, 0.0516149+0.0910129im, 0.0101349+0.00664052im, 0.0914119+0.0482539im, -0.0747527-0.165043im, 0.0413568-0.0635959im, -0.0693221+0.0657724im, 0.0365044-0.0251559im, -0.0174501+0.050913im, 0.024104+0.0724012im, 0.0527045-0.106462im, 0.130564+0.0430493im, 0.0759731+0.00204933im, -0.0276763+0.0223241im, -0.0490268+0.0493659im, -0.0225284-0.130815im, -0.154378-0.162012im, -0.0980248+0.0771599im, 0.141508-0.0374196im, 0.0319291+0.0623257im, 0.141194-0.0641872im, -0.0139239-0.105253im, 0.0357681+0.0335473im, 0.00159876-0.0426761im, -0.0411716-0.0253729im, 0.044012-0.0738854im, 0.178761+0.155179im, -0.0588981+0.0283419im, -0.0517148-0.0287977im, 0.082494-0.0137691im, -0.19455-0.135785im, -0.0377519+0.167077im, 0.0434685+0.0721958im, -0.0440632-0.117276im, -0.0210061+0.101583im, 0.0429303+0.0484166im, -0.00274968-0.0626113im, -0.0748755-0.111402im, 0.000734426-0.0178753im, -0.0220211+0.092239im, -0.0509642+0.143533im, 0.102485-0.0694067im, 0.0415428-0.160115im, -0.105056+0.168621im, 0.0266904+0.0705891im, 0.108392+0.0590784im, -0.0927721-0.0421773im, -0.0279278+0.0680865im, 0.177048+0.0374269im, -0.0162908+0.0735778im, 0.0645239+0.0948281im, 0.00708471-0.108708im, -0.0928881+0.0216634im, -0.0470189-0.0487427im, -0.0946236+0.068788im, 0.0628737+0.062084im, -0.0424965-0.0907549im, -0.035725-0.0111451im, 0.149341+0.0052956im, -0.070769-0.0644444im, -0.021404-0.0607889im, 0.00795954-0.0779723im, 0.112822-0.0934957im, 0.00201011+0.0692604im, 0.100613+0.155883im, 0.0534068+0.0368267im, -0.018529-0.0531643im, -0.0438211+0.0975749im, -0.0770061-0.0626689im, -0.00570978-0.0386191im, 0.114558-0.176309im, 0.0546771+0.116744im, -0.0302758+0.0347815im, -0.00514055-0.0618497im, 0.0144864+0.00753913im, 0.121036-0.0824888im, 0.0665328+0.121435im, -0.0223725+0.0378169im, 0.0374235+0.0432862im, -0.0116136-0.0224322im, -0.0347115-0.107482im, -0.0299541+0.0770057im, 0.0896431+0.0061141im, -0.0352181+0.116533im, 0.114917+0.0112533im, 0.0375288+0.0367915im, -0.0582873-0.0185945im, -0.0885866+0.11736im, 0.046199+0.0434253im, -0.146848+0.0882682im, -0.0952114-0.127975im, -0.0678608-0.0608908im, -0.00900662-0.016314im, -0.0618793+0.056113im, -0.0478155-0.106129im, -0.0404909+0.109243im, 0.0107292-0.00301157im, 0.06678+0.0408855im, -0.00121997-0.0432874im, 0.040371+0.0315523im, -0.0662414+0.0409993im, -0.00751288-0.0686733im, -0.195972-0.115568im, -0.0778745+0.0503254im, 0.0192884-0.100936im, -0.0459113+0.0955479im, 0.144969-0.215321im, -0.0959127-0.0230504im, 0.130197-0.118775im, 0.0507006+0.00149925im, 0.0300754+0.00589044im, -0.0598818-0.0775788im, -0.0722682+0.136642im, -0.0873939-0.148839im, -0.0191508+0.0396092im, 0.004516+0.169713im, 0.0458061+0.154222im, -0.0198695+0.106914im, -0.00328147-0.0752272im, -0.0155555-0.188056im, -0.151521-0.0845511im, -0.0228299+0.101521im, -0.0243559+0.0619144im, 0.0704148-0.179286im, 0.197352+0.0271561im, 0.109942+0.0298903im, -0.0290309-0.0509694im, 0.028198+0.0324967im, 0.122333+0.0112685im, 0.0205497+0.0331686im, 0.0132035-0.107072im, 0.022687+0.047982im, 0.000604315+0.0644997im, -0.114816-0.101267im, -0.0413324-0.0467389im, -0.099391-0.0990419im, 0.222213+0.0339075im, -0.0546666+0.0535118im, 0.0763893-0.0348949im, -0.0228747-0.0462767im, -0.0447951-0.105682im, -0.0478462-0.0100684im, -0.0491398+0.0425145im, 0.148614+0.136261im, -0.0223914-0.067844im, 0.187603-0.0284656im, -0.0914551+0.0781024im, 0.0896316+0.122213im, -0.0196933+0.120752im, -0.0156937+0.0194837im, -0.0417865+0.0245658im, -0.0814676+0.0902583im, 0.0132199+0.0780558im, -0.0099676+0.0726021im, 0.0600411+0.00459012im, -0.0313669-0.100018im, -0.130369-0.0386481im, 0.00419817+0.0576432im, 0.0818449-0.0561703im, 0.00220601-0.0618203im, -0.0276142+0.0262781im, -0.0746319-0.0839813im, -0.0190869+0.0841112im, -0.168781-0.12422im, -0.0462975+0.107479im, 0.0198956-0.068836im, 0.0594175-0.115992im, -0.126273-0.0121554im, 0.0133121-0.0166535im, 0.0491638-0.0749591im, 0.107217-0.016384im, -0.0145736-0.0127585im, 0.0525886+0.00373636im, 0.00332615+0.158625im, -0.17312+4.46685e-5im, 0.0576086-0.0273404im, -0.0029016-0.0185031im, 0.120417+0.0546914im, -0.0744195-0.207812im, 0.0327748-0.0824082im, -0.0603293-0.0800748im, -0.0535777-0.0817236im, -0.0659305-0.0593563im, 0.0433674+0.00699974im, -0.0965029-0.116328im, 0.00952819-0.0326506im, 0.0105464+0.0310237im, -0.0647358+0.0531076im, 0.0461136+0.00968873im, -0.0115091+0.0786816im, 0.0119265+0.00643264im, -0.0532156-0.0212529im, 0.0747181+0.10069im, -0.0606129-0.0255834im, -0.0267308+0.0360117im, -0.00946047-0.164767im, 0.0170594-0.0209667im, 0.0194056+0.0672492im, -0.123691-0.120165im, -0.0121613+0.0187102im, 0.0760317-0.00981902im, 0.0613454-0.0637694im, -0.123877-0.119134im, 0.0811609-0.00742241im, 0.130745-0.0100389im, 0.0258506-0.0189453im, 0.109916+0.0432379im, 0.0162442+0.0821948im, -0.00964092-0.0577976im, -0.0313349+0.0358982im, -0.000817394+0.103068im, 0.0181154-0.0292106im, -0.0736826-0.0815715im, 0.0222621-0.0437613im, 0.0363709-0.0986831im, 0.0730026-0.126787im, 0.0509459+0.0165747im, -0.0136663+0.0982626im, 0.00421537+0.00188139im, -0.00308776-0.0248862im, -0.118844-0.0882898im, 0.0773465-0.170176im, 0.0782814-0.0560999im, -0.00692755-0.176002im, -0.186197+0.0470085im, 0.134834-0.0389981im, 0.0466847+0.00414528im, -0.0927056+0.0524693im, 0.033935-0.0549405im, 0.0360669+0.00904688im, 0.024895-0.0778637im, -0.0756899-0.0358767im, -0.00766982-0.0358544im, -0.0702949+0.0277874im, -0.0537219+0.0683406im, 0.0783759+0.0992542im, -0.127843-0.0870881im, 0.120522+0.0870946im, -0.0037393-0.12883im, -0.00515096-0.117252im, 0.0154761+0.102037im, -0.101164+0.0265873im, 0.0290225-0.140136im, -0.119942-0.0267192im, 0.00430843+0.0298212im, -0.110827-0.0718523im, 0.0836798+0.0373784im, 0.00468031-0.0141144im, -0.00138537+0.0568525im, -0.00437132+0.0235935im, 0.0629288+0.0523523im, -0.0174544-0.0685309im, -0.0361392+0.0539268im, 0.00660456+0.0330314im, 0.0814231+0.109546im, 0.166141+0.206568im, -0.065441-0.0478511im, 0.135336+0.0892886im, 0.134855+0.140423im, 0.042035+0.0114177im, 0.0152053+0.115142im, -0.00210195-0.0309338im, 0.0108763+0.154465im, -0.0631565+0.00416921im, 0.0411764-0.0390842im, 0.0337171-0.0620698im, 0.0476954+0.00591305im, 0.0527243+0.169691im, 0.0827984-0.0730562im, 0.0967913-0.0167062im, 0.0094329+0.142115im, -0.0710893-0.121732im, -4.43318e-5-0.152883im, 0.153223-0.0851803im, 0.0949666-0.0136638im, 0.103427+0.102586im, 0.153926-0.0635286im, 0.133892-0.027164im, -0.259787+0.0265997im, 0.0430376+0.0811674im, 0.0466973+0.0456409im, 0.110704+0.0823017im, -0.0304521-0.00927444im, -0.0444833+0.00426235im, 0.0172522+0.144322im, -0.0353474+0.0561506im, -0.127581-0.0613638im, 0.0667089+0.0554852im, -0.158358-0.065111im, -0.0285889+0.0875474im, -0.0389161+0.054802im, 0.0131828-0.0209529im, -0.0898445+0.0516255im, 0.0278819+0.0137756im, 0.0423467-0.0078574im, -0.0215539+0.0855504im, 0.0618457+0.0629992im, -0.0947301-0.0888922im, -0.0319016-0.0728357im, 0.0946838+0.0653811im, -0.0119625+0.00330763im, 0.0562163-0.096052im, -0.0820455+0.0348451im, -0.0830852-0.0893763im, -0.0154527-0.0539474im, -0.0409809-0.0117935im, -0.0497225-0.2464im, 0.0108942+0.0447132im, -0.0320337+0.017428im, -0.0374812-0.00528305im, -0.0272174+0.101052im, -0.0469729-0.129575im, 0.00360156-0.0669703im, 0.0676662+0.104687im, -0.0988469-0.0296687im, 0.0468341-0.114423im, -0.107459-0.0319856im, 0.0524346-0.0929086im, -0.104586-0.0491357im, 0.161665+0.0495663im, 0.15206-0.10722im, 0.0537934-0.0828898im, 0.00788251+0.017027im, 0.101628+0.0195074im, 0.0175263+0.0705366im, -0.117743+0.0873234im, 0.0919411-0.0264841im, -0.0241814+0.0224235im, 0.108194+0.0444112im, 0.0559324+0.0596392im, -0.102732-0.0279905im, -0.0919905+0.0268679im, -0.000730433-0.0881709im, 0.0140116+0.0326803im, -0.10953+0.0455068im, -0.0180376+0.0915381im, 0.0589607+0.0647388im, 0.00564128-0.119918im, 0.011999-0.0676349im, 0.10275-0.14524im, -0.0620291-0.0997072im, 0.0766015+0.0837338im, -0.104327-0.0371957im, 0.149409-0.0105996im, 0.0708969-0.0188444im, 0.23614+0.0625001im, -0.00423922+0.0589502im, -0.0666584+0.0614651im, 0.183183+0.00223324im, -0.0602733-0.0194442im, 0.00544155+0.030675im, -0.0156288-0.0115694im, 0.0287274-0.065003im, -0.0526356+0.0548028im, -0.0562417+0.0544497im, 0.056754+0.0906549im, -0.077372-0.190497im, 0.115581+0.0537207im, 0.0793184-0.080259im, -0.0350692+0.0469529im, 0.0230836+0.00391291im, -0.0809289+0.0637254im, 0.0238897+0.0913539im, -0.0387112+0.0264699im, 0.0156235+0.0487373im, -0.0185544+0.110731im, 0.090857-0.102775im, 0.0214139-0.0800971im, 0.124212-0.0528931im, 0.035058-0.0761236im, -0.0614549+0.11989im, 0.0547782+0.0221399im, -0.0204425-0.0023309im, 0.00778212-0.0138763im, 0.0976933+0.0855575im, 0.0365164+0.0532888im, 0.0129082-0.0426026im, 0.180432-0.180927im, 0.0533053+0.137613im, 0.033217+0.183323im, 0.0613629+0.0171887im, -0.0500982+0.0338581im, -0.014486+0.18514im, -0.113669+0.0414819im, 0.0250356-0.0945137im, 0.114666+0.00351949im, -0.0996813+0.0204619im, 0.0903747-0.0342848im, -0.0542193+0.0136147im, -0.117442-0.11233im, -0.011029-0.100379im, 0.0580437-0.0577716im, -0.0166537+0.00513434im, 0.0106307-0.0153791im, 0.104666+0.109576im, 0.0134182-0.0156897im, -0.026806+0.0013132im, 0.152964+0.0413885im, 0.11216+0.0920126im, 0.00526826+0.125307im, -0.0939841-0.135582im, -0.104098+0.046267im, -0.0576456-0.100249im, -0.023317-0.0245573im, 0.066385+0.149158im, -0.0282577+0.089281im, 0.0268032+0.0219607im, 0.0912067+0.0109137im, 0.0097529+0.0730504im, -0.126139+0.0160488im, 0.00315709-0.0205391im, 0.0412333+0.0999581im, 0.00365228+0.0150248im, 0.110254+0.043868im, -0.0184878-0.00181269im, 0.158099+0.134406im, -0.106261-0.107095im, 0.100182+0.168076im, 0.00799026+0.0711195im, -0.0204227-0.132578im, 0.0357722-0.0720677im, 0.109351-0.0223455im, 0.0785847+0.0697237im, 0.0879005-0.0708231im, -0.136377+0.0335714im, -0.0342384-0.0057235im, 0.0494184-0.0799439im, -0.062825-0.0437784im, 0.0412695+0.118748im, -0.0424144-0.0544086im, 0.0742595+0.0356374im, -0.0222337+0.133022im, 0.0336556-0.0393512im, 0.0175612+0.0486668im, 0.145889-0.00779155im, -0.0174887-0.0348617im, 0.025985+0.0360603im, -0.0560355-0.0333359im, -0.0607733+0.00290881im, -0.0471807+0.0516779im, -0.0977819-0.104652im, -0.0185213-0.0152066im, 0.159321-0.0512277im, 0.0573831-0.0715353im, 0.108507+0.0569177im, -0.0983467+0.00407275im, -0.0650549+0.0703735im, -0.0430625-0.00686465im, -0.0269502-0.0224684im, -0.0836484-0.0771839im, -0.15604-0.0537287im, -0.103595+0.0367778im, -0.0426048-0.130919im, 0.0455122+0.0322225im, -0.0673913+0.0265597im, 0.0982261-0.192526im, -0.0143347-0.0695327im, 0.119039-0.0165666im, -0.0334985+0.111945im, -0.0539561+0.127739im, 0.0569568-0.0527582im, 0.0442672-0.0548046im, -0.0122073-0.209373im, 0.0479696-0.0160274im, -0.0729286-0.129151im, -0.0446814-0.045305im, -0.000411312-0.0399773im, -0.0776336+0.00992611im, -0.0148249+0.134183im, 0.0250636+0.0146705im, 0.093323+0.0541344im, 0.0609487-0.104966im, -0.0537268+0.074963im, -0.120556-0.233958im, -0.0163145+0.0805737im, -0.0822126-0.0552846im, -0.10436-0.0332525im, -0.0485247+0.0404692im, -0.0163212-0.045915im, -0.147902+0.00178979im, -0.0236093-0.0231905im, 0.0199996+0.00773647im, -0.00622368+0.0129235im, -0.00303668+0.165042im, 0.119311-0.0442418im, -0.108235+0.0646868im, 0.0660603+0.101669im, -0.00734277+0.0108686im, 0.103669-0.055437im, 0.0971067+0.0420306im, 0.0404368-0.191363im, 0.0849339+0.0627014im, -0.0475649-0.00500417im, 0.127037-0.156084im, 0.0373316+0.0192545im, 0.0258554+0.0578636im, 0.186986-0.163771im, 0.0447545-0.0337361im, 0.0412176-0.0269697im, 0.00988611-0.0620456im, -0.0175998-0.026089im, -0.017021-0.0868974im, 0.0702248-0.170512im, 0.132778-0.0161216im, -0.0639768+0.0583172im, 0.0542081-0.13128im, -0.0561658-0.0696575im, -0.00756474-0.00204209im, 0.00155534-0.0421im, -0.0835967+0.0826186im, 0.0260258-0.0233333im, -0.0399838-0.0119219im, -0.0809712+0.206339im, -0.0103236-0.0116514im, -0.0274254+0.061023im, -0.0779458-0.0450412im, -0.115179+0.0420439im, -0.13631+0.0432827im, 0.0813731-0.0647819im, 0.108568+0.170035im, 0.0749819+0.0298531im, 0.0629753-0.0175097im, -0.0758252-0.0648325im, -0.00995993-0.0623842im, -0.0157847-0.0159651im, -0.0915122+0.0303221im, -0.00457632+0.143937im, 0.150231+0.0913251im, 0.0176725-0.000508557im, -0.0688639-0.00250937im, -0.0543344-0.0639541im, 0.101345-0.0924622im, -0.000867179+0.0600427im, -0.0792119-0.152291im, -0.00489922-0.0815435im, 0.00296128+0.0493562im, 0.132485-0.203562im, 0.00320491+0.0148167im, -0.0671609+0.111791im, 0.16171+0.0597312im, -0.113323-0.00664944im, 0.0159766-0.0390203im, 0.0680829+0.0611434im, -0.0205688+0.0494396im, -0.0722061-0.0353941im, -0.0254179-0.13959im, 0.0725454+0.0832477im, 0.0893113-0.112083im, 0.0439896-0.117615im, -0.0578702-0.110613im, -0.0603567+0.0515276im, -0.00608919-0.0433999im, -0.0260507-0.0238291im, -0.0161631-0.112291im, -0.038429-0.0910551im, 0.100668-0.0731067im, -0.0190105-0.125359im, -0.198047-0.0213074im, 0.180133-0.103093im, -0.00536561+0.117191im, 0.0306217-0.0519232im, -0.0414228-0.136015im, -0.0944111+0.0107644im, 0.0308609-0.044829im, 0.00455384-0.0486866im, -0.0967659+0.0239484im, 0.0237444-0.0688754im, 0.00566481+0.133689im, -0.0435515-0.213024im, -0.0300393+0.00499907im, -0.0847932-0.0424023im, -0.16423-0.0567178im, 0.0612485-0.0512837im, 0.00769616-0.0954072im, -0.0323535-0.0440016im, -0.0465758+0.0925313im, 0.0715981+0.0118031im, -0.0410899+0.126184im, -0.0500004-0.198234im, -0.0725278+0.0437999im, 0.00425218+0.0314769im, -0.042919+0.0497673im, 0.0701138+0.10688im, 0.0742861+0.0683177im, 0.000628224+0.0416658im, -0.0686126+0.013528im, -0.0140564-0.00298845im, 0.0210836-0.114273im, 0.110126-0.0571059im, -0.014593-0.0451142im, -0.00917988+0.0225957im, -0.0504218+0.112055im, 0.0157514-0.0296851im, 0.0414414-0.0778665im, -0.0628899-0.0681091im, 0.0798988+0.0950401im, 0.101583-0.0300778im, -0.103102-0.0179237im, 0.134003-0.0832791im, -0.118035+0.064682im, 0.0873911-0.00917187im, -0.0141579+0.160579im, 0.0823546-0.00783807im, -0.00484082+0.0381508im, 0.0869804+0.00590079im, -0.0666201-0.121662im, 0.0100752+0.0284919im, 0.0673297-0.0451166im, -0.0138137-0.0594978im, 0.0306469-0.169904im, 0.172697-0.0392023im, -0.0221381+0.00242855im, -0.144653+0.0695113im, 0.0411052-0.0257288im, 0.0776596+0.0068487im, -0.0611206-0.0450027im, 0.00025795+0.101884im, 0.0244185+0.10742im, -0.0302722+0.0618293im, -0.00993234+0.0478885im, 0.0716344+0.0808434im, -0.100413-0.0598848im, -0.0229923+0.0515003im, 0.16837-0.192725im, -0.0761698+0.0798864im, 0.0317827-0.0872934im, 0.000845937-0.0257105im, -0.0461587-0.083864im, -0.0747325+0.0793035im, 0.0735808+0.0941808im, 0.0373852-0.051668im, -0.100113+0.00276281im, 0.0338373+0.042884im, -0.0193186-0.1437im, -0.0555462+0.0902977im, -0.0588708-0.042287im, -0.00612075+0.0339367im, -0.129065-0.182835im, 0.0547995+0.0456858im, 0.194943-0.0347294im, 0.0264871-0.0350993im, 0.145342+0.0108366im, -0.0570181+0.0433224im, -0.0158786-0.0264194im, -0.0251036-0.0477798im, -0.0329697-0.00411678im, 0.0521663-0.0483867im, -0.131154-0.0503362im, -0.0336515+0.103261im, 0.0279296-0.0748148im, -0.0642105+0.0713709im, 0.0784302+0.184505im, -0.00931179+0.0295768im, -0.116113+0.10958im, 0.0285452-0.202788im, 0.0270573+0.0674899im, 0.00973619-0.00511815im, 0.149072+0.0256126im, -0.119934+0.0763647im, -0.0337175+0.0173186im, 0.0611957+0.0667193im, -0.118615+0.119689im, 0.0352917-0.0348011im, 0.109264-0.0335443im, 0.105243+0.0546836im, -0.0894262+0.0515764im, 0.0132604-0.0666536im, 0.07711-0.125214im, 0.101916-0.132171im, 0.0257073+0.022287im, -0.0212378-0.00127077im, -0.0553621+0.0206289im, -0.0569328-0.0792201im, -0.0476411-0.0213706im, 0.121478+0.00818338im, 0.136992+0.152017im, 0.0393387+0.0104925im, 0.05765+0.0206792im, 0.029209-0.0855289im, 0.0720293+0.10617im, 0.0701985+0.0489428im, 0.0659623-0.192647im, 0.0576089-0.13248im, 0.0832965-0.0423453im, -0.0256126+0.0491606im, 0.017473+0.0701525im, -0.101663-0.152396im, 0.111556+0.0349384im, 0.0284788+0.113748im, -0.00520628+0.15787im, 0.0628546+0.0879789im, 0.0283635+0.0269754im, -0.0694347-0.0991681im, -0.0497524+0.0989392im, 0.0306496-0.105895im, 0.0357126+0.0298776im, 0.0634785+0.0783368im, 0.0876108-0.0704608im, 0.0172633+0.00746657im, -0.0107332+0.0634449im, -0.0447654+0.0286374im, -0.0262458+0.0500883im, -0.0518506-0.0751667im, 0.125284-0.0877061im, -0.0730235+0.0700323im, -0.0256927-0.0978621im, 0.0337742+0.116508im, -0.0179934+0.112328im, 0.055129-0.00675477im, 0.0564256+0.0537509im, 0.0543854+0.0203828im, -0.00922907+0.0292085im, -0.0354933+0.0246987im, -0.0328457-0.0733536im, 0.0841733-0.00259941im, -0.184393-0.100159im, 0.0686997+0.053948im, -0.105782+0.0310567im, -0.159519+0.00316541im, -0.00213402+0.0864275im, 0.0129428-0.00832078im, -0.0274385-0.0227082im, -0.0396212-0.138763im, 0.0119269-0.127239im, 0.00895317+0.100797im, 0.0372526-0.0607521im, -0.0162744+0.0527791im, 0.0178663+0.0185839im, 0.00564697-0.0670014im, -0.0281416-0.0636005im, 0.0963809+0.0655524im, -0.00905114+0.00499258im, -0.00266779-0.0558034im, -0.0584583-0.10366im, 0.118344-0.012135im, -0.21409-0.0980661im, -0.0881541+0.106951im, 0.0611682+0.0461859im, 0.032956+0.0500537im, -0.0763085-0.0185344im, 0.0251667-0.206239im, -0.0268402-0.238691im, 0.102487+0.0727793im, 0.118495-0.0534629im, -0.0332665-0.136389im, 0.0734709-0.0450135im, -0.157466-0.0889078im, -0.00699834-0.0944765im, -0.0361805-0.0363123im, 0.0735948-0.144617im, -0.0512486+0.123669im, 0.00114197-0.016737im, -0.0130169-0.0792839im, -0.0572994+0.00111762im, -0.00703507+0.019896im, -0.0476713+0.0391447im, -0.000775428-0.0243211im, -0.106688+0.0294989im, 0.0423524+0.0386274im, 0.0434548-0.0176571im, 0.0441892+0.00912353im, 0.0119184+0.0576632im, -0.0589524+0.15171im, -0.0808825-0.0462427im, -0.0412125-0.0577364im, 0.0186899+0.042064im, -0.0367806-0.0767961im, -0.052474-0.0354519im, -0.117596-0.0887002im, 0.097103+0.0280416im, -0.0259597+0.0587115im, -0.0379324+0.0726993im, 0.110697+0.011884im, 0.0198057+0.0348256im, 0.0461466-0.0186595im, 0.0545422-0.0863321im, 0.0369698+0.0416473im, 0.0709946+0.0636584im, -0.0441699-0.0821753im, 0.004255+0.0802688im, -0.0714121-0.0471197im, 0.0410587+0.0865044im, -0.0208919-0.0412997im, 0.0550552-0.179235im, -0.0135701-0.0324215im, -0.120309-0.0910153im, -0.0908864-0.0725798im, -0.0239568+0.124625im, 0.0552112+0.00268286im, -0.121937+0.046068im, -0.00384392+0.0299733im, -0.0278111+0.202089im, 0.0973334-0.0312862im, -0.0024491-0.0108565im, -0.0654712-0.0688608im, -0.0112541-0.0955502im, 0.00829179-0.020583im, 0.0960012-0.00811653im, -0.00434971+0.118824im, 0.00579137+0.140175im, -0.0661073-0.159932im, -0.173955-0.130367im, -0.0214125+0.0675277im, -0.0151831-0.0836164im, -0.0685982-0.0407133im, 0.144527-0.0510402im, -0.0660527+0.0667281im, 0.0786361-0.0274632im, 0.0819289+0.0760993im, -0.0352606-0.0413609im, -0.0653047+0.00679869im, 0.122089-0.0827175im, 0.0967344-0.0564285im, 0.138684-0.00301627im, 0.0939085+0.149375im, 0.0228594+0.0370641im, 0.0930201-0.0183889im, -0.0204029+0.0334299im, 0.0648964-0.114773im, 0.153606+0.083618im, -0.00168944+0.108863im, -0.173378-0.0800836im, 0.0309147-0.0186499im, -0.0965456-0.0859508im, 0.20051+0.0710254im, -0.124011+0.0665912im, -0.024537-0.14583im, -0.0980367-0.107693im, 0.142336-0.082105im, -0.149277-0.0141165im, 0.0260554+0.166735im, -0.0315023-0.0861793im, -0.00705525+0.0691362im, 0.072574-0.0633469im, 0.0431634-0.0509957im, 0.0388003-0.0150461im, -0.0585611-0.00704im, -0.0901109+0.00837279im, 0.00660596-0.0207768im, -0.0390746+0.0338752im, 0.037445-0.0138944im, -0.141138-0.112563im, 0.0242739+0.0102173im, 0.0944808-0.0525475im, 0.0769785+0.0600186im, 0.0429495+0.089042im, 0.00999755-0.00671487im, 0.0284344-0.0882847im, -0.0956292+0.0414517im, -0.0881605+0.0524004im, -0.128143+0.0249592im, -0.0268824-0.00353341im, 0.0119156+0.0483078im, 0.117372-0.0350251im, 0.00700126+0.123728im, 0.00379278-0.0353523im, -0.144743-0.00246152im, -0.11425-0.035922im, -0.0454338-0.137967im, 0.0478179-0.0114009im, 0.136513+0.176281im, -0.0625485+0.22181im, 0.00986813+0.168968im, -0.0281462-0.0312663im, -0.0579577+0.0203307im, 0.0765008-0.0291379im, 0.0187159-0.0531237im, -0.12115-0.0760885im, 0.00626209+0.0118326im, -0.0361448+0.0953545im, 0.0882767-0.0736592im, -0.0138081+0.0759061im, -0.0194953-0.0377505im, -0.0307651+0.0497302im, -0.0362985+0.121845im, -0.0367937-0.00512124im, -0.0936545+0.00191276im, -0.0969019-0.143509im, 0.046839-0.10804im, 0.0097094+0.192606im, 0.0690086-0.0406602im, -0.0660849-0.0749144im, -0.00662758-0.0628537im, -0.159391+0.127379im, 0.0272895-0.139751im, 0.0576204-0.0361384im, -0.0151528-0.11229im, 0.0549724-0.0410101im, 0.0117069-0.0393213im, -0.0114572+0.0444991im, 0.0968595-0.092635im, 0.0818253-0.0108363im, 0.0341584+0.0658961im, 0.0318812+0.0604239im, 0.0483003+0.0153555im, -0.131343-0.0329953im, -0.0152346-0.097279im, 0.152406-0.0267359im, -0.0113782-0.109233im, 0.0277511-0.0252882im, -0.17751+0.00178876im, 0.0628219+0.101292im, -0.0985323+0.183945im, -0.0690948+0.206687im, 0.0341112-0.0582558im, 0.0287655-0.0761894im, -0.0306304-0.0155873im, -0.0762069-0.00310996im, -0.0397226+0.128154im, 0.155668-0.0209513im, -0.00114456+0.109986im, -0.137565-0.0645391im, -0.101825+0.00521097im, -0.0692237-0.0139281im, -0.0785597-0.0384973im], (ℂ^20 ⊗ ℂ^2 ⊗ (ℂ^2)') ← ℂ^20)\n│   ⋮\n\n\nNote that this will just construct a MPS with random Gaussian entries based on the physical spaces of the supplied transfer operator. Of course, one might come up with a better initial guess (leading to better convergence) depending on the application. To find the leading boundary MPS fixed point, we call leading_boundary using the MPSKit.VUMPS algorithm:\n\nmps, env, ϵ = leading_boundary(mps₀, T, VUMPS(; tol = 1.0e-6, verbosity = 2));\n\n[ Info: VUMPS init:\tobj = +1.674563752306e+00 +3.035692829590e+00im\terr = 7.5576e-01\n[ Info: VUMPS conv 120:\tobj = +6.831610878310e+00 -9.694384440741e-09im\terr = 9.5145748817e-07\ttime = 7.86 sec\n\n\nThe norm of the state per unit cell is then given by the expectation value langle psi_textMPS  mathbbT  psi_textMPS rangle per site:\n\nnorm_vumps = abs(prod(expectation_value(mps, T)))\n\n6.831610878309688\n\nThis can be compared to the result obtained using CTMRG, where we see that the results match:\n\nenv_ctmrg, = leading_boundary(CTMRGEnv(ψ, ComplexSpace(20)), ψ; tol = 1.0e-6, verbosity = 2)\nnorm_ctmrg = abs(norm(ψ, env_ctmrg))\n@show abs(norm_vumps - norm_ctmrg) / norm_vumps;\n\n[ Info: CTMRG init:\tobj = -1.495741317009e+01 +3.091851579630e-01im\terr = 1.0000e+00\n[ Info: CTMRG conv 30:\tobj = +6.831603585666e+00\terr = 6.2262595352e-07\ttime = 6.44 sec\nabs(norm_vumps - norm_ctmrg) / norm_vumps = 1.0674852567312514e-6\n","category":"section"},{"location":"examples/boundary_mps/#Working-with-unit-cells","page":"Boundary MPS contractions of 2D networks","title":"Working with unit cells","text":"For PEPS with non-trivial unit cells, the principle is exactly the same. The only difference is that now the transfer operator of the PEPS norm partition function has multiple rows or 'lines', each of which can be represented by an InfiniteTransferPEPS object. Such a multi-line transfer operator is represented by a PEPSKit.MultilineTransferPEPS object. In this case, the boundary MPS is an MultilineMPS object, which should be initialized by specifying a virtual space for each site in the partition function unit cell.\n\nFirst, we construct a PEPS with a 2 times 2 unit cell using the unitcell keyword argument and then define the corresponding transfer operator, where we again specify the direction which will be facing north:\n\nψ_2x2 = InfinitePEPS(rand, ComplexF64, ComplexSpace(2), ComplexSpace(2); unitcell = (2, 2))\nT_2x2 = PEPSKit.MultilineTransferPEPS(ψ_2x2, dir);\n\nNow, the procedure is the same as before: We compute the norm once using VUMPS, once using CTMRG and then compare.\n\nmps₀_2x2 = initialize_mps(T_2x2, fill(ComplexSpace(20), 2, 2))\nmps_2x2, = leading_boundary(mps₀_2x2, T_2x2, VUMPS(; tol = 1.0e-6, verbosity = 2))\nnorm_2x2_vumps = abs(prod(expectation_value(mps_2x2, T_2x2)))\n\nenv_ctmrg_2x2, = leading_boundary(\n    CTMRGEnv(ψ_2x2, ComplexSpace(20)), ψ_2x2; tol = 1.0e-6, verbosity = 2\n)\nnorm_2x2_ctmrg = abs(norm(ψ_2x2, env_ctmrg_2x2))\n\n@show abs(norm_2x2_vumps - norm_2x2_ctmrg) / norm_2x2_vumps;\n\n[ Info: VUMPS init:\tobj = +8.149302834396e+02 -8.860408249120e+01im\terr = 8.6172e-01\n┌ Warning: VUMPS cancel 200:\tobj = +1.041128719531e+05 -2.947417781828e+02im\terr = 4.9289102276e-02\ttime = 20.80 sec\n└ @ MPSKit ~/.julia/packages/MPSKit/hiGZg/src/algorithms/groundstate/vumps.jl:76\n[ Info: CTMRG init:\tobj = -1.240261729401e+02 -1.672150510263e+01im\terr = 1.0000e+00\n[ Info: CTMRG conv 47:\tobj = +1.046633714846e+05\terr = 1.6994291389e-07\ttime = 3.07 sec\nabs(norm_2x2_vumps - norm_2x2_ctmrg) / norm_2x2_vumps = 0.005283497739358622\n\n\nAgain, the results are compatible. Note that for larger unit cells and non-Hermitian PEPS the VUMPS algorithm may become unstable, in which case the CTMRG algorithm is recommended.","category":"section"},{"location":"examples/boundary_mps/#Contracting-PEPO-overlaps","page":"Boundary MPS contractions of 2D networks","title":"Contracting PEPO overlaps","text":"Using exactly the same machinery, we can contract 2D networks which encode the expectation value of a PEPO for a given PEPS state. As an example, we can consider the overlap of the PEPO correponding to the partition function of 3D classical Ising model with our random PEPS from before and evaluate the overlap langle psi  T  psi rangle.\n\nThe classical Ising PEPO is defined as follows:\n\nfunction ising_pepo(β; unitcell = (1, 1, 1))\n    t = ComplexF64[exp(β) exp(-β); exp(-β) exp(β)]\n    q = sqrt(t)\n\n    O = zeros(2, 2, 2, 2, 2, 2)\n    O[1, 1, 1, 1, 1, 1] = 1\n    O[2, 2, 2, 2, 2, 2] = 1\n    @tensor o[-1 -2; -3 -4 -5 -6] :=\n        O[1 2; 3 4 5 6] * q[-1; 1] * q[-2; 2] * q[-3; 3] * q[-4; 4] * q[-5; 5] * q[-6; 6]\n    O = TensorMap(o, ℂ^2 ⊗ (ℂ^2)' ← ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')\n\n    return InfinitePEPO(O; unitcell)\nend;\n\nTo evaluate the overlap, we instantiate the PEPO and the corresponding InfiniteTransferPEPO in the right direction, on the right row of the partition function (trivial here):\n\nT = ising_pepo(1)\ntransfer_pepo = InfiniteTransferPEPO(ψ, T, 1, 1)\n\nsingle site MPSKit.InfiniteMPO{Tuple{TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}, TensorKit.TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 4, Vector{ComplexF64}}}}:\n╷  ⋮\n┼ O[1]: (TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}(ComplexF64[-0.552439-0.0735719im, -0.545525+0.894662im, 0.340145-0.755257im, 1.24928+0.453523im, 0.33621+0.440088im, -0.00772501+1.73809im, -0.986666-0.286888im, -0.190711-1.13675im, -0.0914985+0.356094im, -0.193093-0.323639im, 1.62556-0.568943im, -0.0253568+0.563228im, 0.0767511-0.0114798im, -1.01163-0.925307im, -0.1778+1.13792im, 1.1649+0.993637im, 0.251068-0.182052im, 0.0450165-0.814097im, -0.57924-0.430911im, -0.560835+0.212626im, 1.50618+0.171909im, -0.817694-0.409197im, -0.800123+0.676494im, -0.669218+0.692337im, -0.165564+0.254013im, -0.29883-0.0722946im, 0.0554612+0.372318im, -1.20017-0.455093im, 0.289874+0.44719im, 0.512828-0.286546im, 0.0183578+0.963413im, -0.442786+0.261208im], ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')), TensorMap{ComplexF64, TensorKit.ComplexSpace, 1, 4, Vector{ComplexF64}}(ComplexF64[-0.552439-0.0735719im, -0.545525+0.894662im, 0.340145-0.755257im, 1.24928+0.453523im, 0.33621+0.440088im, -0.00772501+1.73809im, -0.986666-0.286888im, -0.190711-1.13675im, -0.0914985+0.356094im, -0.193093-0.323639im, 1.62556-0.568943im, -0.0253568+0.563228im, 0.0767511-0.0114798im, -1.01163-0.925307im, -0.1778+1.13792im, 1.1649+0.993637im, 0.251068-0.182052im, 0.0450165-0.814097im, -0.57924-0.430911im, -0.560835+0.212626im, 1.50618+0.171909im, -0.817694-0.409197im, -0.800123+0.676494im, -0.669218+0.692337im, -0.165564+0.254013im, -0.29883-0.0722946im, 0.0554612+0.372318im, -1.20017-0.455093im, 0.289874+0.44719im, 0.512828-0.286546im, 0.0183578+0.963413im, -0.442786+0.261208im], ℂ^2 ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')), TensorMap{ComplexF64, TensorKit.ComplexSpace, 2, 4, Vector{ComplexF64}}(ComplexF64[19.8096+0.0im, 1.34669+0.0im, 1.34669+0.0im, 0.0919699+0.0im, 1.34669+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 1.34669+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 1.34669+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 1.34669+0.0im, 1.34669+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 1.34669+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 1.34669+0.0im, 0.0124468+0.0im, 0.0919699+0.0im, 0.0919699+0.0im, 1.34669+0.0im, 0.0919699+0.0im, 1.34669+0.0im, 1.34669+0.0im, 19.8096+0.0im], (ℂ^2 ⊗ (ℂ^2)') ← (ℂ^2 ⊗ ℂ^2 ⊗ (ℂ^2)' ⊗ (ℂ^2)')))\n╵  ⋮\n\n\nAs before, we converge the boundary MPS using VUMPS and then compute the expectation value:\n\nmps₀_pepo = initialize_mps(transfer_pepo, [ComplexSpace(20)])\nmps_pepo, = leading_boundary(mps₀_pepo, transfer_pepo, VUMPS(; tol = 1.0e-6, verbosity = 2))\nnorm_pepo = abs(prod(expectation_value(mps_pepo, transfer_pepo)));\n@show norm_pepo;\n\n[ Info: VUMPS init:\tobj = +2.655321432467e+01 +3.760603778362e-01im\terr = 8.9759e-01\n┌ Warning: VUMPS cancel 200:\tobj = +9.094977761227e+01 -6.006566625488e+00im\terr = 3.5527156917e-01\ttime = 50.63 sec\n└ @ MPSKit ~/.julia/packages/MPSKit/hiGZg/src/algorithms/groundstate/vumps.jl:76\nnorm_pepo = 91.14790667014051\n\n\nThese objects and routines can be used to optimize PEPS fixed points of 3D partition functions, see for example Vanderstraeten et al.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/j1j2_su/","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/j1j2_su/#Three-site-simple-update-for-the-J_1-J_2-model","page":"Three-site simple update for the J_1-J_2 model","title":"Three-site simple update for the J_1-J_2 model","text":"In this example, we will use SimpleUpdate imaginary time evolution to treat the two-dimensional J_1-J_2 model, which contains next-nearest-neighbour interactions:\n\nH = J_1 sum_langle ij rangle mathbfS_i cdot mathbfS_j\n+ J_2 sum_langle langle ij rangle rangle mathbfS_i cdot mathbfS_j\n\nHere we will exploit the U(1) spin rotation symmetry in the J_1-J_2 model. The goal will be to calculate the energy at J_1 = 1 and J_2 = 12, first using the simple update algorithm and then, to refine the energy estimate, using AD-based variational PEPS optimization.\n\nWe first import all required modules and seed the RNG:\n\nusing Random\nusing TensorKit, PEPSKit\nRandom.seed!(29385293);","category":"section"},{"location":"examples/j1j2_su/#Simple-updating-a-challenging-phase","page":"Three-site simple update for the J_1-J_2 model","title":"Simple updating a challenging phase","text":"Let's start by initializing an InfinitePEPS for which we set the required parameters as well as physical and virtual vector spaces. The SUWeight used by simple update will be initialized to identity matrices. We use the minimal unit cell size (2 times 2) required by the simple update algorithm for Hamiltonians with next-nearest-neighbour interactions:\n\nDbond, symm = 4, U1Irrep\nNr, Nc, J1 = 2, 2, 1.0\n\n# random initialization of 2x2 iPEPS (using real numbers) and SUWeight\nPspace = Vect[U1Irrep](1 // 2 => 1, -1 // 2 => 1)\nVspace = Vect[U1Irrep](0 => 2, 1 // 2 => 1, -1 // 2 => 1)\npeps = InfinitePEPS(rand, Float64, Pspace, Vspace; unitcell = (Nr, Nc));\nwts = SUWeight(peps);\n\nThe value J_2  J_1 = 05 corresponds to a possible spin liquid phase, which is challenging for SU to produce a relatively good state from random initialization. Therefore, we shall gradually increase J_2  J_1 from 0.1 to 0.5, each time initializing on the previously evolved PEPS:\n\ndt, tol, nstep = 1.0e-2, 1.0e-8, 30000\ncheck_interval = 4000\ntrunc_peps = truncerror(; atol = 1.0e-10) & truncrank(Dbond)\nalg = SimpleUpdate(; trunc = trunc_peps)\nfor J2 in 0.1:0.1:0.5\n    # convert Hamiltonian `LocalOperator` to real floats\n    H = real(\n        j1_j2_model(ComplexF64, symm, InfiniteSquare(Nr, Nc); J1, J2, sublattice = false),\n    )\n    global peps, wts, = time_evolve(peps, H, dt, nstep, alg, wts; tol, check_interval)\nend\n\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1/2 => 1, -1/2 => 1)\n[ Info: SU iter 1      : dt = 0.01, |Δλ| = 1.189e+00. Time = 38.623 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 1833   : dt = 0.01, |Δλ| = 9.859e-09. Time = 0.060 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 159.85 s\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 1      : dt = 0.01, |Δλ| = 3.401e-04. Time = 0.063 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 523    : dt = 0.01, |Δλ| = 9.965e-09. Time = 0.076 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 33.42 s\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 1      : dt = 0.01, |Δλ| = 3.526e-04. Time = 0.061 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 611    : dt = 0.01, |Δλ| = 9.848e-09. Time = 0.076 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 38.95 s\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 1      : dt = 0.01, |Δλ| = 3.664e-04. Time = 0.061 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 735    : dt = 0.01, |Δλ| = 9.963e-09. Time = 0.060 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 46.82 s\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 1      : dt = 0.01, |Δλ| = 3.828e-04. Time = 0.061 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 901    : dt = 0.01, |Δλ| = 9.995e-09. Time = 0.077 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 57.45 s\n\n\nAfter we reach J_2  J_1 = 05, we gradually decrease the evolution time step to obtain a more accurately evolved PEPS:\n\ndts = [1.0e-3, 1.0e-4]\ntols = [1.0e-9, 1.0e-9]\nJ2 = 0.5\nH = real(j1_j2_model(ComplexF64, symm, InfiniteSquare(Nr, Nc); J1, J2, sublattice = false))\nfor (dt, tol) in zip(dts, tols)\n    global peps, wts, = time_evolve(peps, H, dt, nstep, alg, wts; tol)\nend\n\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 1      : dt = 0.001, |Δλ| = 4.477e-04. Time = 0.063 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 500    : dt = 0.001, |Δλ| = 2.767e-08. Time = 0.061 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 1000   : dt = 0.001, |Δλ| = 9.954e-09. Time = 0.061 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 1500   : dt = 0.001, |Δλ| = 5.019e-09. Time = 0.061 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 2000   : dt = 0.001, |Δλ| = 3.015e-09. Time = 0.076 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 2500   : dt = 0.001, |Δλ| = 1.935e-09. Time = 0.076 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 3000   : dt = 0.001, |Δλ| = 1.273e-09. Time = 0.076 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 3295   : dt = 0.001, |Δλ| = 9.994e-10. Time = 0.060 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 209.81 s\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 1      : dt = 0.0001, |Δλ| = 4.467e-05. Time = 0.061 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 500    : dt = 0.0001, |Δλ| = 1.150e-09. Time = 0.075 s/it\n[ Info: Space of x-weight at [1, 1] = Rep[U₁](0 => 2, 1 => 1, -1 => 1)\n[ Info: SU iter 873    : dt = 0.0001, |Δλ| = 9.998e-10. Time = 0.060 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 55.60 s\n","category":"section"},{"location":"examples/j1j2_su/#Computing-the-simple-update-energy-estimate","page":"Three-site simple update for the J_1-J_2 model","title":"Computing the simple update energy estimate","text":"Finally, we measure the ground-state energy by converging a CTMRG environment and computing the expectation value, where we first normalize tensors in the PEPS:\n\nnormalize!.(peps.A, Inf) ## normalize each PEPS tensor by largest element\nχenv = 32\ntrunc_env = truncerror(; atol = 1.0e-10) & truncrank(χenv)\nEspace = Vect[U1Irrep](0 => χenv ÷ 2, 1 // 2 => χenv ÷ 4, -1 // 2 => χenv ÷ 4)\nenv₀ = CTMRGEnv(rand, Float64, peps, Espace)\nenv, = leading_boundary(env₀, peps; tol = 1.0e-10, alg = :sequential, trunc = trunc_env);\nE = expectation_value(peps, H, env) / (Nr * Nc)\n\n-0.4908483447932549\n\nLet us compare that estimate with benchmark data obtained from the YASTN/peps-torch package. which utilizes AD-based PEPS optimization to find E_textref=-049425:\n\nE_ref = -0.49425\n@show (E - E_ref) / abs(E_ref);\n\n(E - E_ref) / abs(E_ref) = 0.006882458688406928\n","category":"section"},{"location":"examples/j1j2_su/#Variational-PEPS-optimization-using-AD","page":"Three-site simple update for the J_1-J_2 model","title":"Variational PEPS optimization using AD","text":"As a last step, we will use the SU-evolved PEPS as a starting point for a fixedpoint PEPS optimization. Note that we could have also used a sublattice-rotated version of H to fit the Hamiltonian onto a single-site unit cell which would require us to optimize fewer parameters and hence lead to a faster optimization. But here we instead take advantage of the already evolved peps, thus giving us a physical initial guess for the optimization. In order to break some of the C_4v symmetry of the PEPS, we will add a bit of noise to it. This is conviently done using MPSKit's randomize! function. (Breaking some of the spatial symmetry can be advantageous for obtaining lower energies.)\n\nusing MPSKit: randomize!\n\nnoise_peps = InfinitePEPS(randomize!.(deepcopy(peps.A)))\npeps₀ = peps + 1.0e-1noise_peps\npeps_opt, env_opt, E_opt, = fixedpoint(\n    H, peps₀, env; optimizer_alg = (; tol = 1.0e-4, maxiter = 80)\n);\n\n┌ Warning: the provided real environment was converted to a complex environment since :fixed mode generally produces complex gauges; use :diffgauge mode instead by passing gradient_alg=(; iterscheme=:diffgauge) to the fixedpoint keyword arguments to work with purely real environments\n└ @ PEPSKit ~/Projects/PEPSKit.jl/src/algorithms/optimization/peps_optimization.jl:204\n[ Info: LBFGS: initializing with f = -1.907301302110e+00, ‖∇f‖ = 5.5641e-01\n[ Info: LBFGS: iter    1, Δt 27.08 s: f = -1.912496200062e+00, ‖∇f‖ = 4.8528e-01, α = 1.00e+00, m = 0, nfg = 1\n[ Info: LBFGS: iter    2, Δt 21.55 s: f = -1.939590317765e+00, ‖∇f‖ = 3.1781e-01, α = 1.00e+00, m = 1, nfg = 1\n[ Info: LBFGS: iter    3, Δt 18.59 s: f = -1.948086619481e+00, ‖∇f‖ = 1.8688e-01, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, Δt 17.68 s: f = -1.954903534354e+00, ‖∇f‖ = 1.0567e-01, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    5, Δt 18.51 s: f = -1.958636003807e+00, ‖∇f‖ = 9.6554e-02, α = 1.00e+00, m = 4, nfg = 1\n[ Info: LBFGS: iter    6, Δt 17.87 s: f = -1.961414208875e+00, ‖∇f‖ = 8.8495e-02, α = 1.00e+00, m = 5, nfg = 1\n[ Info: LBFGS: iter    7, Δt 17.70 s: f = -1.963670567806e+00, ‖∇f‖ = 5.9165e-02, α = 1.00e+00, m = 6, nfg = 1\n[ Info: LBFGS: iter    8, Δt 18.26 s: f = -1.965776363520e+00, ‖∇f‖ = 5.0139e-02, α = 1.00e+00, m = 7, nfg = 1\n[ Info: LBFGS: iter    9, Δt 19.99 s: f = -1.967226453690e+00, ‖∇f‖ = 9.2909e-02, α = 1.00e+00, m = 8, nfg = 1\n[ Info: LBFGS: iter   10, Δt 19.12 s: f = -1.968251645234e+00, ‖∇f‖ = 4.4439e-02, α = 1.00e+00, m = 9, nfg = 1\n[ Info: LBFGS: iter   11, Δt 19.63 s: f = -1.969059008087e+00, ‖∇f‖ = 4.6917e-02, α = 1.00e+00, m = 10, nfg = 1\n[ Info: LBFGS: iter   12, Δt 20.27 s: f = -1.969667913862e+00, ‖∇f‖ = 4.8179e-02, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, Δt 20.12 s: f = -1.970804652416e+00, ‖∇f‖ = 3.2505e-02, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, Δt 22.14 s: f = -1.971787694409e+00, ‖∇f‖ = 4.3869e-02, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, Δt 22.25 s: f = -1.972414025039e+00, ‖∇f‖ = 4.0604e-02, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, Δt 21.37 s: f = -1.972867447250e+00, ‖∇f‖ = 2.5133e-02, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, Δt 20.19 s: f = -1.973224221322e+00, ‖∇f‖ = 2.3593e-02, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, Δt 20.15 s: f = -1.973780793633e+00, ‖∇f‖ = 2.7945e-02, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   19, Δt 19.79 s: f = -1.974278639630e+00, ‖∇f‖ = 2.8914e-02, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   20, Δt 18.27 s: f = -1.974533659938e+00, ‖∇f‖ = 1.8380e-02, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   21, Δt 20.24 s: f = -1.974797746482e+00, ‖∇f‖ = 1.5608e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   22, Δt 19.84 s: f = -1.975002265713e+00, ‖∇f‖ = 2.0961e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, Δt 19.23 s: f = -1.975178140945e+00, ‖∇f‖ = 3.4077e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, Δt 18.51 s: f = -1.975348043297e+00, ‖∇f‖ = 1.4875e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, Δt 19.49 s: f = -1.975446214398e+00, ‖∇f‖ = 1.3359e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, Δt 19.63 s: f = -1.975598188521e+00, ‖∇f‖ = 1.5129e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, Δt 18.69 s: f = -1.975648975504e+00, ‖∇f‖ = 4.0666e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, Δt 18.30 s: f = -1.975801502894e+00, ‖∇f‖ = 1.2082e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, Δt 18.04 s: f = -1.975838520962e+00, ‖∇f‖ = 1.0012e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, Δt 19.48 s: f = -1.975920699081e+00, ‖∇f‖ = 1.1497e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, Δt 20.05 s: f = -1.975994476122e+00, ‖∇f‖ = 2.0164e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, Δt 17.66 s: f = -1.976049779798e+00, ‖∇f‖ = 1.2778e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, Δt 18.90 s: f = -1.976083052474e+00, ‖∇f‖ = 8.1251e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, Δt 17.64 s: f = -1.976120284177e+00, ‖∇f‖ = 9.1433e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, Δt 18.21 s: f = -1.976178863096e+00, ‖∇f‖ = 1.2556e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, Δt 18.10 s: f = -1.976225564245e+00, ‖∇f‖ = 1.1295e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, Δt 17.97 s: f = -1.976262568889e+00, ‖∇f‖ = 7.0514e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, Δt 17.80 s: f = -1.976300953764e+00, ‖∇f‖ = 8.6312e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, Δt 18.50 s: f = -1.976337659332e+00, ‖∇f‖ = 1.1092e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, Δt 18.26 s: f = -1.976393924161e+00, ‖∇f‖ = 1.1668e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, Δt 18.35 s: f = -1.976436192483e+00, ‖∇f‖ = 8.0157e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, Δt 17.61 s: f = -1.976469672103e+00, ‖∇f‖ = 7.3417e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, Δt 18.45 s: f = -1.976509489620e+00, ‖∇f‖ = 8.4507e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, Δt 18.35 s: f = -1.976583802578e+00, ‖∇f‖ = 1.3151e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, Δt 19.56 s: f = -1.976630307258e+00, ‖∇f‖ = 1.4170e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   46, Δt 18.29 s: f = -1.976680877868e+00, ‖∇f‖ = 8.3860e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, Δt 19.00 s: f = -1.976710020540e+00, ‖∇f‖ = 1.0325e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, Δt 17.61 s: f = -1.976745581904e+00, ‖∇f‖ = 1.2062e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, Δt 18.88 s: f = -1.976829231643e+00, ‖∇f‖ = 1.2197e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, Δt 18.91 s: f = -1.976899195992e+00, ‖∇f‖ = 1.9229e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   51, Δt 18.74 s: f = -1.976987140901e+00, ‖∇f‖ = 1.8244e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, Δt 16.81 s: f = -1.977023236629e+00, ‖∇f‖ = 8.3070e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, Δt 18.17 s: f = -1.977056164969e+00, ‖∇f‖ = 8.3182e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   54, Δt 17.75 s: f = -1.977123528338e+00, ‖∇f‖ = 1.1023e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, Δt 37.08 s: f = -1.977157909182e+00, ‖∇f‖ = 1.7552e-02, α = 3.55e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   56, Δt 18.66 s: f = -1.977212923858e+00, ‖∇f‖ = 1.1229e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, Δt 18.01 s: f = -1.977268389200e+00, ‖∇f‖ = 7.8373e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, Δt 18.83 s: f = -1.977326972617e+00, ‖∇f‖ = 1.1772e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, Δt 18.11 s: f = -1.977371513954e+00, ‖∇f‖ = 2.0292e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, Δt 18.21 s: f = -1.977420127940e+00, ‖∇f‖ = 1.0167e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, Δt 17.38 s: f = -1.977459871700e+00, ‖∇f‖ = 8.8652e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   62, Δt 18.74 s: f = -1.977507028354e+00, ‖∇f‖ = 8.3742e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, Δt 19.13 s: f = -1.977570888464e+00, ‖∇f‖ = 1.5706e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, Δt 37.04 s: f = -1.977620567166e+00, ‖∇f‖ = 1.0020e-02, α = 4.86e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   65, Δt 19.38 s: f = -1.977658416479e+00, ‖∇f‖ = 8.1197e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, Δt 18.51 s: f = -1.977708104067e+00, ‖∇f‖ = 1.1151e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, Δt 19.21 s: f = -1.977753273984e+00, ‖∇f‖ = 8.6127e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, Δt 21.38 s: f = -1.977756230819e+00, ‖∇f‖ = 1.1803e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, Δt 20.18 s: f = -1.977778298956e+00, ‖∇f‖ = 1.3834e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, Δt 17.39 s: f = -1.977826121915e+00, ‖∇f‖ = 1.0827e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, Δt 19.25 s: f = -1.977853878453e+00, ‖∇f‖ = 9.0049e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, Δt 18.86 s: f = -1.977879275990e+00, ‖∇f‖ = 8.2484e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, Δt 18.96 s: f = -1.977902757838e+00, ‖∇f‖ = 6.2376e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   74, Δt 18.26 s: f = -1.977930234553e+00, ‖∇f‖ = 5.6595e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, Δt 19.82 s: f = -1.977964320717e+00, ‖∇f‖ = 1.1578e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, Δt 18.28 s: f = -1.977994766836e+00, ‖∇f‖ = 7.7846e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, Δt 18.79 s: f = -1.978013673463e+00, ‖∇f‖ = 7.3610e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, Δt 17.63 s: f = -1.978027144104e+00, ‖∇f‖ = 6.3493e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, Δt 18.44 s: f = -1.978044594980e+00, ‖∇f‖ = 7.3623e-03, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 80 iterations and time 33.51 m: f = -1.978065459455e+00, ‖∇f‖ = 5.8505e-03\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/lbfgs.jl:199\n\n\nFinally, we compare the variationally optimized energy against the reference energy. Indeed, we find that the additional AD-based optimization improves the SU-evolved PEPS and leads to a more accurate energy estimate.\n\nE_opt /= (Nr * Nc)\n@show E_opt\n@show (E_opt - E_ref) / abs(E_ref);\n\nE_opt = -0.49451636486378536\n(E_opt - E_ref) / abs(E_ref) = -0.0005389273925854121\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/bose_hubbard/","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/bose_hubbard/#Optimizing-the-U(1)-symmetric-Bose-Hubbard-model","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Optimizing the U(1)-symmetric Bose-Hubbard model","text":"This example demonstrates the simulation of the two-dimensional Bose-Hubbard model. In particular, the point will be to showcase the use of internal symmetries and finite particle densities in PEPS ground state searches. As we will see, incorporating symmetries into the simulation consists of initializing a symmetric Hamiltonian, PEPS state and CTM environment - made possible through TensorKit.\n\nBut first let's seed the RNG and import the required modules:\n\nusing Random\nusing TensorKit, PEPSKit\nusing MPSKit: add_physical_charge\nRandom.seed!(2928528935);","category":"section"},{"location":"examples/bose_hubbard/#Defining-the-model","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Defining the model","text":"We will construct the Bose-Hubbard model Hamiltonian through the bose_hubbard_model, function from MPSKitModels as reexported by PEPSKit. We'll simulate the model in its Mott-insulating phase where the ratio Ut is large, since in this phase we expect the ground state to be well approximated by a PEPS with a manifest global U(1) symmetry. Furthermore, we'll impose a cutoff at 2 bosons per site, set the chemical potential to zero and use a simple 1 times 1 unit cell:\n\nt = 1.0\nU = 30.0\ncutoff = 2\nmu = 0.0\nlattice = InfiniteSquare(1, 1);\n\nNext, we impose an explicit global U(1) symmetry as well as a fixed particle number density in our simulations. We can do this by setting the symmetry argument of the Hamiltonian constructor to U1Irrep and passing one as the particle number density keyword argument n:\n\nsymmetry = U1Irrep\nn = 1\nH = bose_hubbard_model(ComplexF64, symmetry, lattice; cutoff, t, U, n);\n\nBefore we continue, it might be interesting to inspect the corresponding lattice physical spaces (which is here just a 1 times 1 matrix due to the single-site unit cell):\n\nphysical_spaces = physicalspace(H)\n\n1×1 Matrix{TensorKit.GradedSpace{TensorKitSectors.U1Irrep, TensorKit.SortedVectorDict{TensorKitSectors.U1Irrep, Int64}}}:\n (0 => 1, 1 => 1, -1 => 1)\n\nNote that the physical space contains U(1) charges -1, 0 and +1. Indeed, imposing a particle number density of +1 corresponds to shifting the physical charges by -1 to 're-center' the physical charges around the desired density. When we do this with a cutoff of two bosons per site, i.e. starting from U(1) charges 0, 1 and 2 on the physical level, we indeed get the observed charges.","category":"section"},{"location":"examples/bose_hubbard/#Characterizing-the-virtual-spaces","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Characterizing the virtual spaces","text":"When running PEPS simulations with explicit internal symmetries, specifying the structure of the virtual spaces of the PEPS and its environment becomes a bit more involved. For the environment, one could in principle allow the virtual space to be chosen dynamically during the boundary contraction using CTMRG by using a truncation scheme that allows for this (e.g. using alg=:truncrank or alg=:trunctol to truncate to a fixed total bond dimension or singular value cutoff respectively). For the PEPS virtual space however, the structure has to be specified before the optimization.\n\nWhile there are a host of techniques to do this in an informed way (e.g. starting from a simple update result), here we just specify the virtual space manually. Since we're dealing with a model at unit filling our physical space only contains integer U(1) irreps. Therefore, we'll build our PEPS and environment spaces using integer U(1) irreps centered around the zero charge:\n\nV_peps = U1Space(0 => 2, 1 => 1, -1 => 1)\nV_env = U1Space(0 => 6, 1 => 4, -1 => 4, 2 => 2, -2 => 2);","category":"section"},{"location":"examples/bose_hubbard/#Finding-the-ground-state","page":"Optimizing the U(1)-symmetric Bose-Hubbard model","title":"Finding the ground state","text":"Having defined our Hamiltonian and spaces, it is just a matter of plugging this into the optimization framework in the usual way to find the ground state. So, we first specify all algorithms and their tolerances:\n\nboundary_alg = (; tol = 1.0e-8, alg = :simultaneous, trunc = (; alg = :fixedspace))\ngradient_alg = (; tol = 1.0e-6, maxiter = 10, alg = :eigsolver, iterscheme = :diffgauge)\noptimizer_alg = (; tol = 1.0e-4, alg = :lbfgs, maxiter = 150, ls_maxiter = 2, ls_maxfg = 2);\n\nnote: Note\nTaking CTMRG gradients and optimizing symmetric tensors tends to be more problematic than with dense tensors. In particular, this means that one frequently needs to tweak the boundary_alg, gradient_alg and optimizer_alg settings. There rarely is a general-purpose set of settings which will always work, so instead one has to adjust the simulation settings for each specific application. For example, it might help to switch between the CTMRG flavors alg=:simultaneous and alg=:sequential to improve convergence. The evaluation of the CTMRG gradient can be instable, so there it is advised to try the different iterscheme=:diffgauge and iterscheme=:fixed schemes as well as different alg keywords. Of course the tolerances of the algorithms and their subalgorithms also have to be compatible. For more details on the available options, see the fixedpoint docstring.\n\nKeep in mind that the PEPS is constructed from a unit cell of spaces, so we have to make a matrix of V_peps spaces:\n\nvirtual_spaces = fill(V_peps, size(lattice)...)\npeps₀ = InfinitePEPS(randn, ComplexF64, physical_spaces, virtual_spaces)\nenv₀, = leading_boundary(CTMRGEnv(peps₀, V_env), peps₀; boundary_alg...);\n\n[ Info: CTMRG init:\tobj = +1.693461429863e+00 +8.390974048721e-02im\terr = 1.0000e+00\n[ Info: CTMRG conv 19:\tobj = +1.181834754305e+01 -1.514938309052e-11im\terr = 3.6943029323e-09\ttime = 11.53 sec\n\n\nAnd at last, we optimize (which might take a bit):\n\npeps, env, E, info = fixedpoint(\n    H, peps₀, env₀; boundary_alg, gradient_alg, optimizer_alg, verbosity = 3\n)\n@show E;\n\n[ Info: LBFGS: initializing with f = 9.360531870693e+00, ‖∇f‖ = 1.6944e+01\n[ Info: LBFGS: iter    1, Δt  1.77 m: f = 1.243260264922e-01, ‖∇f‖ = 6.2855e+00, α = 1.56e+02, m = 0, nfg = 7\n┌ Warning: `eigsolve` cotangents sensitive to gauge choice: (|Δgauge| = 1.5631940186722204e-12)\n└ @ KrylovKitChainRulesCoreExt ~/.julia/packages/KrylovKit/ZcdRg/ext/KrylovKitChainRulesCoreExt/eigsolve.jl:212\n[ Info: LBFGS: iter    2, Δt 39.80 s: f = 6.539120686695e-02, ‖∇f‖ = 9.5385e+00, α = 5.34e-01, m = 1, nfg = 2\n[ Info: LBFGS: iter    3, Δt  3.13 s: f = -2.708528946074e-02, ‖∇f‖ = 1.8037e+00, α = 1.00e+00, m = 2, nfg = 1\n[ Info: LBFGS: iter    4, Δt  3.55 s: f = -6.192494042461e-02, ‖∇f‖ = 1.5587e+00, α = 1.00e+00, m = 3, nfg = 1\n[ Info: LBFGS: iter    5, Δt  7.09 s: f = -1.124692496698e-01, ‖∇f‖ = 1.4258e+00, α = 2.19e-01, m = 4, nfg = 2\n┌ Warning: Linesearch not converged after 2 iterations and 3 function evaluations:\n│ α = 3.94e-02, dϕ = -4.49e-01, ϕ - ϕ₀ = -1.84e-02\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/linesearches.jl:148\n[ Info: LBFGS: iter    6, Δt 11.03 s: f = -1.309032710952e-01, ‖∇f‖ = 1.3707e+00, α = 3.94e-02, m = 5, nfg = 3\n┌ Warning: Linesearch not converged after 2 iterations and 4 function evaluations:\n│ α = 2.57e-02, dϕ = -3.20e-01, ϕ - ϕ₀ = -8.38e-03\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/linesearches.jl:148\n[ Info: LBFGS: iter    7, Δt 15.96 s: f = -1.392843682240e-01, ‖∇f‖ = 1.3391e+00, α = 2.57e-02, m = 6, nfg = 4\n┌ Warning: Linesearch not converged after 2 iterations and 4 function evaluations:\n│ α = 2.68e-02, dϕ = -3.37e-01, ϕ - ϕ₀ = -9.18e-03\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/linesearches.jl:148\n[ Info: LBFGS: iter    8, Δt 14.36 s: f = -1.484598935358e-01, ‖∇f‖ = 1.3021e+00, α = 2.68e-02, m = 7, nfg = 4\n┌ Warning: Linesearch not converged after 2 iterations and 3 function evaluations:\n│ α = 3.65e-02, dϕ = -3.92e-01, ϕ - ϕ₀ = -1.48e-02\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/linesearches.jl:148\n[ Info: LBFGS: iter    9, Δt 10.44 s: f = -1.632810531195e-01, ‖∇f‖ = 1.2272e+00, α = 3.65e-02, m = 8, nfg = 3\n┌ Warning: Linesearch not converged after 2 iterations and 3 function evaluations:\n│ α = 2.76e-02, dϕ = -2.97e-01, ϕ - ϕ₀ = -8.38e-03\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/linesearches.jl:148\n[ Info: LBFGS: iter   10, Δt 10.55 s: f = -1.716592494485e-01, ‖∇f‖ = 1.1736e+00, α = 2.76e-02, m = 9, nfg = 3\n[ Info: LBFGS: iter   11, Δt 14.00 s: f = -1.826457590505e-01, ‖∇f‖ = 2.4735e+00, α = 3.85e-01, m = 10, nfg = 4\n[ Info: LBFGS: iter   12, Δt  4.18 s: f = -2.064083431847e-01, ‖∇f‖ = 7.6299e-01, α = 1.00e+00, m = 11, nfg = 1\n[ Info: LBFGS: iter   13, Δt  2.89 s: f = -2.162126950757e-01, ‖∇f‖ = 5.5939e-01, α = 1.00e+00, m = 12, nfg = 1\n[ Info: LBFGS: iter   14, Δt  2.87 s: f = -2.254856786317e-01, ‖∇f‖ = 8.5453e-01, α = 1.00e+00, m = 13, nfg = 1\n[ Info: LBFGS: iter   15, Δt  3.13 s: f = -2.311620542835e-01, ‖∇f‖ = 5.0252e-01, α = 1.00e+00, m = 14, nfg = 1\n[ Info: LBFGS: iter   16, Δt  2.36 s: f = -2.399420522249e-01, ‖∇f‖ = 3.2750e-01, α = 1.00e+00, m = 15, nfg = 1\n[ Info: LBFGS: iter   17, Δt  2.12 s: f = -2.481363618858e-01, ‖∇f‖ = 2.2685e-01, α = 1.00e+00, m = 16, nfg = 1\n[ Info: LBFGS: iter   18, Δt  2.64 s: f = -2.562994698651e-01, ‖∇f‖ = 3.0926e-01, α = 1.00e+00, m = 17, nfg = 1\n[ Info: LBFGS: iter   19, Δt  1.78 s: f = -2.649856856868e-01, ‖∇f‖ = 2.7617e-01, α = 1.00e+00, m = 18, nfg = 1\n[ Info: LBFGS: iter   20, Δt  1.56 s: f = -2.683582580828e-01, ‖∇f‖ = 1.3450e-01, α = 1.00e+00, m = 19, nfg = 1\n[ Info: LBFGS: iter   21, Δt  2.08 s: f = -2.691261600416e-01, ‖∇f‖ = 1.0939e-01, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   22, Δt  1.51 s: f = -2.696623293951e-01, ‖∇f‖ = 9.1215e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   23, Δt  1.54 s: f = -2.702859675414e-01, ‖∇f‖ = 7.9156e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   24, Δt  2.12 s: f = -2.707509817413e-01, ‖∇f‖ = 7.4977e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   25, Δt  1.51 s: f = -2.711576093720e-01, ‖∇f‖ = 6.1069e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   26, Δt  1.55 s: f = -2.715380802075e-01, ‖∇f‖ = 6.7125e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   27, Δt  2.08 s: f = -2.717339606082e-01, ‖∇f‖ = 4.1048e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   28, Δt  1.51 s: f = -2.718487460362e-01, ‖∇f‖ = 3.5424e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   29, Δt  1.55 s: f = -2.722072392974e-01, ‖∇f‖ = 4.0213e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   30, Δt  2.11 s: f = -2.722439668172e-01, ‖∇f‖ = 7.1999e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   31, Δt  1.51 s: f = -2.723699154079e-01, ‖∇f‖ = 2.9087e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   32, Δt  1.50 s: f = -2.724342986384e-01, ‖∇f‖ = 1.7378e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   33, Δt  2.10 s: f = -2.725306249305e-01, ‖∇f‖ = 2.3958e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   34, Δt  1.56 s: f = -2.726223101417e-01, ‖∇f‖ = 2.4508e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   35, Δt  1.50 s: f = -2.727454537974e-01, ‖∇f‖ = 1.6125e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   36, Δt  2.12 s: f = -2.728727321968e-01, ‖∇f‖ = 2.3678e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   37, Δt  1.54 s: f = -2.729237733613e-01, ‖∇f‖ = 2.8241e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   38, Δt  1.55 s: f = -2.729791702466e-01, ‖∇f‖ = 1.7025e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   39, Δt  2.25 s: f = -2.730285586841e-01, ‖∇f‖ = 1.1314e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   40, Δt  1.63 s: f = -2.730488129466e-01, ‖∇f‖ = 9.9527e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   41, Δt  1.54 s: f = -2.730623447009e-01, ‖∇f‖ = 1.2306e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   42, Δt  2.17 s: f = -2.730716419408e-01, ‖∇f‖ = 6.6281e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   43, Δt  1.52 s: f = -2.730778245503e-01, ‖∇f‖ = 6.1449e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   44, Δt  1.51 s: f = -2.730838518419e-01, ‖∇f‖ = 5.1229e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   45, Δt  2.10 s: f = -2.730895662464e-01, ‖∇f‖ = 8.2164e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   46, Δt  1.59 s: f = -2.730958799236e-01, ‖∇f‖ = 8.6062e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   47, Δt  1.57 s: f = -2.731035516065e-01, ‖∇f‖ = 8.4505e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   48, Δt  2.19 s: f = -2.731178809183e-01, ‖∇f‖ = 1.1336e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   49, Δt  1.55 s: f = -2.731261391867e-01, ‖∇f‖ = 1.3382e-02, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   50, Δt  1.48 s: f = -2.731343691618e-01, ‖∇f‖ = 8.2222e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   51, Δt  2.11 s: f = -2.731480054714e-01, ‖∇f‖ = 7.7324e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   52, Δt  1.56 s: f = -2.731587193225e-01, ‖∇f‖ = 8.6622e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   53, Δt  3.73 s: f = -2.731635819333e-01, ‖∇f‖ = 1.1039e-02, α = 3.44e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   54, Δt  1.59 s: f = -2.731716220961e-01, ‖∇f‖ = 4.3834e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   55, Δt  1.50 s: f = -2.731747338371e-01, ‖∇f‖ = 3.3324e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   56, Δt  2.12 s: f = -2.731771231498e-01, ‖∇f‖ = 4.7862e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   57, Δt  1.54 s: f = -2.731790392649e-01, ‖∇f‖ = 4.8080e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   58, Δt  1.52 s: f = -2.731804414997e-01, ‖∇f‖ = 2.1500e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   59, Δt  2.17 s: f = -2.731815373905e-01, ‖∇f‖ = 2.8117e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   60, Δt  1.60 s: f = -2.731826327105e-01, ‖∇f‖ = 4.4664e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   61, Δt  1.51 s: f = -2.731849541596e-01, ‖∇f‖ = 6.1122e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   62, Δt  2.11 s: f = -2.731880740800e-01, ‖∇f‖ = 6.6791e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   63, Δt  1.52 s: f = -2.731902005238e-01, ‖∇f‖ = 6.6581e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   64, Δt  1.53 s: f = -2.731927985872e-01, ‖∇f‖ = 2.4370e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   65, Δt  2.16 s: f = -2.731943262018e-01, ‖∇f‖ = 3.2011e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   66, Δt  1.55 s: f = -2.731957978659e-01, ‖∇f‖ = 4.4978e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   67, Δt  1.54 s: f = -2.731987676894e-01, ‖∇f‖ = 6.3647e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   68, Δt  2.14 s: f = -2.732009902493e-01, ‖∇f‖ = 8.7994e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   69, Δt  1.53 s: f = -2.732045313641e-01, ‖∇f‖ = 3.9474e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   70, Δt  1.52 s: f = -2.732074828919e-01, ‖∇f‖ = 3.8933e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   71, Δt  2.08 s: f = -2.732095999551e-01, ‖∇f‖ = 5.1625e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   72, Δt  1.54 s: f = -2.732137224912e-01, ‖∇f‖ = 5.2307e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   73, Δt  3.60 s: f = -2.732147607346e-01, ‖∇f‖ = 6.8682e-03, α = 2.19e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   74, Δt  1.52 s: f = -2.732175934360e-01, ‖∇f‖ = 3.0811e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   75, Δt  1.46 s: f = -2.732185990605e-01, ‖∇f‖ = 2.0362e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   76, Δt  2.08 s: f = -2.732190483159e-01, ‖∇f‖ = 2.2154e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   77, Δt  1.49 s: f = -2.732193561301e-01, ‖∇f‖ = 1.9100e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   78, Δt  1.46 s: f = -2.732201314365e-01, ‖∇f‖ = 1.7894e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   79, Δt  2.06 s: f = -2.732208329599e-01, ‖∇f‖ = 2.3035e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   80, Δt  1.49 s: f = -2.732213654101e-01, ‖∇f‖ = 3.1563e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   81, Δt  1.47 s: f = -2.732219948849e-01, ‖∇f‖ = 1.6658e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   82, Δt  2.10 s: f = -2.732225315237e-01, ‖∇f‖ = 1.8094e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   83, Δt  1.48 s: f = -2.732233367859e-01, ‖∇f‖ = 2.5051e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   84, Δt  1.46 s: f = -2.732247002697e-01, ‖∇f‖ = 3.3721e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   85, Δt  2.05 s: f = -2.732258314846e-01, ‖∇f‖ = 3.6046e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   86, Δt  1.48 s: f = -2.732269279088e-01, ‖∇f‖ = 1.9356e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   87, Δt  1.46 s: f = -2.732276502460e-01, ‖∇f‖ = 2.0305e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   88, Δt  2.05 s: f = -2.732281742297e-01, ‖∇f‖ = 2.6686e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   89, Δt  1.53 s: f = -2.732291570490e-01, ‖∇f‖ = 3.4663e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   90, Δt  1.52 s: f = -2.732301136721e-01, ‖∇f‖ = 3.8554e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   91, Δt  3.55 s: f = -2.732306714243e-01, ‖∇f‖ = 2.8588e-03, α = 5.17e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   92, Δt  1.49 s: f = -2.732312852356e-01, ‖∇f‖ = 1.4790e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   93, Δt  2.08 s: f = -2.732316922511e-01, ‖∇f‖ = 1.6855e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   94, Δt  1.56 s: f = -2.732320780387e-01, ‖∇f‖ = 2.0239e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   95, Δt  1.49 s: f = -2.732330290872e-01, ‖∇f‖ = 2.4026e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   96, Δt  3.62 s: f = -2.732333807603e-01, ‖∇f‖ = 2.8123e-03, α = 3.38e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter   97, Δt  1.51 s: f = -2.732338653294e-01, ‖∇f‖ = 1.4864e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   98, Δt  2.10 s: f = -2.732342403446e-01, ‖∇f‖ = 1.2667e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter   99, Δt  1.49 s: f = -2.732345680255e-01, ‖∇f‖ = 1.8206e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  100, Δt  1.53 s: f = -2.732352955624e-01, ‖∇f‖ = 2.3087e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  101, Δt  2.12 s: f = -2.732355485420e-01, ‖∇f‖ = 4.8509e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  102, Δt  1.48 s: f = -2.732362652809e-01, ‖∇f‖ = 1.7593e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  103, Δt  1.47 s: f = -2.732365365963e-01, ‖∇f‖ = 1.0574e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  104, Δt  2.07 s: f = -2.732367158285e-01, ‖∇f‖ = 1.3546e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  105, Δt  1.52 s: f = -2.732371359877e-01, ‖∇f‖ = 1.8413e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  106, Δt  1.49 s: f = -2.732380177513e-01, ‖∇f‖ = 1.9804e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  107, Δt  3.59 s: f = -2.732382612440e-01, ‖∇f‖ = 3.4353e-03, α = 1.81e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter  108, Δt  1.48 s: f = -2.732390883236e-01, ‖∇f‖ = 2.1448e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  109, Δt  2.14 s: f = -2.732396898628e-01, ‖∇f‖ = 1.2799e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  110, Δt  1.51 s: f = -2.732401266812e-01, ‖∇f‖ = 1.6453e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  111, Δt  1.46 s: f = -2.732405228514e-01, ‖∇f‖ = 1.9341e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  112, Δt  2.11 s: f = -2.732411475475e-01, ‖∇f‖ = 1.7568e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  113, Δt  3.02 s: f = -2.732415107932e-01, ‖∇f‖ = 2.5606e-03, α = 4.15e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter  114, Δt  2.06 s: f = -2.732420174516e-01, ‖∇f‖ = 1.0164e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  115, Δt  1.50 s: f = -2.732422573578e-01, ‖∇f‖ = 1.2282e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  116, Δt  1.48 s: f = -2.732425209380e-01, ‖∇f‖ = 1.6224e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  117, Δt  2.07 s: f = -2.732428864048e-01, ‖∇f‖ = 2.7709e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  118, Δt  1.49 s: f = -2.732433322047e-01, ‖∇f‖ = 1.4803e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  119, Δt  1.48 s: f = -2.732437270443e-01, ‖∇f‖ = 1.0819e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  120, Δt  2.05 s: f = -2.732439320538e-01, ‖∇f‖ = 1.4563e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  121, Δt  1.52 s: f = -2.732443671345e-01, ‖∇f‖ = 1.6560e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  122, Δt  1.52 s: f = -2.732451061345e-01, ‖∇f‖ = 3.2331e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  123, Δt  2.10 s: f = -2.732459561589e-01, ‖∇f‖ = 1.9674e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  124, Δt  1.53 s: f = -2.732464830731e-01, ‖∇f‖ = 1.5142e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  125, Δt  1.48 s: f = -2.732467057592e-01, ‖∇f‖ = 9.9866e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  126, Δt  2.07 s: f = -2.732469018571e-01, ‖∇f‖ = 1.2486e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  127, Δt  1.53 s: f = -2.732473593602e-01, ‖∇f‖ = 1.6548e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  128, Δt  1.55 s: f = -2.732475911101e-01, ‖∇f‖ = 2.3968e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  129, Δt  2.15 s: f = -2.732478298586e-01, ‖∇f‖ = 8.8893e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  130, Δt  1.56 s: f = -2.732479433206e-01, ‖∇f‖ = 7.8718e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  131, Δt  1.49 s: f = -2.732480328924e-01, ‖∇f‖ = 1.0602e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  132, Δt  2.08 s: f = -2.732483542017e-01, ‖∇f‖ = 1.8891e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  133, Δt  1.56 s: f = -2.732487865904e-01, ‖∇f‖ = 2.5342e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  134, Δt  1.52 s: f = -2.732493436489e-01, ‖∇f‖ = 1.9991e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  135, Δt  2.07 s: f = -2.732498544914e-01, ‖∇f‖ = 1.3038e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  136, Δt  1.52 s: f = -2.732501499793e-01, ‖∇f‖ = 1.7802e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  137, Δt  1.49 s: f = -2.732504109741e-01, ‖∇f‖ = 1.6813e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  138, Δt  2.09 s: f = -2.732508321319e-01, ‖∇f‖ = 2.0211e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  139, Δt  1.53 s: f = -2.732516319156e-01, ‖∇f‖ = 2.3433e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  140, Δt  1.53 s: f = -2.732523608932e-01, ‖∇f‖ = 3.2668e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  141, Δt  2.11 s: f = -2.732531859672e-01, ‖∇f‖ = 1.7859e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  142, Δt  1.54 s: f = -2.732536476701e-01, ‖∇f‖ = 1.3889e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  143, Δt  1.55 s: f = -2.732538445802e-01, ‖∇f‖ = 2.7700e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  144, Δt  2.09 s: f = -2.732541822672e-01, ‖∇f‖ = 1.2978e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  145, Δt  1.50 s: f = -2.732544133083e-01, ‖∇f‖ = 9.2642e-04, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  146, Δt  1.50 s: f = -2.732547253465e-01, ‖∇f‖ = 1.5108e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  147, Δt  2.11 s: f = -2.732549899420e-01, ‖∇f‖ = 1.6387e-03, α = 1.00e+00, m = 20, nfg = 1\n[ Info: LBFGS: iter  148, Δt  3.12 s: f = -2.732551982409e-01, ‖∇f‖ = 1.3520e-03, α = 5.44e-01, m = 20, nfg = 2\n[ Info: LBFGS: iter  149, Δt  2.12 s: f = -2.732554318758e-01, ‖∇f‖ = 6.9278e-04, α = 1.00e+00, m = 20, nfg = 1\n┌ Warning: LBFGS: not converged to requested tol after 150 iterations and time 14.76 m: f = -2.732557334552e-01, ‖∇f‖ = 1.4594e-03\n└ @ OptimKit ~/.julia/packages/OptimKit/dRsBo/src/lbfgs.jl:199\nE = -0.273255733455233\n\n\nWe can compare our PEPS result to the energy obtained using a cylinder-MPS calculation using a cylinder circumference of L_y = 7 and a bond dimension of 446, which yields E = -0273284888:\n\nE_ref = -0.273284888\n@show (E - E_ref) / E_ref;\n\n(E - E_ref) / E_ref = -0.00010668187685147442\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/hubbard_su/","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"(Image: ) (Image: ) (Image: )","category":"section"},{"location":"examples/hubbard_su/#Simple-update-for-the-Fermi-Hubbard-model-at-half-filling","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Simple update for the Fermi-Hubbard model at half-filling","text":"Once again, we consider the Hubbard model but this time we obtain the ground-state PEPS by imaginary time evolution. In particular, we'll use the SimpleUpdate algorithm. As a reminder, we define the Hubbard model as\n\nH = -t sum_langle ij rangle sum_sigma left( c_isigma^+ c_jsigma^- -\nc_isigma^- c_jsigma^+ right) + U sum_i n_iuparrown_idownarrow - mu sum_i n_i\n\nwith sigma in uparrowdownarrow and n_isigma = c_isigma^+ c_isigma^-.\n\nLet's get started by seeding the RNG and importing the required modules:\n\nusing Random\nusing TensorKit, PEPSKit\nRandom.seed!(12329348592498);","category":"section"},{"location":"examples/hubbard_su/#Defining-the-Hamiltonian","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Defining the Hamiltonian","text":"First, we define the Hubbard model at t=1 hopping and U=6 using Trivial sectors for the particle and spin symmetries, and set mu = U2 for half-filling. The model will be constructed on a 2 times 2 unit cell, so we have:\n\nt = 1\nU = 6\nNr, Nc = 2, 2\nH = hubbard_model(Float64, Trivial, Trivial, InfiniteSquare(Nr, Nc); t, U, mu = U / 2);\nphysical_space = Vect[fℤ₂](0 => 2, 1 => 2);","category":"section"},{"location":"examples/hubbard_su/#Running-the-simple-update-algorithm","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Running the simple update algorithm","text":"Suppose the goal is to use imaginary-time simple update to optimize a PEPS with bond dimension D = 8, and 2 times 2 unit cells. For a challenging model like the Hubbard model, a naive evolution starting from a random PEPS at D = 8 will almost always produce a sub-optimal state. In this example, we shall demonstrate some common practices to improve SU result.\n\nFirst, we shall use a small D for the random PEPS initialization, which is chosen as 4 here. For convenience, here we work with real tensors with Float64 entries. The bond weights are still initialized as identity matrices.\n\nvirtual_space = Vect[fℤ₂](0 => 2, 1 => 2)\npeps = InfinitePEPS(rand, Float64, physical_space, virtual_space; unitcell = (Nr, Nc));\nwts = SUWeight(peps);\n\nStarting from the random state, we first use a relatively large evolution time step dt = 1e-2. After convergence at D = 4, to avoid stucking at some bad local minimum, we first increase D to 12, and drop it back to D = 8 after a while. Afterwards, we keep D = 8 and gradually decrease dt to 1e-4 to improve convergence.\n\ndts = [1.0e-2, 1.0e-2, 1.0e-3, 4.0e-4, 1.0e-4]\ntols = [1.0e-7, 1.0e-7, 1.0e-8, 1.0e-8, 1.0e-8]\nDs = [4, 12, 8, 8, 8]\nmaxiter = 20000\n\nfor (dt, tol, Dbond) in zip(dts, tols, Ds)\n    trunc = truncerror(; atol = 1.0e-10) & truncrank(Dbond)\n    alg = SimpleUpdate(; trunc, bipartite = false)\n    global peps, wts, = time_evolve(peps, H, dt, maxiter, alg, wts; tol, check_interval = 2000)\nend\n\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 2, 1 => 2)\n[ Info: SU iter 1      : dt = 0.01, |Δλ| = 1.316e+00. Time = 21.601 s/it\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 2, 1 => 2)\n[ Info: SU iter 1045   : dt = 0.01, |Δλ| = 9.843e-08. Time = 0.012 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 35.64 s\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 6, 1 => 6)\n[ Info: SU iter 1      : dt = 0.01, |Δλ| = 6.459e-06. Time = 0.134 s/it\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 6, 1 => 6)\n[ Info: SU iter 584    : dt = 0.01, |Δλ| = 9.946e-08. Time = 0.114 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 71.51 s\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 3, 1 => 5)\n[ Info: SU iter 1      : dt = 0.001, |Δλ| = 5.245e-03. Time = 0.373 s/it\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 3, 1 => 5)\n[ Info: SU iter 2000   : dt = 0.001, |Δλ| = 1.418e-07. Time = 0.037 s/it\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 3, 1 => 5)\n[ Info: SU iter 3791   : dt = 0.001, |Δλ| = 9.990e-09. Time = 0.037 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 131.97 s\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 3, 1 => 5)\n[ Info: SU iter 1      : dt = 0.0004, |Δλ| = 3.256e-04. Time = 0.037 s/it\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 3, 1 => 5)\n[ Info: SU iter 2000   : dt = 0.0004, |Δλ| = 1.888e-08. Time = 0.037 s/it\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 3, 1 => 5)\n[ Info: SU iter 3034   : dt = 0.0004, |Δλ| = 9.997e-09. Time = 0.037 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 105.93 s\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 3, 1 => 5)\n[ Info: SU iter 1      : dt = 0.0001, |Δλ| = 1.627e-04. Time = 0.037 s/it\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 3, 1 => 5)\n[ Info: SU iter 2000   : dt = 0.0001, |Δλ| = 1.532e-08. Time = 0.037 s/it\n[ Info: Space of x-weight at [1, 1] = Vect[FermionParity](0 => 3, 1 => 5)\n[ Info: SU iter 2916   : dt = 0.0001, |Δλ| = 9.997e-09. Time = 0.037 s/it\n[ Info: SU: bond weights have converged.\n[ Info: Simple update finished. Total time elapsed: 100.89 s\n","category":"section"},{"location":"examples/hubbard_su/#Computing-the-ground-state-energy","page":"Simple update for the Fermi-Hubbard model at half-filling","title":"Computing the ground-state energy","text":"In order to compute the energy expectation value with evolved PEPS, we need to converge a CTMRG environment on it. We first converge an environment with a small enviroment dimension, which is initialized using the simple update bond weights. Next we use it to initialize another run with bigger environment dimension. The dynamic adjustment of environment dimension is achieved by using trunc=truncrank(χ) with different χs in the CTMRG runs:\n\nχenv₀, χenv = 6, 16\nenv_space = Vect[fℤ₂](0 => χenv₀ / 2, 1 => χenv₀ / 2)\nnormalize!.(peps.A, Inf)\nenv = CTMRGEnv(wts)\nfor χ in [χenv₀, χenv]\n    global env, = leading_boundary(\n        env, peps; alg = :sequential, tol = 1.0e-8, maxiter = 50, trunc = truncrank(χ)\n    )\nend\n\n[ Info: CTMRG init:\tobj = +3.208695223790e-01\terr = 1.0000e+00\n[ Info: CTMRG conv 7:\tobj = +1.777694992786e+00\terr = 2.2836831592e-09\ttime = 8.64 sec\n[ Info: CTMRG init:\tobj = +1.777694992786e+00\terr = 1.0000e+00\n[ Info: CTMRG conv 7:\tobj = +1.781063096355e+00\terr = 3.5793721430e-10\ttime = 37.81 sec\n\n\nWe measure the energy by computing the H expectation value, where we have to make sure to normalize with respect to the unit cell to obtain the energy per site:\n\nE = expectation_value(peps, H, env) / (Nr * Nc)\n@show E;\n\nE = -3.652497562261351\n\n\nFinally, we can compare the obtained ground-state energy against the literature, namely the QMC estimates from Qin et al.. We find that the results generally agree:\n\nEs_exact = Dict(0 => -1.62, 2 => -0.176, 4 => 0.8603, 6 => -0.6567, 8 => -0.5243)\nE_exact = Es_exact[U] - U / 2\n@show (E - E_exact) / abs(E_exact);\n\n(E - E_exact) / abs(E_exact) = 0.001149243235334783\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#PEPSKit.jl","page":"Home","title":"PEPSKit.jl","text":"Tools for working with projected entangled-pair states\n\nIt contracts, it optimizes, it may break.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package can be installed through the Julia general registry, via the package manager:\n\npkg> add PEPSKit","category":"section"},{"location":"#Key-features","page":"Home","title":"Key features","text":"Construction and manipulation of infinite projected entangled-pair states (PEPS)\nContraction of infinite PEPS using the corner transfer matrix renormalization group (CTMRG) and boundary MPS methods\nNative support for symmetric tensors through TensorKit, including fermionic tensors\nPEPS optimization using automatic differentiation (AD) provided through Zygote\nImaginary time evolution algorithms\nSupport for PEPS with generic unit cells\nSupport for classical 2D partition functions and projected entangled-pair operators (PEPOs)\nExtensible system for custom states, operators and algorithms","category":"section"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"After following the installation process, it should now be possible to load the packages and start simulating. For example, in order to obtain the ground state of the 2D Heisenberg model, we can use the following code:\n\nusing TensorKit, PEPSKit\n\n# construct the Hamiltonian\nH = heisenberg_XYZ(InfiniteSquare())\n\n# configure the parameters\nD = 2\nχ = 20\nctmrg_tol = 1e-10\ngrad_tol = 1e-4\n\n# initialize a PEPS and CTMRG environment\npeps₀ = InfinitePEPS(ComplexSpace(2), ComplexSpace(D))\nenv₀, = leading_boundary(CTMRGEnv(peps₀, ComplexSpace(χ)), peps₀; tol=ctmrg_tol)\n\n# ground state search\npeps, env, E, = fixedpoint(H, peps₀, env₀; tol=grad_tol, boundary_alg=(; tol=ctmrg_tol))\n\n@show E # -0.6625...\n\nFor a more in-depth explanation of this simple example, check the Optimizing the 2D Heisenberg model tutorial or consult the Manual pages.","category":"section"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"A detailed rundown of PEPSKit's features can be found in the Manual section (not yet complete, more coming soon™), including:\n\nPages = [\"man/models.md\", \"man/multithreading.md\", \"man/precompilation.md\"]\nDepth = 1\n\nAdditionally, we provide a list of commented examples in the Examples section which showcases most of PEPSKit's capabilities in action.","category":"section"},{"location":"man/operators/#Operators","page":"Operators","title":"Operators","text":"note: Note\nThis section is still under construction.","category":"section"}]
}
