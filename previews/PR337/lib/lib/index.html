<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · PEPSKit.jl</title><meta name="title" content="Library · PEPSKit.jl"/><meta property="og:title" content="Library · PEPSKit.jl"/><meta property="twitter:title" content="Library · PEPSKit.jl"/><meta name="description" content="Documentation for PEPSKit.jl."/><meta property="og:description" content="Documentation for PEPSKit.jl."/><meta property="twitter:description" content="Documentation for PEPSKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PEPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PEPSKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/models/">Models</a></li><li><a class="tocitem" href="../../man/multithreading/">Multithreading</a></li><li><a class="tocitem" href="../../man/precompilation/">Precompilation using PrecompileTools.jl</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/heisenberg/">Optimizing the 2D Heisenberg model</a></li><li><a class="tocitem" href="../../examples/bose_hubbard/">Optimizing the <span>$U(1)$</span>-symmetric Bose-Hubbard model</a></li><li><a class="tocitem" href="../../examples/xxz/">Néel order in the <span>$U(1)$</span>-symmetric XXZ model</a></li><li><a class="tocitem" href="../../examples/fermi_hubbard/">Fermi-Hubbard model with <span>$f\mathbb{Z}_2 \boxtimes U(1)$</span> symmetry, at large <span>$U$</span> and half-filling</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Time Evolution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/heisenberg_su/">Simple update for the Heisenberg model</a></li><li><a class="tocitem" href="../../examples/hubbard_su/">Simple update for the Fermi-Hubbard model at half-filling</a></li><li><a class="tocitem" href="../../examples/j1j2_su/">Three-site simple update for the <span>$J_1$</span>-<span>$J_2$</span> model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Partition Functions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/2d_ising_partition_function/">The 2D classical Ising model using CTMRG</a></li><li><a class="tocitem" href="../../examples/3d_ising_partition_function/">The 3D classical Ising model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Boundary MPS</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/boundary_mps/">Boundary MPS contractions of 2D networks</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/PEPSKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/master/docs/src/lib/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="PEPSKit.ALSTruncation"><a class="docstring-binding" href="#PEPSKit.ALSTruncation"><code>PEPSKit.ALSTruncation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ALSTruncation</code></pre><p>Algorithm struct for the alternating least square (ALS) optimization of a bond. </p><p><strong>Fields</strong></p><ul><li><p><code>trunc::MatrixAlgebraKit.TruncationStrategy</code></p></li><li><p><code>maxiter::Int64</code></p></li><li><p><code>tol::Float64</code></p></li><li><p><code>check_interval::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ALSTruncation(; kwargs...)</code></pre><p>The truncation algorithm can be constructed from the following keyword arguments:</p><ul><li><code>trunc::TruncationStrategy</code>: SVD truncation strategy when initilizing the truncated tensors connected by the bond.</li><li><code>maxiter::Int=50</code> : Maximal number of ALS iterations.</li><li><code>tol::Float64=1e-9</code> : ALS converges when the relative change in bond SVD spectrum between two iterations is smaller than <code>tol</code>.</li><li><code>check_interval::Int=0</code> : Set number of iterations to print information. Output is suppressed when <code>check_interval &lt;= 0</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/truncation/bond_truncation.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.BPEnv"><a class="docstring-binding" href="#PEPSKit.BPEnv"><code>PEPSKit.BPEnv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BPEnv{T}</code></pre><p>Belief propagation (BP) environment for a square lattice norm network,  containing a 4 x rows x cols array of message tensors, defined for  each <em>oriented</em> nearest neighbor bond in the network. </p><p>The message tensors connect to the network tensors  <code>P</code> at site <code>[r,c]</code> in the unit cell as:</p><pre><code class="language-julia hljs">                    m[1,r-1,c]
                    |
    m[4,r,c-1]------P[r,c]------m[2,r,c+1]
                    |
                    m[3,r+1,c]</code></pre><ul><li><code>[1,r-1,c]</code>: message from <code>P[r-1,c]</code> to <code>P[r,c]</code> (axis order: ket ← bra)</li><li><code>[2,r,c+1]</code>: message from <code>P[r,c+1]</code> to <code>P[r,c]</code> (axis order: ket ← bra)</li><li><code>[3,r+1,c]</code>: message from <code>P[r+1,c]</code> to <code>P[r,c]</code> (axis order: bra ← ket)</li><li><code>[4,r,c-1]</code>: message from <code>P[r,c-1]</code> to <code>P[r,c]</code> (axis order: bra ← ket)</li></ul><p><strong>Fields</strong></p><ul><li><code>messages::Array{T, 3} where T</code>: 4 x rows x cols array of message tensors, where the first dimension specifies the spatial direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/bp_environments.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.BPEnv-Tuple{Any, Any, InfiniteSquareNetwork}"><a class="docstring-binding" href="#PEPSKit.BPEnv-Tuple{Any, Any, InfiniteSquareNetwork}"><code>PEPSKit.BPEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BPEnv([f=randn, T=ComplexF64], network::InfiniteSquareNetwork; posdef::Bool = true)</code></pre><p>Construct a BP environment by specifying a corresponding <a href="#PEPSKit.InfiniteSquareNetwork"><code>InfiniteSquareNetwork</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/bp_environments.jl#L120-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.BPEnv-Tuple{SUWeight}"><a class="docstring-binding" href="#PEPSKit.BPEnv-Tuple{SUWeight}"><code>PEPSKit.BPEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BPEnv(wts::SUWeight)</code></pre><p>Convert fixed point weights <code>wts</code> of trivial simple update to a belief propagation environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/bp/gaugefix.jl#L126-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.BPEnv-Union{Tuple{A}, Tuple{A, A}} where A&lt;:(AbstractMatrix{&lt;:TensorKit.ProductSpace})"><a class="docstring-binding" href="#PEPSKit.BPEnv-Union{Tuple{A}, Tuple{A, A}} where A&lt;:(AbstractMatrix{&lt;:TensorKit.ProductSpace})"><code>PEPSKit.BPEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BPEnv(
    [f=randn, T=ComplexF64], Ds_north::A, Ds_east::A; posdef::Bool = true
) where {A &lt;: AbstractMatrix{&lt;:ProductSpace}}</code></pre><p>Construct a BP environment by specifying matrices of north and east virtual spaces of the corresponding <a href="#PEPSKit.InfiniteSquareNetwork"><code>InfiniteSquareNetwork</code></a>. Each matrix entry corresponds to a site in the unit cell.</p><p>When <code>posdef</code> is true, all messages will be made semi-positive definite (when interpreted as a <code>bra ← ket</code> TensorMap).</p><p>Each entry of the <code>Ds_north</code> and <code>Ds_east</code> matrices corresponds to an effective local space of the network, and can be represented as a <code>ProductSpace</code> (e.g. for the case of a network representing overlaps of PEPSs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/bp_environments.jl#L52-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.BPEnv-Union{Tuple{P}, Tuple{P, P}} where P&lt;:TensorKit.ProductSpace"><a class="docstring-binding" href="#PEPSKit.BPEnv-Union{Tuple{P}, Tuple{P, P}} where P&lt;:TensorKit.ProductSpace"><code>PEPSKit.BPEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BPEnv(
    [f=randn, T=ComplexF64], D_north::P, D_east::P;
    unitcell::Tuple{Int, Int} = (1, 1), posdef::Bool = true
) where {P &lt;: ProductSpace}</code></pre><p>Construct a BP environment by specifying the north and east virtual spaces of the corresponding <a href="#PEPSKit.InfiniteSquareNetwork"><code>InfiniteSquareNetwork</code></a>. The network unit cell can be specified by the <code>unitcell</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/bp_environments.jl#L97-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.BPGauge"><a class="docstring-binding" href="#PEPSKit.BPGauge"><code>PEPSKit.BPGauge</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BPGauge</code></pre><p>Algorithm for gauging PEPS with belief propagation fixed point messages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/bp/gaugefix.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.BeliefPropagation"><a class="docstring-binding" href="#PEPSKit.BeliefPropagation"><code>PEPSKit.BeliefPropagation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BeliefPropagation</code></pre><p>Algorithm for computing the belief propagation fixed point messages.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: Stopping criterion for the BP iterations in relative trace norm difference</p></li><li><p><code>miniter::Int64</code>: Minimal number of BP iterations</p></li><li><p><code>maxiter::Int64</code>: Maximal number of BP iterations</p></li><li><p><code>project_hermitian::Bool</code>: Toggle for projecting messages onto the hermitian subspace immediately after update through BP equation</p></li><li><p><code>bipartite::Bool</code>: When true, preserve bipartite structure of BPEnv inherited from input network</p></li><li><p><code>verbosity::Int64</code>: Output verbosity level</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/bp/beliefpropagation.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.C4vCTMRG"><a class="docstring-binding" href="#PEPSKit.C4vCTMRG"><code>PEPSKit.C4vCTMRG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct C4vCTMRG{P&lt;:PEPSKit.ProjectorAlgorithm} &lt;: PEPSKit.CTMRGAlgorithm</code></pre><p>CTMRG algorithm assuming a C₄ᵥ-symmetric PEPS, i.e. invariance under 90° spatial rotation and Hermitian reflection. This requires a single-site unit cell. The projector is obtained from <code>eigh</code> decomposing the Hermitian enlarged corner.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code></p></li><li><p><code>maxiter::Int64</code></p></li><li><p><code>miniter::Int64</code></p></li><li><p><code>verbosity::Int64</code></p></li><li><p><code>projector_alg::PEPSKit.ProjectorAlgorithm</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">C4vCTMRG(; kwargs...)</code></pre><p>Construct a C₄ᵥ CTMRG algorithm struct based on keyword arguments. For a full description, see <a href="#MPSKit.leading_boundary-Tuple{Any, Any, Any}"><code>leading_boundary</code></a>. The supported keywords are:</p><ul><li><code>tol::Real=1.0e-8</code></li><li><code>maxiter::Int=100</code></li><li><code>miniter::Int=4</code></li><li><code>verbosity::Int=2</code></li><li><code>trunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)</code></li><li><code>decomposition_alg::Union{&lt;:EighAdjoint,NamedTuple}</code></li><li><code>projector_alg::Symbol=:c4v_eigh</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/c4v.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.C4vEighProjector"><a class="docstring-binding" href="#PEPSKit.C4vEighProjector"><code>PEPSKit.C4vEighProjector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct C4vEighProjector{S&lt;:EighAdjoint, T} &lt;: PEPSKit.ProjectorAlgorithm</code></pre><p>Projector algorithm implementing the <code>eigh</code> decomposition of a Hermitian enlarged corner.</p><p><strong>Fields</strong></p><ul><li><p><code>decomposition_alg::EighAdjoint</code></p></li><li><p><code>trunc::Any</code></p></li><li><p><code>verbosity::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">C4vEighProjector(; kwargs...)</code></pre><p>Construct the C₄ᵥ <code>eigh</code>-based projector algorithm based on the following keyword arguments:</p><ul><li><code>decomposition_alg::Union{&lt;:EighAdjoint,NamedTuple}=EighAdjoint()</code> : <code>eigh</code> algorithm including the reverse rule. See <a href="#PEPSKit.EighAdjoint"><code>EighAdjoint</code></a>.</li><li><code>trunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)</code> : Truncation strategy for the projector computation, which controls the resulting virtual spaces. Here, <code>alg</code> can be one of the following:<ul><li><code>:fixedspace</code> : Keep virtual spaces fixed during projection</li><li><code>:notrunc</code> : No singular values are truncated and the performed SVDs are exact</li><li><code>:truncerror</code> : Additionally supply error threshold <code>η</code>; truncate to the maximal virtual dimension of <code>η</code></li><li><code>:truncrank</code> : Additionally supply truncation dimension <code>η</code>; truncate such that the 2-norm of the truncated values is smaller than <code>η</code></li><li><code>:truncspace</code> : Additionally supply truncation space <code>η</code>; truncate according to the supplied vector space </li><li><code>:trunctol</code> : Additionally supply singular value cutoff <code>η</code>; truncate such that every retained singular value is larger than <code>η</code></li></ul></li><li><code>verbosity::Int=0</code> : Projector output verbosity which can be:<ol><li>Suppress output information</li><li>Print singular value degeneracy warnings</li></ol></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/c4v.jl#L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.C4vQRProjector"><a class="docstring-binding" href="#PEPSKit.C4vQRProjector"><code>PEPSKit.C4vQRProjector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct C4vQRProjector{S} &lt;: PEPSKit.ProjectorAlgorithm</code></pre><p>Projector algorithm implementing the <code>qr</code> decomposition of a column-enlarged corner.</p><p><strong>Fields</strong></p><ul><li><code>decomposition_alg::Any</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">C4vQRProjector(; kwargs...)</code></pre><p>Construct the C₄ᵥ <code>qr</code>-based projector algorithm based on the following keyword arguments:</p><ul><li><code>decomposition_alg=QRAdjoint()</code> : <code>left_orth</code> algorithm including the reverse rule. See <a href="#PEPSKit.QRAdjoint"><code>QRAdjoint</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/c4v.jl#L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.CTMRGAlgorithm"><a class="docstring-binding" href="#PEPSKit.CTMRGAlgorithm"><code>PEPSKit.CTMRGAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type CTMRGAlgorithm</code></pre><p>Abstract super type for the corner transfer matrix renormalization group (CTMRG) algorithm for contracting infinite PEPS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/ctmrg.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.CTMRGAlgorithm-Tuple{}"><a class="docstring-binding" href="#PEPSKit.CTMRGAlgorithm-Tuple{}"><code>PEPSKit.CTMRGAlgorithm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CTMRGAlgorithm(; kwargs...)</code></pre><p>Keyword argument parser returning the appropriate <code>CTMRGAlgorithm</code> algorithm struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/ctmrg.jl#L11-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.CTMRGEnv"><a class="docstring-binding" href="#PEPSKit.CTMRGEnv"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CTMRGEnv{C, T}</code></pre><p>Corner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.</p><p>Given arrays of corners <code>c</code> and edges <code>t</code>, they connect to the network tensors <code>P</code> at site <code>(r, c)</code> in the unit cell as:</p><pre><code class="language-julia hljs">   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]
   |              |             |
   t[4,r,c-1]-----P[r,c]--------t[2,r,c+1]
   |              |             |
   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]</code></pre><p>Here <code>P</code> represents an effective local constituent tensor. This can either be a single rank-4 tensor, a pair of PEPS tensors, or a stack of PEPS-PEPO-PEPS tensors depending on the network being contracted.</p><p><strong>Fields</strong></p><ul><li><p><code>corners::Array{C, 3} where C</code>: 4 x rows x cols array of corner tensors, where the first dimension specifies the spatial direction</p></li><li><p><code>edges::Array{T, 3} where T</code>: 4 x rows x cols array of edge tensors, where the first dimension specifies the spatial direction</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/ctmrg_environments.jl#L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.CTMRGEnv-Tuple{Any, Any, InfiniteSquareNetwork, Vararg{Any}}"><a class="docstring-binding" href="#PEPSKit.CTMRGEnv-Tuple{Any, Any, InfiniteSquareNetwork, Vararg{Any}}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, T=ComplexF64], network::InfiniteSquareNetwork, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]
) where {A&lt;:Union{AbstractMatrix{&lt;:ElementarySpace}, ElementarySpace}}</code></pre><p>Construct a CTMRG environment by specifying a corresponding <a href="#PEPSKit.InfiniteSquareNetwork"><code>InfiniteSquareNetwork</code></a>, and the north, east, south and west virtual spaces of the environment. The virtual spaces can either be specified as matrices of <code>ElementarySpace</code>s, or as individual <code>ElementarySpace</code>s which are then filled to match the size of the unit cell. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site <code>(r, c)</code>, <code>chis_north[r, c]</code> corresponds to the east space of the north edge tensor, <code>chis_east[r, c]</code> corresponds to the north space of the east edge tensor, <code>chis_south[r, c]</code> corresponds to the east space of the south edge tensor, and <code>chis_west[r, c]</code> corresponds to the north space of the west edge tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/ctmrg_environments.jl#L199-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.CTMRGEnv-Tuple{BPEnv}"><a class="docstring-binding" href="#PEPSKit.CTMRGEnv-Tuple{BPEnv}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CTMRGEnv(bp_env::BPEnv)</code></pre><p>Construct a CTMRG environment with bond dimension χ = 1  from the belief propagation environment <code>bp_env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/bp_environments.jl#L162-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.CTMRGEnv-Tuple{SUWeight}"><a class="docstring-binding" href="#PEPSKit.CTMRGEnv-Tuple{SUWeight}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CTMRGEnv(wts::SUWeight)</code></pre><p>Construct a CTMRG environment with a trivial environment space  (bond dimension χ = 1) from SUWeight <code>wts</code>, which has the same real scalartype as `<code>wts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/suweight.jl#L389-L395">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.CTMRGEnv-Union{Tuple{B}, Tuple{A}, Tuple{Any, Any, A, A, B}, Tuple{Any, Any, A, A, B, B}, Tuple{Any, Any, A, A, B, B, B}, Tuple{Any, Any, A, A, Vararg{B, 4}}} where {A&lt;:(AbstractMatrix{&lt;:TensorKit.ProductSpace}), B&lt;:(AbstractMatrix{&lt;:TensorKit.ElementarySpace})}"><a class="docstring-binding" href="#PEPSKit.CTMRGEnv-Union{Tuple{B}, Tuple{A}, Tuple{Any, Any, A, A, B}, Tuple{Any, Any, A, A, B, B}, Tuple{Any, Any, A, A, B, B, B}, Tuple{Any, Any, A, A, Vararg{B, 4}}} where {A&lt;:(AbstractMatrix{&lt;:TensorKit.ProductSpace}), B&lt;:(AbstractMatrix{&lt;:TensorKit.ElementarySpace})}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, T=ComplexF64], Ds_north::A, Ds_east::A, chis_north::B, [chis_east::B], [chis_south::B], [chis_west::B]
) where {A&lt;:AbstractMatrix{&lt;:VectorSpace}, B&lt;:AbstractMatrix{&lt;:ElementarySpace}}</code></pre><p>Construct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding partition function and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site <code>(r, c)</code>, <code>chis_north[r, c]</code> corresponds to the east space of the north edge tensor, <code>chis_east[r, c]</code> corresponds to the north space of the east edge tensor, <code>chis_south[r, c]</code> corresponds to the east space of the south edge tensor, and <code>chis_west[r, c]</code> corresponds to the north space of the west edge tensor.</p><p>Each entry of the <code>Ds_north</code> and <code>Ds_east</code> matrices corresponds to an effective local space of the partition function, and can be represented as an <code>ElementarySpace</code> (e.g. for the case of a partition function defined in terms of local rank-4 tensors) or a <code>ProductSpace</code> (e.g. for the case of a network representing overlaps of PEPSs and PEPOs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/ctmrg_environments.jl#L62-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{Any, Any, S, S, Vararg{Any}}} where S&lt;:TensorKit.VectorSpace"><a class="docstring-binding" href="#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{Any, Any, S, S, Vararg{Any}}} where S&lt;:TensorKit.VectorSpace"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, T=ComplexF64], D_north::P, D_east::P, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S];
    unitcell::Tuple{Int,Int}=(1, 1),
) where {P&lt;:VectorSpace,S&lt;:ElementarySpace}</code></pre><p>Construct a CTMRG environment by specifying the north and east virtual spaces of the corresponding <a href="#PEPSKit.InfiniteSquareNetwork"><code>InfiniteSquareNetwork</code></a> and the north, east, south and west virtual spaces of the environment. The network unit cell can be specified by the <code>unitcell</code> keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/ctmrg_environments.jl#L165-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ColumnEnlargedCorner"><a class="docstring-binding" href="#PEPSKit.ColumnEnlargedCorner"><code>PEPSKit.ColumnEnlargedCorner</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ColumnEnlargedCorner{TC, TE}</code></pre><p>Column-enlarged CTMRG corner tensor storage.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ColumnEnlargedCorner(env, coordinates)</code></pre><p>Construct a column-enlarged corner with the correct row and column indices  based on the given <code>coordinates</code> which are of the form <code>(dir, row, col)</code>.</p><pre><code class="language-julia hljs">    [NORTHWEST,r,c]         [NORTHEAST,r,c]

        c-1    c                 c     c+1
    r   C₁--←--E₁--←--      --←--E₂--←--C₂  r
        ↓      |                 |      ↑

        ↓      |                 |      ↑
    r   C₄--→--E₃--→--      --→--E₃--→--C₃  r
        c-1    c                 c     c+1

    [SOUTHWEST,r,c]         [SOUTHEAST,r,c]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L301">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.EigSolver"><a class="docstring-binding" href="#PEPSKit.EigSolver"><code>PEPSKit.EigSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EigSolver{F} &lt;: PEPSKit.GradMode{F}</code></pre><p>Gradient mode wrapper around <code>KrylovKit.KrylovAlgorithm</code> for solving the gradient linear problem as an eigenvalue problem.</p><p><strong>Fields</strong></p><ul><li><code>solver_alg::KrylovKit.KrylovAlgorithm</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">EigSolver(; kwargs...)</code></pre><p>Construct the <code>EigSolver</code> algorithm struct based on the following keyword arguments:</p><ul><li><code>tol::Real=1.0e-6</code> : Convergence tolerance of the eigen solver.</li><li><code>maxiter::Int=30</code> : Maximal number of solver iterations.</li><li><code>verbosity::Int=-1</code> : Output information verbosity of the linear solver.</li><li><code>iterscheme::Symbol=:fixed</code> : Style of CTMRG iteration which is being differentiated, which can be:<ul><li><code>:fixed</code> : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges</li><li><code>:diffgauge</code> : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well</li></ul></li><li><code>solver_alg::Union{KrylovKit.KrylovAlgorithm,NamedTuple}=(; alg=:arnoldi</code> : Eigen solver algorithm which, if supplied directly as a <code>KrylovKit.KrylovAlgorithm</code> overrides the above specified <code>tol</code>, <code>maxiter</code> and <code>verbosity</code>. Alternatively, it can be supplied via a <code>NamedTuple</code> where <code>alg</code> can be one of the following:<ul><li><code>:arnoldi</code> : Arnoldi Krylov algorithm, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.Arnoldi"><code>KrylovKit.Arnoldi</code></a> for details</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/fixed_point_differentiation.jl#L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.EighAdjoint"><a class="docstring-binding" href="#PEPSKit.EighAdjoint"><code>PEPSKit.EighAdjoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EighAdjoint{F, R}</code></pre><p>Wrapper for a eigenvalue decomposition algorithm <code>fwd_alg</code> with a defined reverse rule <code>rrule_alg</code>. If <code>isnothing(rrule_alg)</code>, Zygote differentiates the forward call automatically.</p><p><strong>Fields</strong></p><ul><li><p><code>fwd_alg::Any</code></p></li><li><p><code>rrule_alg::Any</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">EighAdjoint(; kwargs...)</code></pre><p>Construct a <code>EighAdjoint</code> algorithm struct based on the following keyword arguments:</p><ul><li><code>fwd_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=qriteration)</code>: Eig algorithm of the forward pass which can either be passed as an <code>Algorithm</code> instance or a <code>NamedTuple</code> where <code>alg</code> is one of the following:<ul><li><code>:qriteration</code> : MatrixAlgebraKit&#39;s <code>LAPACK_QRIteration</code></li><li><code>:bisection</code> : MatrixAlgebraKit&#39;s <code>LAPACK_Bisection</code></li><li><code>:divideandconquer</code> : MatrixAlgebraKit&#39;s <code>LAPACK_DivideAndConquer</code></li><li><code>:multiple</code> : MatrixAlgebraKit&#39;s <code>LAPACK_MultipleRelativelyRobustRepresentations</code></li><li><code>:lanczos</code> : Lanczos algorithm for symmetric/Hermitian matrices, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.Lanczos">KrylovKit docs</a></li><li><code>:blocklanczos</code> : Block version of <code>:lanczos</code> for repeated extremal eigenvalues, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.BlockLanczos">KrylovKit docs</a></li></ul></li><li><code>rrule_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=full)</code>: Reverse-rule algorithm for differentiating the eigenvalue decomposition. Can be supplied by an <code>Algorithm</code> instance directly or as a <code>NamedTuple</code> where <code>alg</code> is one of the following:<ul><li><code>:full</code> : MatrixAlgebraKit&#39;s <code>eigh_pullback!</code> that requires access to the full spectrum</li><li><code>:trunc</code> : MatrixAlgebraKit&#39;s <code>eigh_trunc_pullback!</code> solving a Sylvester equation on the truncated subspace</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/eigh.jl#L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.EnlargedCorner"><a class="docstring-binding" href="#PEPSKit.EnlargedCorner"><code>PEPSKit.EnlargedCorner</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct EnlargedCorner{TC, TE, TA}</code></pre><p>Enlarged CTMRG corner tensor storage.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">EnlargedCorner(network::InfiniteSquareNetwork, env, coordinates)</code></pre><p>Construct an enlarged corner with the correct row and column indices based on the given <code>coordinates</code> which are of the form <code>(dir, row, col)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FixedEig"><a class="docstring-binding" href="#PEPSKit.FixedEig"><code>PEPSKit.FixedEig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FixedEig{Dt, Vt, Dtf, Vtf, It}</code></pre><p>Eigenvalue decomposition struct containing a pre-computed decomposition or even multiple ones. Additionally, it can contain the full untruncated decomposition and the corresponding truncation indices as well. The call to <code>eigh_trunc</code>/<code>eig_trunc</code> just returns the pre-computed D and V. In the reverse pass, the adjoint is computed with these exact D and V and, potentially, the full decompositions if the adjoints require access to them.</p><p><strong>Fields</strong></p><ul><li><p><code>D::Any</code></p></li><li><p><code>V::Any</code></p></li><li><p><code>D_full::Any</code></p></li><li><p><code>V_full::Any</code></p></li><li><p><code>truncation_indices::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/eigh.jl#L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FixedQR"><a class="docstring-binding" href="#PEPSKit.FixedQR"><code>PEPSKit.FixedQR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FixedQR{Qt, Rt}</code></pre><p>QR decomposition struct containing a pre-computed decomposition. Th call to <code>left_orth(!)</code> just returns the precomputed <code>Q</code> and <code>R</code>. In the reverse pass, the adjoint is computed with these exact <code>D</code> and <code>R</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>Q::Any</code></p></li><li><p><code>R::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/qr.jl#L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FixedSVD"><a class="docstring-binding" href="#PEPSKit.FixedSVD"><code>PEPSKit.FixedSVD</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FixedSVD{Ut, St, Vt, Utf, Stf, Vtf, It}</code></pre><p>SVD struct containing a pre-computed decomposition or even multiple ones. Additionally, it can contain the untruncated full decomposition as well. The call to <code>svd_trunc</code> just returns the pre-computed U, S and V. In the reverse pass, the SVD adjoint is computed with these exact U, S, and V and, potentially, the full decompositions if the adjoints needs access to them.</p><p><strong>Fields</strong></p><ul><li><p><code>U::Any</code></p></li><li><p><code>S::Any</code></p></li><li><p><code>V::Any</code></p></li><li><p><code>U_full::Any</code></p></li><li><p><code>S_full::Any</code></p></li><li><p><code>V_full::Any</code></p></li><li><p><code>truncation_indices::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/svd.jl#L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FixedSpaceTruncation"><a class="docstring-binding" href="#PEPSKit.FixedSpaceTruncation"><code>PEPSKit.FixedSpaceTruncation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FixedSpaceTruncation &lt;: MatrixAlgebraKit.TruncationStrategy</code></pre><p>CTMRG specific truncation strategy for <code>svd_trunc</code> which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from <code>TruncationSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/truncation/truncationschemes.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FullEighPullback"><a class="docstring-binding" href="#PEPSKit.FullEighPullback"><code>PEPSKit.FullEighPullback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FullEighPullback</code></pre><p>Eigh reverse-rule algorithm which wraps MatrixAlgebraKit&#39;s <code>eigh_pullback!</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>degeneracy_atol::Real</code></p></li><li><p><code>verbosity::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">FullEighPullback(; kwargs...)</code></pre><p>Construct a <code>FullEighPullback</code> algorithm struct from the following keyword arguments:</p><ul><li><code>verbosity::Int=0</code> : Suppresses all output if <code>≤0</code>, prints gauge dependency warnings if <code>1</code>, and always prints gauge dependency if <code>≥2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/eigh.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FullEnvTruncation"><a class="docstring-binding" href="#PEPSKit.FullEnvTruncation"><code>PEPSKit.FullEnvTruncation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FullEnvTruncation</code></pre><p>Algorithm struct for the full environment truncation (FET).</p><p><strong>Fields</strong></p><ul><li><p><code>trunc::MatrixAlgebraKit.TruncationStrategy</code></p></li><li><p><code>maxiter::Int64</code></p></li><li><p><code>tol::Float64</code></p></li><li><p><code>trunc_init::Bool</code></p></li><li><p><code>check_interval::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">FullEnvTruncation(; kwargs...)</code></pre><p>The truncation algorithm can be constructed from the following keyword arguments:</p><ul><li><code>trunc::TruncationStrategy</code> : SVD truncation strategy when optimizing the new bond matrix.</li><li><code>maxiter::Int=50</code> : Maximal number of FET iterations.</li><li><code>tol::Float64=1e-9</code> : FET converges when the relative change in bond SVD spectrum between two FET iterations is smaller than <code>tol</code>.</li><li><code>trunc_init::Bool=true</code> : Controls whether the initialization of the new bond matrix is obtained from truncated SVD of the old bond matrix. </li><li><code>check_interval::Int=0</code> : Set number of iterations to print information. Output is suppressed when <code>check_interval &lt;= 0</code>. </li></ul><p><strong>References</strong></p><ul><li><a href="../../references/#evenbly_gauge_2018">Glen Evenbly, Phys. Rev. B 98, 085155 (2018)</a>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/truncation/fullenv_truncation.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FullInfiniteEnv"><a class="docstring-binding" href="#PEPSKit.FullInfiniteEnv"><code>PEPSKit.FullInfiniteEnv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FullInfiniteEnv{TC, TE, TA}</code></pre><p>Full-infinite CTMRG environment tensor storage.</p><p><strong>Fields</strong></p><ul><li><p><code>C_1</code></p></li><li><p><code>C_2</code></p></li><li><p><code>C_3</code></p></li><li><p><code>C_4</code></p></li><li><p><code>E_1</code></p></li><li><p><code>E_2</code></p></li><li><p><code>E_3</code></p></li><li><p><code>E_4</code></p></li><li><p><code>E_5</code></p></li><li><p><code>E_6</code></p></li><li><p><code>E_7</code></p></li><li><p><code>E_8</code></p></li><li><p><code>A_1</code></p></li><li><p><code>A_2</code></p></li><li><p><code>A_3</code></p></li><li><p><code>A_4</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">FullInfiniteEnv(
    quadrant1::E, quadrant2::E, quadrant3::E, quadrant4::E
) where {E&lt;:EnlargedCorner}</code></pre><p>Construct sparse full-infinite environment based on four sparse enlarged corners (quadrants).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FullInfiniteEnv-Tuple{Any, Val{false}}"><a class="docstring-binding" href="#PEPSKit.FullInfiniteEnv-Tuple{Any, Val{false}}"><code>PEPSKit.FullInfiniteEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(env::FullInfiniteEnv)(x, ::Val{false}) 
(env::FullInfiniteEnv)(x, ::Val{true})</code></pre><p>Contract full-infinite environment with a vector <code>x</code>, such that the environment acts as a linear map or adjoint linear map on <code>x</code> if <code>Val(true)</code> or <code>Val(false)</code> is passed, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L253-L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FullInfiniteProjector"><a class="docstring-binding" href="#PEPSKit.FullInfiniteProjector"><code>PEPSKit.FullInfiniteProjector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FullInfiniteProjector{S&lt;:SVDAdjoint, T} &lt;: PEPSKit.ProjectorAlgorithm</code></pre><p>Projector algorithm implementing projectors from SVDing the full 4x4 CTMRG environment.</p><p><strong>Fields</strong></p><ul><li><p><code>decomposition_alg::SVDAdjoint</code></p></li><li><p><code>trunc::Any</code></p></li><li><p><code>verbosity::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">FullInfiniteProjector(; kwargs...)</code></pre><p>Construct the full-infinite projector algorithm based on the following keyword arguments:</p><ul><li><code>decomposition_alg::Union{&lt;:SVDAdjoint,NamedTuple}=SVDAdjoint()</code> : SVD algorithm including the reverse rule. See <a href="#PEPSKit.SVDAdjoint"><code>SVDAdjoint</code></a>.</li><li><code>trunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)</code> : Truncation scheme for the projector computation, which controls the resulting virtual spaces. Here, <code>alg</code> can be one of the following:<ul><li><code>:fixedspace</code> : Keep virtual spaces fixed during projection</li><li><code>:notrunc</code> : No singular values are truncated and the performed SVDs are exact</li><li><code>:truncerror</code> : Additionally supply error threshold <code>η</code>; truncate to the maximal virtual dimension of <code>η</code></li><li><code>:truncrank</code> : Additionally supply truncation dimension <code>η</code>; truncate such that the 2-norm of the truncated values is smaller than <code>η</code></li><li><code>:truncspace</code> : Additionally supply truncation space <code>η</code>; truncate according to the supplied vector space </li><li><code>:trunctol</code> : Additionally supply singular value cutoff <code>η</code>; truncate such that every retained singular value is larger than <code>η</code></li></ul></li><li><code>verbosity::Int=0</code> : Projector output verbosity which can be:<ol><li>Suppress output information</li><li>Print singular value degeneracy warnings</li></ol></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/projectors.jl#L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.FullSVDPullback"><a class="docstring-binding" href="#PEPSKit.FullSVDPullback"><code>PEPSKit.FullSVDPullback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FullSVDPullback</code></pre><p>SVD reverse-rule algorithm which wraps MatrixAlgebraKit&#39;s <code>svd_pullback!</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>degeneracy_atol::Real</code></p></li><li><p><code>verbosity::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">FullSVDPullback(; kwargs...)</code></pre><p>Construct a <code>FullSVDPullback</code> algorithm struct from the following keyword arguments:</p><ul><li><code>degeneracy_atol::Real=1.0e-13</code> : Broadening amplitude for smoothing divergent term in SVD derivative in case of (pseudo) degenerate singular values.</li><li><code>verbosity::Int=0</code> : Suppresses all output if <code>≤0</code>, prints gauge dependency warnings if <code>1</code>, and always prints gauge dependency if <code>≥2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/svd.jl#L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.GeomSum"><a class="docstring-binding" href="#PEPSKit.GeomSum"><code>PEPSKit.GeomSum</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct GeomSum{F} &lt;: PEPSKit.GradMode{F}</code></pre><p>Gradient mode for CTMRG using explicit evaluation of the geometric sum.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Real</code></p></li><li><p><code>maxiter::Int64</code></p></li><li><p><code>verbosity::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">GeomSum(; kwargs...)</code></pre><p>Construct the <code>GeomSum</code> algorithm struct based on the following keyword arguments:</p><ul><li><code>tol::Real=1.0e-6</code> : Convergence tolerance for the difference of norms of two consecutive summands in the geometric sum.</li><li><code>maxiter::Int=30</code> : Maximal number of gradient iterations.</li><li><code>verbosity::Int=-1</code> : Output information verbosity that can be one of the following:<ol><li>Suppress output information</li><li>Print convergence warnings</li><li>Information at each gradient iteration</li></ol></li><li><code>iterscheme::Symbol=:fixed</code> : Style of CTMRG iteration which is being differentiated, which can be:<ul><li><code>:fixed</code> : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges</li><li><code>:diffgauge</code> : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/fixed_point_differentiation.jl#L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.GradMode-Tuple{}"><a class="docstring-binding" href="#PEPSKit.GradMode-Tuple{}"><code>PEPSKit.GradMode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GradMode(; kwargs...)</code></pre><p>Keyword argument parser returning the appropriate <code>GradMode</code> algorithm struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/fixed_point_differentiation.jl#L11-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.HalfInfiniteEnv"><a class="docstring-binding" href="#PEPSKit.HalfInfiniteEnv"><code>PEPSKit.HalfInfiniteEnv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct HalfInfiniteEnv{TC, TE, TA}</code></pre><p>Half-infinite CTMRG environment tensor storage.</p><p><strong>Fields</strong></p><ul><li><p><code>C_1</code></p></li><li><p><code>C_2</code></p></li><li><p><code>E_1</code></p></li><li><p><code>E_2</code></p></li><li><p><code>E_3</code></p></li><li><p><code>E_4</code></p></li><li><p><code>A_1</code></p></li><li><p><code>A_2</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HalfInfiniteEnv(quadrant1::EnlargedCorner, quadrant2::EnlargedCorner)</code></pre><p>Construct sparse half-infinite environment based on two sparse enlarged corners (quadrants).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.HalfInfiniteEnv-Tuple{Any, Val{false}}"><a class="docstring-binding" href="#PEPSKit.HalfInfiniteEnv-Tuple{Any, Val{false}}"><code>PEPSKit.HalfInfiniteEnv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(env::HalfInfiniteEnv)(x, ::Val{false}) 
(env::HalfInfiniteEnv)(x, ::Val{true})</code></pre><p>Contract half-infinite environment with a vector <code>x</code>, such that the environment acts as a linear map or adjoint linear map on <code>x</code> if <code>Val(true)</code> or <code>Val(false)</code> is passed, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L157-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.HalfInfiniteProjector"><a class="docstring-binding" href="#PEPSKit.HalfInfiniteProjector"><code>PEPSKit.HalfInfiniteProjector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct HalfInfiniteProjector{S&lt;:SVDAdjoint, T} &lt;: PEPSKit.ProjectorAlgorithm</code></pre><p>Projector algorithm implementing projectors from SVDing the half-infinite CTMRG environment.</p><p><strong>Fields</strong></p><ul><li><p><code>decomposition_alg::SVDAdjoint</code></p></li><li><p><code>trunc::Any</code></p></li><li><p><code>verbosity::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HalfInfiniteProjector(; kwargs...)</code></pre><p>Construct the half-infinite projector algorithm based on the following keyword arguments:</p><ul><li><code>decomposition_alg::Union{&lt;:SVDAdjoint,NamedTuple}=SVDAdjoint()</code> : SVD algorithm including the reverse rule. See <a href="#PEPSKit.SVDAdjoint"><code>SVDAdjoint</code></a>.</li><li><code>trunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)</code> : Truncation strategy for the projector computation, which controls the resulting virtual spaces. Here, <code>alg</code> can be one of the following:<ul><li><code>:fixedspace</code> : Keep virtual spaces fixed during projection</li><li><code>:notrunc</code> : No singular values are truncated and the performed SVDs are exact</li><li><code>:truncerror</code> : Additionally supply error threshold <code>η</code>; truncate to the maximal virtual dimension of <code>η</code></li><li><code>:truncrank</code> : Additionally supply truncation dimension <code>η</code>; truncate such that the 2-norm of the truncated values is smaller than <code>η</code></li><li><code>:truncspace</code> : Additionally supply truncation space <code>η</code>; truncate according to the supplied vector space </li><li><code>:trunctol</code> : Additionally supply singular value cutoff <code>η</code>; truncate such that every retained singular value is larger than <code>η</code></li></ul></li><li><code>verbosity::Int=0</code> : Projector output verbosity which can be:<ol><li>Suppress output information</li><li>Print singular value degeneracy warnings</li></ol></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/projectors.jl#L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPO"><a class="docstring-binding" href="#PEPSKit.InfinitePEPO"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct InfinitePEPO{T&lt;:PEPOTensor}</code></pre><p>Represents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.</p><p><strong>Fields</strong></p><ul><li><code>A::Array{T, 3} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/infinitepepo.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPO-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)"><a class="docstring-binding" href="#PEPSKit.InfinitePEPO-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePEPO(A::PEPOTensor; unitcell=(1, 1, 1))</code></pre><p>Create an InfinitePEPO by specifying a tensor which is repeated across the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/infinitepepo.jl#L86-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)"><a class="docstring-binding" href="#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePEPO(A::AbstractArray{T, 3})</code></pre><p>Allow users to pass in an array of tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/infinitepepo.jl#L34-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A&lt;:(AbstractArray{&lt;:TensorKit.ElementarySpace, 3})"><a class="docstring-binding" href="#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A&lt;:(AbstractArray{&lt;:TensorKit.ElementarySpace, 3})"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePEPO([f=randn, T=ComplexF64,] Pspaces, Nspaces, Espaces)</code></pre><p>Allow users to pass in arrays of spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/infinitepepo.jl#L43-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePEPO([f=randn, T=ComplexF64,] Pspace::S, Nspace::S, [Espace::S]; unitcell=(1,1,1)) where {S&lt;:ElementarySpace}</code></pre><p>Create an InfinitePEPO by specifying its spaces and unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/infinitepepo.jl#L95-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPS"><a class="docstring-binding" href="#PEPSKit.InfinitePEPS"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct InfinitePEPS{T&lt;:PEPSTensor}</code></pre><p>Represents an infinite projected entangled-pair state on a 2D square lattice.</p><p><strong>Fields</strong></p><ul><li><code>A::Matrix{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepeps.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPS-Tuple{AbstractMatrix{&lt;:TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace}}"><a class="docstring-binding" href="#PEPSKit.InfinitePEPS-Tuple{AbstractMatrix{&lt;:TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace}}"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePEPS(A::AbstractMatrix{T})</code></pre><p>Create an <code>InfinitePEPS</code> by specifying a matrix containing the PEPS tensors at each site in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepeps.jl#L32-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPS-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)"><a class="docstring-binding" href="#PEPSKit.InfinitePEPS-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePEPS(A::PEPSTensor; unitcell=(1, 1))</code></pre><p>Create an <code>InfinitePEPS</code> by specifying a tensor and unit cell.</p><p>The unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index <code>[r, c]</code> by one, respectively:</p><pre><code class="language-julia hljs">   |            |          |
---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---
   |            ||         ||
---T[r,c-1]=====AA[r,c]====AA[r,c+1]====
   |            ||         ||
---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==
   |            ||         ||</code></pre><p>The unit cell has periodic boundary conditions, so <code>[r, c]</code> is indexed modulo the size of the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepeps.jl#L69-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPS-Union{Tuple{M}, Tuple{Any, Type{&lt;:Number}, M, M}, Tuple{Any, Type{&lt;:Number}, M, M, M}} where M&lt;:(AbstractMatrix{&lt;:TensorKit.ElementarySpace})"><a class="docstring-binding" href="#PEPSKit.InfinitePEPS-Union{Tuple{M}, Tuple{Any, Type{&lt;:Number}, M, M}, Tuple{Any, Type{&lt;:Number}, M, M, M}} where M&lt;:(AbstractMatrix{&lt;:TensorKit.ElementarySpace})"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePEPS([f=randn, T=ComplexF64,] Pspaces::A, Nspaces::A, [Espaces::A]) where {A&lt;:AbstractMatrix{ElementarySpace}}</code></pre><p>Create an <code>InfinitePEPS</code> by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepeps.jl#L42-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{Any, Type{&lt;:Number}, S, Vararg{Any}}} where S&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{Any, Type{&lt;:Number}, S, Vararg{Any}}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePEPS([f=randn, T=ComplexF64,] Pspace, Nspace, [Espace]; unitcell=(1,1))</code></pre><p>Create an InfinitePEPS by specifying its physical, north and east spaces and unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepeps.jl#L105-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePartitionFunction"><a class="docstring-binding" href="#PEPSKit.InfinitePartitionFunction"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct InfinitePartitionFunction{T&lt;:PartitionFunctionTensor}</code></pre><p>Represents an infinite partition function on a 2D square lattice.</p><p><strong>Fields</strong></p><ul><li><code>A::Matrix{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepartitionfunction.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePartitionFunction-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace)"><a class="docstring-binding" href="#PEPSKit.InfinitePartitionFunction-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePartitionFunction(A; unitcell=(1, 1))</code></pre><p>Create an <code>InfinitePartitionFunction</code> by specifying a tensor and unit cell.</p><p>The unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if partition function tensor or environment tensor, is obtained by shifting the row and column index <code>[r, c]</code> by one, respectively:</p><pre><code class="language-julia hljs">   |            |          |
---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---
   |            |          |
---T[r,c-1]-----AA[r,c]----AA[r,c+1]----
   |            |          |
---T[r+1,c-1]---AA[r+1,c]--AA[r+1,c+1]--
   |            |          |</code></pre><p>The unit cell has periodic boundary conditions, so <code>[r, c]</code> is indexed modulo the size of the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepartitionfunction.jl#L71-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePartitionFunction-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace)"><a class="docstring-binding" href="#PEPSKit.InfinitePartitionFunction-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePartitionFunction(A::AbstractMatrix{T})</code></pre><p>Create an <code>InfinitePartitionFunction</code> by specifying a matrix containing the PEPS tensors at each site in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepartitionfunction.jl#L33-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePartitionFunction-Union{Tuple{M}, Tuple{Any, Any, M}, Tuple{Any, Any, M, M}} where M&lt;:(AbstractMatrix{&lt;:TensorKit.ElementarySpace})"><a class="docstring-binding" href="#PEPSKit.InfinitePartitionFunction-Union{Tuple{M}, Tuple{Any, Any, M}, Tuple{Any, Any, M, M}} where M&lt;:(AbstractMatrix{&lt;:TensorKit.ElementarySpace})"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePartitionFunction(
    [f=randn, T=ComplexF64,] Pspaces::A, Nspaces::A, [Espaces::A]
) where {A&lt;:AbstractMatrix{&lt;:Union{Int,ElementarySpace}}}</code></pre><p>Create an <code>InfinitePartitionFunction</code> by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an <code>Int</code> or an <code>ElementarySpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepartitionfunction.jl#L43-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfinitePartitionFunction-Union{Tuple{S}, Tuple{Any, Any, S}, Tuple{Any, Any, S, S}} where S&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#PEPSKit.InfinitePartitionFunction-Union{Tuple{S}, Tuple{Any, Any, S}, Tuple{Any, Any, S, S}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit.InfinitePartitionFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfinitePartitionFunction(
    [f=randn, T=ComplexF64,] Pspace::S, Nspace::S, [Espace::S]; unitcell=(1,1)
) where {S&lt;:ElementarySpace}</code></pre><p>Create an InfinitePartitionFunction by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via <code>Int</code> or via <code>ElementarySpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepartitionfunction.jl#L97-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfiniteSquare"><a class="docstring-binding" href="#PEPSKit.InfiniteSquare"><code>PEPSKit.InfiniteSquare</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct InfiniteSquare &lt;: MPSKitModels.AbstractLattice{2}</code></pre><p>Infinite square lattice with a unit cell of size <code>(Nrows, Ncols)</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>Nrows::Int64</code></p></li><li><p><code>Ncols::Int64</code></p></li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">InfiniteSquare([Nrows=1, Ncols=1])</code></pre><p>By default, an infinite square with a (1, 1)-unitcell is constructed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/lattices/squarelattice.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfiniteSquareNetwork"><a class="docstring-binding" href="#PEPSKit.InfiniteSquareNetwork"><code>PEPSKit.InfiniteSquareNetwork</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct InfiniteSquareNetwork{O}</code></pre><p>Contractible square network. Wraps a matrix of &#39;rank-4-tensor-like&#39; objects.</p><p><strong>Fields</strong></p><ul><li><code>A::Matrix</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/networks/infinitesquarenetwork.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfiniteTransferPEPO"><a class="docstring-binding" href="#PEPSKit.InfiniteTransferPEPO"><code>PEPSKit.InfiniteTransferPEPO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPO{H,T,O}</code></pre><p>Represents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an <code>InfinitePEPO</code> between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L63-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}"><a class="docstring-binding" href="#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}"><code>PEPSKit.InfiniteTransferPEPO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)</code></pre><p>Constructs a transfer operator corresponding to a single row of a partition function representing the expectation value of <code>O</code> for the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north, after which its <code>row</code>th row from the north is selected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L82-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfiniteTransferPEPS"><a class="docstring-binding" href="#PEPSKit.InfiniteTransferPEPS"><code>PEPSKit.InfiniteTransferPEPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPS{T}</code></pre><p>Represents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L9-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}"><a class="docstring-binding" href="#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}"><code>PEPSKit.InfiniteTransferPEPS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPS(T::InfinitePEPS, dir, row)</code></pre><p>Constructs a transfer operator corresponding to a single row of a partition function representing the norm of the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north, after which its <code>row</code>th row from the north is selected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L25-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.IterEigh"><a class="docstring-binding" href="#PEPSKit.IterEigh"><code>PEPSKit.IterEigh</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct IterEigh</code></pre><p>Iterative eigenvalue solver based on KrylovKit&#39;s <code>eigsolve</code>, adapted to (symmetric) tensors. The number of targeted eigenvalues is set via the <code>truncspace</code> in <code>ProjectorAlg</code>. In particular, this makes it possible to specify the targeted eigenvalues block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative decomposition didn&#39;t converge, the algorithm falls back to a dense <code>eigh</code>/<code>eigh</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>alg::Any</code></p></li><li><p><code>fallback_threshold::Float64</code></p></li><li><p><code>start_vector::Any</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IterEigh(; kwargs...)</code></pre><p>Construct an <code>IterEigh</code> algorithm struct based on the following keyword arguments:</p><ul><li><code>alg=KrylovKit.Lanczos(; tol=1e-14, krylovdim=25)</code> : KrylovKit algorithm struct for iterative eigenvalue decomposition.</li><li><code>fallback_threshold::Float64=Inf</code> : Threshold for <code>howmany / minimum(size(block))</code> above which (if the block is too small) the algorithm falls back to a dense decomposition.</li><li><code>start_vector=random_start_vector</code> : Function providing the initial vector for the iterative algorithm.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/eigh.jl#L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.IterSVD"><a class="docstring-binding" href="#PEPSKit.IterSVD"><code>PEPSKit.IterSVD</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct IterSVD</code></pre><p>Iterative SVD solver based on KrylovKit&#39;s GKL algorithm, adapted to (symmetric) tensors. The number of targeted singular values is set via the <code>truncspace</code> in <code>ProjectorAlg</code>. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn&#39;t converge, the algorithm falls back to a dense SVD.</p><p><strong>Fields</strong></p><ul><li><p><code>alg::KrylovKit.GKL</code></p></li><li><p><code>fallback_threshold::Float64</code></p></li><li><p><code>start_vector::Any</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IterSVD(; kwargs...)</code></pre><p>Construct an <code>IterSVD</code> algorithm struct based on the following keyword arguments:</p><ul><li><code>alg::KrylovKit.GKL=KrylovKit.GKL(; tol=1e-14, krylovdim=25)</code> : GKL algorithm struct for block-wise iterative SVD.</li><li><code>fallback_threshold::Float64=Inf</code> : Threshold for <code>howmany / minimum(size(block))</code> above which (if the block is too small) the algorithm falls back to TensorKit&#39;s dense SVD.</li><li><code>start_vector=random_start_vector</code> : Function providing the initial vector for the iterative SVD algorithm.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/svd.jl#L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.LinSolver"><a class="docstring-binding" href="#PEPSKit.LinSolver"><code>PEPSKit.LinSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct LinSolver{F} &lt;: PEPSKit.GradMode{F}</code></pre><p>Gradient mode wrapper around <code>KrylovKit.LinearSolver</code> for solving the gradient linear problem using iterative solvers.</p><p><strong>Fields</strong></p><ul><li><code>solver_alg::KrylovKit.LinearSolver</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LinSolver(; kwargs...)</code></pre><p>Construct the <code>LinSolver</code> algorithm struct based on the following keyword arguments:</p><ul><li><code>tol::Real=1.0e-6</code> : Convergence tolerance of the linear solver.</li><li><code>maxiter::Int=30</code> : Maximal number of solver iterations.</li><li><code>verbosity::Int=-1</code> : Output information verbosity of the linear solver.</li><li><code>iterscheme::Symbol=:fixed</code> : Style of CTMRG iteration which is being differentiated, which can be:<ul><li><code>:fixed</code> : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges</li><li><code>:diffgauge</code> : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well</li></ul></li><li><code>solver_alg::Union{KrylovKit.LinearSolver,NamedTuple}=(; alg::Symbol=:bicgstab</code> : Linear solver algorithm which, if supplied directly as a <code>KrylovKit.LinearSolver</code> overrides the above specified <code>tol</code>, <code>maxiter</code> and <code>verbosity</code>. Alternatively, it can be supplied via a <code>NamedTuple</code> where <code>alg</code> can be one of the following:<ul><li><code>:gmres</code> : GMRES iterative linear solver, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.GMRES"><code>KrylovKit.GMRES</code></a> for details</li><li><code>:bicgstab</code> : BiCGStab iterative linear solver, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.BiCGStab"><code>KrylovKit.BiCGStab</code></a> for details</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/fixed_point_differentiation.jl#L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.LocalOperator"><a class="docstring-binding" href="#PEPSKit.LocalOperator"><code>PEPSKit.LocalOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct LocalOperator{T&lt;:Tuple, S}</code></pre><p>A sum of local operators acting on a lattice. The lattice is stored as a matrix of vector spaces, and the terms are stored as a tuple of pairs of indices and operators.</p><p><strong>Fields</strong></p><ul><li><code>lattice::Matrix{S}</code>: The lattice on which the operator acts.</li><li><code>terms::T</code>: The terms of the operator, stored as a tuple of pairs of indices and operators.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LocalOperator(lattice::Matrix{S}, terms::Pair...)
LocalOperator{T,S}(lattice::Matrix{S}, terms::T) where {T,S}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lattice = fill(ℂ^2, 1, 1) # single-site unitcell
O1 = LocalOperator(lattice, ((1, 1),) =&gt; σx, ((1, 1), (1, 2)) =&gt; σx ⊗ σx, ((1, 1), (2, 1)) =&gt; σx ⊗ σx)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/localoperator.jl#L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ManualIter"><a class="docstring-binding" href="#PEPSKit.ManualIter"><code>PEPSKit.ManualIter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ManualIter{F} &lt;: PEPSKit.GradMode{F}</code></pre><p>Gradient mode for CTMRG using manual iteration to solve the linear problem.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Real</code></p></li><li><p><code>maxiter::Int64</code></p></li><li><p><code>verbosity::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ManualIter(; kwargs...)</code></pre><p>Construct the <code>ManualIter</code> algorithm struct based on the following keyword arguments:</p><ul><li><code>tol::Real=1.0e-6</code> : Convergence tolerance for the norm difference of two consecutive <code>dx</code> contributions.</li><li><code>maxiter::Int=30</code> : Maximal number of gradient iterations.</li><li><code>verbosity::Int=-1</code> : Output information verbosity that can be one of the following:<ol><li>Suppress output information</li><li>Print convergence warnings</li><li>Information at each gradient iteration</li></ol></li><li><code>iterscheme::Symbol=:fixed</code> : Style of CTMRG iteration which is being differentiated, which can be:<ul><li><code>:fixed</code> : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges</li><li><code>:diffgauge</code> : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/fixed_point_differentiation.jl#L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.MultilineTransferPEPO"><a class="docstring-binding" href="#PEPSKit.MultilineTransferPEPO"><code>PEPSKit.MultilineTransferPEPO</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const MultilineTransferPEPO = MPSKit.Multiline{&lt;:InfiniteTransferPEPO}</code></pre><p>Type that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an <code>InfinitePEPO</code> between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L96-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.MultilineTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any}"><a class="docstring-binding" href="#PEPSKit.MultilineTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any}"><code>PEPSKit.MultilineTransferPEPO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MultilineTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir)</code></pre><p>Construct a multi-row transfer operator corresponding to the partition function representing the expectation value of <code>O</code> for the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L106-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.MultilineTransferPEPS"><a class="docstring-binding" href="#PEPSKit.MultilineTransferPEPS"><code>PEPSKit.MultilineTransferPEPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const MultilineTransferPEPS = MPSKit.Multiline{&lt;:InfiniteTransferPEPS}</code></pre><p>Type that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L37-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.MultilineTransferPEPS-Tuple{InfinitePEPS, Any}"><a class="docstring-binding" href="#PEPSKit.MultilineTransferPEPS-Tuple{InfinitePEPS, Any}"><code>PEPSKit.MultilineTransferPEPS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MultilineTransferPEPS(T::InfinitePEPS, dir)</code></pre><p>Construct a multi-row transfer operator corresponding to the partition function representing the norm of the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L47-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.PEPOTensor"><a class="docstring-binding" href="#PEPSKit.PEPOTensor"><code>PEPSKit.PEPOTensor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const PEPOTensor{S}</code></pre><p>Default type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: <span>$T : P ⊗ P´ ← N ⊗ E ⊗ S ⊗ W$</span>. Here, <span>$P´$</span> and <span>$P$</span> denote the incoming and outgoing physical space respectively, encoding the physical mapping from <span>$P´&#39;$</span> to <span>$P$</span> where <span>$P´&#39;$</span> corresponds to a physical PEPS index. <span>$N$</span>, <span>$E$</span>, <span>$S$</span> and <span>$W$</span> denote the physics, north, east, south and west spaces, respectively.</p><pre><code class="language-julia hljs">        P´ N
        | ╱
        |╱
   W---- ----E
       ╱|
      ╱ |
     S  P</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/networks/tensors.jl#L112-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.PEPSOptimize"><a class="docstring-binding" href="#PEPSKit.PEPSOptimize"><code>PEPSKit.PEPSOptimize</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PEPSOptimize{B, G}</code></pre><p>Algorithm struct for PEPS ground-state optimization using AD. See <a href="#PEPSKit.fixedpoint-Tuple{Any, InfinitePEPS, Any}"><code>fixedpoint</code></a> for details.</p><p><strong>Fields</strong></p><ul><li><p><code>boundary_alg::Any</code></p></li><li><p><code>gradient_alg::Any</code></p></li><li><p><code>optimizer_alg::OptimKit.OptimizationAlgorithm</code></p></li><li><p><code>reuse_env::Bool</code></p></li><li><p><code>symmetrization::Union{Nothing, PEPSKit.SymmetrizationStyle}</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PEPSOptimize(; kwargs...)</code></pre><p>Construct a PEPS optimization algorithm struct based on keyword arguments. For a full description, see <a href="#PEPSKit.fixedpoint-Tuple{Any, InfinitePEPS, Any}"><code>fixedpoint</code></a>. The supported keywords are:</p><ul><li><code>boundary_alg::Union{NamedTuple,&lt;:CTMRGAlgorithm,...}</code></li><li><code>gradient_alg::Union{NamedTuple,Nothing,&lt;:GradMode}</code></li><li><code>optimizer_alg::Union{NamedTuple,&lt;:OptimKit.OptimizationAlgorithm}</code></li><li><code>reuse_env::Bool=true</code></li><li><code>symmetrization::Union{Nothing,SymmetrizationStyle}=nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/peps_optimization.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.PEPSTensor"><a class="docstring-binding" href="#PEPSKit.PEPSTensor"><code>PEPSKit.PEPSTensor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const PEPSTensor{S}</code></pre><p>Default type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: <span>$T : P ← N ⊗ E ⊗ S ⊗ W$</span>. Here, <span>$P$</span> denotes the physical space and <span>$N$</span>, <span>$E$</span>, <span>$S$</span> and <span>$W$</span> denote the north, east, south and west virtual spaces, respectively.</p><pre><code class="language-julia hljs">           N
          ╱
         ╱
   W---- ----E
       ╱|
      ╱ |
     S  P</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/networks/tensors.jl#L61-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.PEPSTensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,
           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S&lt;:Union{Int,ElementarySpace}}</code></pre><p>Construct a PEPS tensor based on the physical, north, east, south and west spaces. The tensor elements are generated based on <code>f</code> and the element type is specified in <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/networks/tensors.jl#L81-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.PEPSWeight"><a class="docstring-binding" href="#PEPSKit.PEPSWeight"><code>PEPSKit.PEPSWeight</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const PEPSWeight</code></pre><p>Default type for PEPS bond weights with 2 virtual indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/suweight.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.PartitionFunctionTensor"><a class="docstring-binding" href="#PEPSKit.PartitionFunctionTensor"><code>PEPSKit.PartitionFunctionTensor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const PartitionFunctionTensor{S}</code></pre><p>Default type for partition function tensors with 4 virtual indices, conventionally ordered as: <span>$T : W ⊗ S ← N ⊗ E$</span>. Here, <span>$N$</span>, <span>$E$</span>, <span>$S$</span> and <span>$W$</span> denote the north, east, south and west spaces, respectively.</p><pre><code class="language-julia hljs">          N
         ╱
        ╱
  W---- ----E
      ╱
     ╱
    S </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/networks/tensors.jl#L5-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.PartitionFunctionTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}} where {T, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.PartitionFunctionTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}} where {T, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.PartitionFunctionTensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PartitionFunctionTensor(f, ::Type{T}, Pspace::S, Nspace::S,
           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S&lt;:Union{Int,ElementarySpace}}</code></pre><p>Construct a PartitionFunctionTensor tensor based on the north, east, west and south spaces. The tensor elements are generated based on <code>f</code> and the element type is specified in <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/networks/tensors.jl#L25-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ProjectorAlgorithm"><a class="docstring-binding" href="#PEPSKit.ProjectorAlgorithm"><code>PEPSKit.ProjectorAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type ProjectorAlgorithm</code></pre><p>Abstract super type for all CTMRG projector algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/projectors.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ProjectorAlgorithm-Tuple{}"><a class="docstring-binding" href="#PEPSKit.ProjectorAlgorithm-Tuple{}"><code>PEPSKit.ProjectorAlgorithm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ProjectorAlgorithm(; kwargs...)</code></pre><p>Keyword argument parser returning the appropriate <code>ProjectorAlgorithm</code> algorithm struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/projectors.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.QRAdjoint"><a class="docstring-binding" href="#PEPSKit.QRAdjoint"><code>PEPSKit.QRAdjoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct QRAdjoint{F, R}</code></pre><p>Wrapper for a QR decomposition algorithm <code>fwd_alg</code> with a defined reverse rule <code>rrule_alg</code>. If <code>isnothing(rrule_alg)</code>, Zygote differentiates the forward call automatically.</p><p><strong>Fields</strong></p><ul><li><p><code>fwd_alg::Any</code></p></li><li><p><code>rrule_alg::Any</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">QRAdjoint(; kwargs...)</code></pre><p>Construct a <code>QRAdjoint</code> algorithm struct based on the following keyword arguments:</p><ul><li><p><code>fwd_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=qr)</code>: Eig algorithm of the forward pass which can either be passed as an <code>Algorithm</code> instance or a <code>NamedTuple</code> where <code>alg</code> is one of the following:</p><ul><li><code>:qr</code> : MatrixAlgebraKit&#39;s <code>LAPACK_HouseholderQR</code></li></ul></li><li><p><code>rrule_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=qr)</code>: Reverse-rule algorithm for differentiating the eigenvalue decomposition. Can be supplied by an <code>Algorithm</code> instance directly or as a <code>NamedTuple</code> where <code>alg</code> is one of the following:</p><ul><li><code>:qr</code> : MatrixAlgebraKit&#39;s <code>qr_pullback</code></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/qr.jl#L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.QRPullback"><a class="docstring-binding" href="#PEPSKit.QRPullback"><code>PEPSKit.QRPullback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct QRPullback</code></pre><p>QR reverse-rule algorithm which wraps MatrixAlgebraKit&#39;s <code>qr_pullback!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/qr.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ReflectDepth"><a class="docstring-binding" href="#PEPSKit.ReflectDepth"><code>PEPSKit.ReflectDepth</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ReflectDepth &lt;: PEPSKit.SymmetrizationStyle</code></pre><p>Reflection symmmetrization along the horizontal axis, such that north and south are mirrored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/symmetrization.jl#L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ReflectWidth"><a class="docstring-binding" href="#PEPSKit.ReflectWidth"><code>PEPSKit.ReflectWidth</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ReflectWidth &lt;: PEPSKit.SymmetrizationStyle</code></pre><p>Reflection symmmetrization along the vertical axis, such that east and west are mirrored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/symmetrization.jl#L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.Rotate"><a class="docstring-binding" href="#PEPSKit.Rotate"><code>PEPSKit.Rotate</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Rotate &lt;: PEPSKit.SymmetrizationStyle</code></pre><p>Rotation symmmetrization leaving the object invariant under π/2 rotations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/symmetrization.jl#L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.RotateReflect"><a class="docstring-binding" href="#PEPSKit.RotateReflect"><code>PEPSKit.RotateReflect</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct RotateReflect &lt;: PEPSKit.SymmetrizationStyle</code></pre><p>Full reflection and rotation symmmetrization, such that reflection along the horizontal and vertical axis as well as π/2 rotations leave the object invariant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/symmetrization.jl#L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SUGauge"><a class="docstring-binding" href="#PEPSKit.SUGauge"><code>PEPSKit.SUGauge</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SUGauge</code></pre><p>Algorithm for fixing gauge of an iPEPS using trivial simple update (with identity gates).</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code>: Stopping criterion for the trivial SU iterations in weight difference</p></li><li><p><code>miniter::Int64</code>: Minimal number of SU iterations</p></li><li><p><code>maxiter::Int64</code>: Maximal number of SU iterations</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/gaugefix_su.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SUState"><a class="docstring-binding" href="#PEPSKit.SUState"><code>PEPSKit.SUState</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Internal state of simple update algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate.jl#L27-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SUWeight"><a class="docstring-binding" href="#PEPSKit.SUWeight"><code>PEPSKit.SUWeight</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SUWeight{E&lt;:PEPSWeight}</code></pre><p>Schmidt bond weights used in simple/cluster update. Each weight is a real and semi-positive definite <code>DiagonalTensorMap</code>, with the same codomain and domain.</p><p>On the square lattice,</p><ul><li><code>wt[1,r,c]</code> is on the x-bond between <code>[r,c]</code> and <code>[r,c+1]</code>;</li><li><code>wt[2,r,c]</code> is on the y-bond between <code>[r,c]</code> and <code>[r-1,c]</code>.</li></ul><p>Axis order of each weight matrix is</p><pre><code class="language-julia hljs">    x-weights:      y-weights:

    1 - x - 2           2
                        |
                        y
                        |
                        1</code></pre><p><strong>Fields</strong></p><ul><li><code>data::Array{E, 3} where E&lt;:(TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S})</code></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SUWeight(wts_mats::AbstractMatrix{E}...) where {E&lt;:PEPSWeight}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/suweight.jl#L8-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SUWeight-Tuple{BPEnv}"><a class="docstring-binding" href="#PEPSKit.SUWeight-Tuple{BPEnv}"><code>PEPSKit.SUWeight</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SUWeight(env::BPEnv)</code></pre><p>Construct <code>SUWeight</code> from belief propagation fixed point environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/bp/gaugefix.jl#L111-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SUWeight-Tuple{InfinitePEPO}"><a class="docstring-binding" href="#PEPSKit.SUWeight-Tuple{InfinitePEPO}"><code>PEPSKit.SUWeight</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SUWeight(pepo::InfinitePEPO)</code></pre><p>Create a trivial <code>SUWeight</code> for a given one-layer InfinitePEPO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/suweight.jl#L100-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SUWeight-Tuple{InfinitePEPS}"><a class="docstring-binding" href="#PEPSKit.SUWeight-Tuple{InfinitePEPS}"><code>PEPSKit.SUWeight</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SUWeight(peps::InfinitePEPS)</code></pre><p>Create a trivial <code>SUWeight</code> for a given InfinitePEPS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/suweight.jl#L89-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SUWeight-Union{Tuple{M}, Tuple{M, M}} where M&lt;:(AbstractMatrix{&lt;:TensorKit.ElementarySpace})"><a class="docstring-binding" href="#PEPSKit.SUWeight-Union{Tuple{M}, Tuple{M, M}} where M&lt;:(AbstractMatrix{&lt;:TensorKit.ElementarySpace})"><code>PEPSKit.SUWeight</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SUWeight(Nspaces::M, [Espaces::M]) where {M&lt;:AbstractMatrix{&lt;:ElementarySpace}}</code></pre><p>Create a trivial <code>SUWeight</code> by specifying the vertical (north) or horizontal (east) virtual bond spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/suweight.jl#L60-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SUWeight-Union{Tuple{S}, Tuple{S, S}} where S&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#PEPSKit.SUWeight-Union{Tuple{S}, Tuple{S, S}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit.SUWeight</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SUWeight(Nspace::S, Espace::S=Nspace; unitcell::Tuple{Int,Int}=(1, 1)) where {S&lt;:ElementarySpace}</code></pre><p>Create a trivial <code>SUWeight</code> by specifying its vertical (north) and horizontal (east)  as <code>ElementarySpace</code>s) and unit cell size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/suweight.jl#L77-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SVDAdjoint"><a class="docstring-binding" href="#PEPSKit.SVDAdjoint"><code>PEPSKit.SVDAdjoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SVDAdjoint{F, R}</code></pre><p>Wrapper for a SVD algorithm <code>fwd_alg</code> with a defined reverse rule <code>rrule_alg</code>. If <code>isnothing(rrule_alg)</code>, Zygote differentiates the forward call automatically.</p><p><strong>Fields</strong></p><ul><li><p><code>fwd_alg::Any</code></p></li><li><p><code>rrule_alg::Any</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SVDAdjoint(; kwargs...)</code></pre><p>Construct a <code>SVDAdjoint</code> algorithm struct based on the following keyword arguments:</p><ul><li><code>fwd_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=sdd)</code>: SVD algorithm of the forward pass which can either be passed as an <code>Algorithm</code> instance or a <code>NamedTuple</code> where <code>alg</code> is one of the following:<ul><li><code>:sdd</code> : MatrixAlgebraKit&#39;s <code>LAPACK_DivideAndConquer</code></li><li><code>:svd</code> : MatrixAlgebraKit&#39;s <code>LAPACK_QRIteration</code></li><li><code>:bisection</code> : MatrixAlgebraKit&#39;s <code>LAPACK_Bisection</code></li><li><code>:jacobi</code> : MatrixAlgebraKit&#39;s <code>LAPACK_Jacobi</code></li><li><code>:iterative</code> : Iterative SVD only computing the specifed number of singular values and vectors, see <a href="#PEPSKit.IterSVD"><code>IterSVD</code></a></li></ul></li><li><code>rrule_alg::Union{Algorithm,NamedTuple}=(; alg::Symbol=full)</code>: Reverse-rule algorithm for differentiating the SVD. Can be supplied by an <code>Algorithm</code> instance directly or as a <code>NamedTuple</code> where <code>alg</code> is one of the following:<ul><li><code>:full</code> : MatrixAlgebraKit&#39;s <code>svd_pullback!</code> that requires access to the full spectrum</li><li><code>:trunc</code> : MatrixAlgebraKit&#39;s <code>svd_trunc_pullback!</code> solving a Sylvester equation on the truncated subspace</li><li><code>:gmres</code> : GMRES iterative linear solver, see the <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.GMRES">KrylovKit docs</a> for details</li><li><code>:bicgstab</code> : BiCGStab iterative linear solver, see the <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.BiCGStab">KrylovKit docs</a> for details</li><li><code>:arnoldi</code> : Arnoldi Krylov algorithm, see the <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.Arnoldi">KrylovKit docs</a> for details</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/svd.jl#L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ScramblingEnvGauge"><a class="docstring-binding" href="#PEPSKit.ScramblingEnvGauge"><code>PEPSKit.ScramblingEnvGauge</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ScramblingEnvGauge</code></pre><p>CTMRG environment gauge fixing algorithm implementing the &quot;general&quot; technique from https://arxiv.org/abs/2311.11894. This works by constructing a transfer matrix consisting of an edge tensor and a random MPS, thus scrambling potential degeneracies, and then performing a QR decomposition to extract the gauge signs. This is adapted accordingly for asymmetric CTMRG algorithms using multi-site unit cell transfer matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/gaugefix.jl#L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ScramblingEnvGaugeC4v"><a class="docstring-binding" href="#PEPSKit.ScramblingEnvGaugeC4v"><code>PEPSKit.ScramblingEnvGaugeC4v</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ScramblingEnvGaugeC4v</code></pre><p>C4v-symmetric equivalent of the <a href="#PEPSKit.ScramblingEnvGauge">ScramblingEnvGauge`</a> environment gauge fixing algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/gaugefix.jl#L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SequentialCTMRG"><a class="docstring-binding" href="#PEPSKit.SequentialCTMRG"><code>PEPSKit.SequentialCTMRG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SequentialCTMRG &lt;: CTMRGAlgorithm</code></pre><p>CTMRG algorithm where the expansions and renormalization is performed sequentially column-wise. This is implemented as a growing and projecting step to the left, followed by a clockwise rotation (performed four times).</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code></p></li><li><p><code>maxiter::Int64</code></p></li><li><p><code>miniter::Int64</code></p></li><li><p><code>verbosity::Int64</code></p></li><li><p><code>projector_alg::PEPSKit.ProjectorAlgorithm</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SequentialCTMRG(; kwargs...)</code></pre><p>Construct a sequential CTMRG algorithm struct based on keyword arguments. For a full description, see <a href="#MPSKit.leading_boundary-Tuple{Any, Any, Any}"><code>leading_boundary</code></a>. The supported keywords are:</p><ul><li><code>tol::Real=1.0e-8</code></li><li><code>maxiter::Int=100</code></li><li><code>miniter::Int=4</code></li><li><code>verbosity::Int=2</code></li><li><code>trunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)</code></li><li><code>decomposition_alg::Union{&lt;:SVDAdjoint,NamedTuple}</code></li><li><code>projector_alg::Symbol=:halfinfinite</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sequential.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SimpleUpdate"><a class="docstring-binding" href="#PEPSKit.SimpleUpdate"><code>PEPSKit.SimpleUpdate</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SimpleUpdate &lt;: PEPSKit.TimeEvolution</code></pre><p>Algorithm struct for simple update (SU) of InfinitePEPS or InfinitePEPO.</p><p><strong>Fields</strong></p><ul><li><p><code>trunc::MatrixAlgebraKit.TruncationStrategy</code>: Truncation strategy for bonds updated by Trotter gates</p></li><li><p><code>imaginary_time::Bool</code>: When true (or false), the Trotter gate is <code>exp(-H dt)</code> (or <code>exp(-iH dt)</code>)</p></li><li><p><code>force_3site::Bool</code>: When true, force the usage of 3-site simple update</p></li><li><p><code>bipartite::Bool</code>: When true, assume bipartite unit cell structure</p></li><li><p><code>purified::Bool</code>: (Only applicable to InfinitePEPO)     When true, the PEPO is regarded as a purified PEPS, and updated as     <code>|ρ(t + dt)⟩ = exp(-H dt/2) |ρ(t)⟩</code>.     When false, the PEPO is updated as     <code>ρ(t + dt) = exp(-H dt/2) ρ(t) exp(-H dt/2)</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.SimultaneousCTMRG"><a class="docstring-binding" href="#PEPSKit.SimultaneousCTMRG"><code>PEPSKit.SimultaneousCTMRG</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SimultaneousCTMRG{P&lt;:PEPSKit.ProjectorAlgorithm} &lt;: PEPSKit.CTMRGAlgorithm</code></pre><p>CTMRG algorithm where all sides are grown and renormalized at the same time. In particular, the projectors are applied to the corners from two sides simultaneously.</p><p><strong>Fields</strong></p><ul><li><p><code>tol::Float64</code></p></li><li><p><code>maxiter::Int64</code></p></li><li><p><code>miniter::Int64</code></p></li><li><p><code>verbosity::Int64</code></p></li><li><p><code>projector_alg::PEPSKit.ProjectorAlgorithm</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SimultaneousCTMRG(; kwargs...)</code></pre><p>Construct a simultaneous CTMRG algorithm struct based on keyword arguments. For a full description, see <a href="#MPSKit.leading_boundary-Tuple{Any, Any, Any}"><code>leading_boundary</code></a>. The supported keywords are:</p><ul><li><code>tol::Real=1.0e-8</code></li><li><code>maxiter::Int=100</code></li><li><code>miniter::Int=4</code></li><li><code>verbosity::Int=2</code></li><li><code>trunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)</code></li><li><code>decomposition_alg::Union{&lt;:SVDAdjoint,NamedTuple}</code></li><li><code>projector_alg::Symbol=:halfinfinite</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/simultaneous.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.TimeEvolution"><a class="docstring-binding" href="#PEPSKit.TimeEvolution"><code>PEPSKit.TimeEvolution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type TimeEvolution</code></pre><p>Abstract super type for time evolution algorithms of InfinitePEPS or InfinitePEPO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/time_evolve.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.TimeEvolver"><a class="docstring-binding" href="#PEPSKit.TimeEvolver"><code>PEPSKit.TimeEvolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct TimeEvolver{TE &lt;: TimeEvolution, G, S, N &lt;: Number}</code></pre><p>Iterator for Trotter-based time evolution of InfinitePEPS or InfinitePEPO.</p><p><strong>Fields</strong></p><ul><li><p><code>alg::PEPSKit.TimeEvolution</code>: Time evolution algorithm (currently supported: <code>SimpleUpdate</code>)</p></li><li><p><code>dt::Number</code>: Trotter time step</p></li><li><p><code>nstep::Int64</code>: The number of iteration steps</p></li><li><p><code>gate::Any</code>: Trotter gates</p></li><li><p><code>state::Any</code>: Internal state of the iterator, including the number of     already performed iterations, evolved time, PEPS/PEPO and its environment</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/time_evolve.jl#L8-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.TimeEvolver-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Number, Int64, SimpleUpdate, SUWeight}"><a class="docstring-binding" href="#PEPSKit.TimeEvolver-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Number, Int64, SimpleUpdate, SUWeight}"><code>PEPSKit.TimeEvolver</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TimeEvolver(
    psi0::InfiniteState, H::LocalOperator, dt::Number, nstep::Int, 
    alg::SimpleUpdate, env0::SUWeight; t0::Number = 0.0
)</code></pre><p>Initialize a TimeEvolver with Hamiltonian <code>H</code> and simple update <code>alg</code>,  starting from the initial state <code>psi0</code> and SUWeight environment <code>env0</code>.</p><ul><li>The initial time is specified by <code>t0</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate.jl#L41-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.TruncEighPullback"><a class="docstring-binding" href="#PEPSKit.TruncEighPullback"><code>PEPSKit.TruncEighPullback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TruncEighPullback</code></pre><p>Truncated eigh reverse-rule algorithm which wraps MatrixAlgebraKit&#39;s <code>eigh_trunc_pullback!</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>degeneracy_atol::Real</code></p></li><li><p><code>verbosity::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">TruncEighPullback(; kwargs...)</code></pre><p>Construct a <code>TruncEighPullback</code> algorithm struct from the following keyword arguments:</p><ul><li><code>verbosity::Int=0</code> : Suppresses all output if <code>≤0</code>, prints gauge dependency warnings if <code>1</code>, and always prints gauge dependency if <code>≥2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/eigh.jl#L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.TruncSVDPullback"><a class="docstring-binding" href="#PEPSKit.TruncSVDPullback"><code>PEPSKit.TruncSVDPullback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct TruncSVDPullback</code></pre><p>SVD reverse-rule algorithm which wraps MatrixAlgebraKit&#39;s <code>svd_trunc_pullback!</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>degeneracy_atol::Real</code></p></li><li><p><code>verbosity::Int64</code></p></li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">TruncSVDPullback(; kwargs...)</code></pre><p>Construct a <code>TruncSVDPullback</code> algorithm struct from the following keyword arguments:</p><ul><li><code>degeneracy_atol::Real=1.0e-13</code> : Broadening amplitude for smoothing divergent term in SVD derivative in case of (pseudo) degenerate singular values.</li><li><code>verbosity::Int=0</code> : Suppresses all output if <code>≤0</code>, prints gauge dependency warnings if <code>1</code>, and always prints gauge dependency if <code>≥2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/svd.jl#L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.TensorMap-Tuple{PEPSKit.ColumnEnlargedCorner}"><a class="docstring-binding" href="#TensorKit.TensorMap-Tuple{PEPSKit.ColumnEnlargedCorner}"><code>TensorKit.TensorMap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TensorMap(Q::ColumnEnlargedCorner)</code></pre><p>Instantiate column-enlarged corner as a <code>TensorMap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L345-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.TensorMap-Tuple{PEPSKit.EnlargedCorner}"><a class="docstring-binding" href="#TensorKit.TensorMap-Tuple{PEPSKit.EnlargedCorner}"><code>TensorKit.TensorMap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TensorMap(Q::EnlargedCorner)</code></pre><p>Instantiate enlarged corner as a <code>TensorMap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L64-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.TensorMap-Tuple{PEPSKit.FullInfiniteEnv}"><a class="docstring-binding" href="#TensorKit.TensorMap-Tuple{PEPSKit.FullInfiniteEnv}"><code>TensorKit.TensorMap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TensorMap(env::FullInfiniteEnv)</code></pre><p>Instantiate full-infinite environment as <code>TensorMap</code> explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L240-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TensorKit.TensorMap-Tuple{PEPSKit.HalfInfiniteEnv}"><a class="docstring-binding" href="#TensorKit.TensorMap-Tuple{PEPSKit.HalfInfiniteEnv}"><code>TensorKit.TensorMap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TensorMap(env::HalfInfiniteEnv)</code></pre><p>Instantiate half-infinite environment as <code>TensorMap</code> explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sparse_environments.jl#L146-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FiniteDifferences.to_vec-Tuple{InfinitePEPS}"><a class="docstring-binding" href="#FiniteDifferences.to_vec-Tuple{InfinitePEPS}"><code>FiniteDifferences.to_vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_vec(A::InfinitePEPS) -&gt; vec, state_from_vec</code></pre><p>Vectorize an <code>InfinitePEPS</code> into a vector of real numbers. A vectorized infinite PEPS can retrieved again as an <code>InfinitePEPS</code> by application of the <code>state_from_vec</code> map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/states/infinitepeps.jl#L232-L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.add_physical_charge-Tuple{LocalOperator, AbstractMatrix{&lt;:TensorKitSectors.Sector}}"><a class="docstring-binding" href="#MPSKit.add_physical_charge-Tuple{LocalOperator, AbstractMatrix{&lt;:TensorKitSectors.Sector}}"><code>MPSKit.add_physical_charge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_physical_charge(H::LocalOperator, charges::AbstractMatrix{&lt;:Sector})</code></pre><p>Change the spaces of a <code>LocalOperator</code> by fusing in an auxiliary charge into the domain of the operator on every site, according to a given matrix of &#39;auxiliary&#39; physical charges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/localoperator.jl#L240-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.correlation_length-Tuple{Any, CTMRGEnv}"><a class="docstring-binding" href="#MPSKit.correlation_length-Tuple{Any, CTMRGEnv}"><code>MPSKit.correlation_length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">correlation_length(state, env::CTMRGEnv; num_vals=2, kwargs...)</code></pre><p>Compute the correlation length associated to <code>state</code> as contracted using the environment <code>env</code>, based on the spectrum of the horizontal and vertical transfer matrices associated to <code>env</code>. Additionally the (normalized) eigenvalue spectrum is returned. The number of computed eigenvalues can be specified using <code>num_vals</code>, and any remaining keyword arguments are passed through to <code>MPSKit.transfer_spectrum</code> (e.g. allowing to target the correlation length in a specific symmetry sector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L274-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.expectation_value-Tuple{Any, Any}"><a class="docstring-binding" href="#MPSKit.expectation_value-Tuple{Any, Any}"><code>MPSKit.expectation_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})
MPSKit.expectation_value(st::MultilineMPS, op::Union{MultilineTransferPEPS,MultilineTransferPEPO})</code></pre><p>Compute expectation value of the transfer operator <code>op</code> for the state <code>st</code> for each site in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L177-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.expectation_value-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Union{InfinitePEPO, InfinitePEPS}, CTMRGEnv}"><a class="docstring-binding" href="#MPSKit.expectation_value-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Union{InfinitePEPO, InfinitePEPS}, CTMRGEnv}"><code>MPSKit.expectation_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expectation_value(state, O::LocalOperator, env::CTMRGEnv)
expectation_value(bra, O::LocalOperator, ket, env::CTMRGEnv)</code></pre><p>Compute the expectation value ⟨bra|O|ket⟩ / ⟨bra|ket⟩ of a <a href="#PEPSKit.LocalOperator"><code>LocalOperator</code></a> <code>O</code>. This can be done either for a PEPS, or alternatively for a density matrix PEPO. In the latter case the first signature corresponds to a single layer PEPO contraction, while the second signature yields a bilayer contraction instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.expectation_value-Union{Tuple{S}, Tuple{T}, Tuple{InfinitePartitionFunction, Pair{CartesianIndex{2}, &lt;:TensorKit.AbstractTensorMap{T, S, 2, 2}}, CTMRGEnv}} where {T, S}"><a class="docstring-binding" href="#MPSKit.expectation_value-Union{Tuple{S}, Tuple{T}, Tuple{InfinitePartitionFunction, Pair{CartesianIndex{2}, &lt;:TensorKit.AbstractTensorMap{T, S, 2, 2}}, CTMRGEnv}} where {T, S}"><code>MPSKit.expectation_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expectation_value(pf::InfinitePartitionFunction, inds =&gt; O, env::CTMRGEnv)</code></pre><p>Compute the expectation value corresponding to inserting a local tensor(s) <code>O</code> at position <code>inds</code> in the partition function <code>pf</code> and contracting the chole using a given CTMRG environment <code>env</code>.</p><p>Here <code>inds</code> can be specified as either a <code>Tuple{Int,Int}</code> or a <code>CartesianIndex{2}</code>, and <code>O</code> should be a rank-4 tensor conforming to the <a href="#PEPSKit.PartitionFunctionTensor"><code>PartitionFunctionTensor</code></a> indexing convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L33-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.leading_boundary-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#MPSKit.leading_boundary-Tuple{Any, Any, Any}"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">leading_boundary(
    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [env]
)
leading_boundary(
    st::MPSMulitline, op::Union{MultilineTransferPEPS,MultilineTransferPEPO}, alg, [env]
)</code></pre><p>Approximate the leading boundary MPS eigenvector for the transfer operator <code>op</code> using <code>st</code> as initial guess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L185-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.leading_boundary-Tuple{BPEnv, InfiniteSquareNetwork, BeliefPropagation}"><a class="docstring-binding" href="#MPSKit.leading_boundary-Tuple{BPEnv, InfiniteSquareNetwork, BeliefPropagation}"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">leading_boundary(env₀::BPEnv, network, alg::BeliefPropagation)</code></pre><p>Contract <code>network</code> in the BP approximation and return the corresponding messages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/bp/beliefpropagation.jl#L30-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.leading_boundary-Tuple{CTMRGEnv, InfiniteSquareNetwork}"><a class="docstring-binding" href="#MPSKit.leading_boundary-Tuple{CTMRGEnv, InfiniteSquareNetwork}"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">leading_boundary(env₀, network; kwargs...) -&gt; env, info
# expert version:
leading_boundary(env₀, network, alg::CTMRGAlgorithm)</code></pre><p>Contract <code>network</code> using CTMRG and return the CTM environment. The algorithm can be supplied via the keyword arguments or directly as an <a href="#PEPSKit.CTMRGAlgorithm"><code>CTMRGAlgorithm</code></a> struct.</p><p><strong>Keyword arguments</strong></p><p><strong>CTMRG iterations</strong></p><ul><li><code>tol::Real=1.0e-8</code> : Stopping criterium for the CTMRG iterations. This is the norm convergence, as well as the distance in singular values of the corners and edges.</li><li><code>miniter::Int=4</code> : Minimal number of CTMRG iterations.</li><li><code>maxiter::Int=100</code> : Maximal number of CTMRG iterations.</li><li><code>verbosity::Int=2</code> : Output verbosity level, should be one of the following:<ol><li>Suppress all output</li><li>Only print warnings</li><li>Initialization and convergence info</li><li>Iteration info</li><li>Debug info</li></ol></li><li><code>alg::Symbol=:simultaneous</code> : Variant of the CTMRG algorithm. See also <a href="#PEPSKit.CTMRGAlgorithm"><code>CTMRGAlgorithm</code></a>.<ul><li><code>:simultaneous</code> : Simultaneous expansion and renormalization of all sides.</li><li><code>:sequential</code> : Sequential application of left moves and rotations.</li><li><code>:c4v</code> : CTMRG assuming C₄ᵥ-symmetric PEPS and environment.</li></ul></li></ul><p><strong>Projector algorithm</strong></p><ul><li><code>trunc::Union{TruncationStrategy,NamedTuple}=(; alg::Symbol=:fixedspace)</code> : Truncation strategy for the projector computation, which controls the resulting virtual spaces. Here, <code>alg</code> can be one of the following:<ul><li><code>:fixedspace</code> : Keep virtual spaces fixed during projection</li><li><code>:notrunc</code> : No singular values are truncated and the performed SVDs are exact</li><li><code>:truncerror</code> : Additionally supply error threshold <code>η</code>; truncate to the maximal virtual dimension of <code>η</code></li><li><code>:truncrank</code> : Additionally supply truncation dimension <code>η</code>; truncate such that the 2-norm of the truncated values is smaller than <code>η</code></li><li><code>:truncspace</code> : Additionally supply truncation space <code>η</code>; truncate according to the supplied vector space </li><li><code>:trunctol</code> : Additionally supply singular value cutoff <code>η</code>; truncate such that every retained singular value is larger than <code>η</code></li></ul></li><li><code>decomposition_alg</code> : Tensor decomposition algorithm for computing projectors. See e.g. <a href="#PEPSKit.SVDAdjoint"><code>SVDAdjoint</code></a>. </li><li><code>projector_alg::Symbol=:halfinfinite</code> : Variant of the projector algorithm. See also <a href="#PEPSKit.ProjectorAlgorithm"><code>ProjectorAlgorithm</code></a>.<ul><li><code>:halfinfinite</code> : Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.</li><li><code>:fullinfinite</code> : Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.</li><li><code>:c4v_eigh</code> : Projection via <code>eigh</code> of the Hermitian enlarged corner, works only for <a href="#PEPSKit.C4vCTMRG"><code>C4vCTMRG</code></a>.</li><li><code>:c4v_qr</code> : Projection via QR decomposition of the lower-rank column-enlarged corner, works only for <a href="#PEPSKit.C4vCTMRG"><code>C4vCTMRG</code></a>.</li></ul></li></ul><p><strong>Return values</strong></p><p>The <code>leading_boundary</code> routine returns the final environment as well as an information <code>NamedTuple</code> that generally contains a <code>convergence_metrics</code> <code>NamedTuple</code> storing different contents depending on the chosen <code>alg</code>. Depending on the contraction method, the information tuple may also contain the final tensor decomposition (used in the projectors) including its truncation indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/ctmrg.jl#L47-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.physicalspace-Tuple{LocalOperator}"><a class="docstring-binding" href="#MPSKit.physicalspace-Tuple{LocalOperator}"><code>MPSKit.physicalspace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">physicalspace(O::LocalOperator)</code></pre><p>Return lattice of physical spaces on which the <code>LocalOperator</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/localoperator.jl#L108-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.time_evolve-Tuple{TimeEvolver{&lt;:SimpleUpdate}}"><a class="docstring-binding" href="#MPSKit.time_evolve-Tuple{TimeEvolver{&lt;:SimpleUpdate}}"><code>MPSKit.time_evolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">time_evolve(
    it::TimeEvolver{&lt;:SimpleUpdate}; 
    tol::Float64 = 0.0, check_interval::Int = 500
) -&gt; (psi, env, info)</code></pre><p>Perform time evolution to the end of TimeEvolver iterator <code>it</code>, or until convergence of SUWeight set by a positive <code>tol</code>.</p><ul><li>Setting <code>tol &gt; 0</code> enables convergence check (for imaginary time evolution of InfinitePEPS only).   For other usages it should not be changed.</li><li><code>check_interval</code> sets the number of iterations between outputs of information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate.jl#L232-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.time_evolve-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Number, Int64, SimpleUpdate, SUWeight}"><a class="docstring-binding" href="#MPSKit.time_evolve-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, Number, Int64, SimpleUpdate, SUWeight}"><code>MPSKit.time_evolve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">time_evolve(
    psi0::Union{InfinitePEPS, InfinitePEPO}, H::LocalOperator, 
    dt::Number, nstep::Int, alg::SimpleUpdate, env0::SUWeight;
    tol::Float64 = 0.0, t0::Number = 0.0, check_interval::Int = 500
) -&gt; (psi, env, info)</code></pre><p>Perform time evolution on the initial state <code>psi0</code> and initial environment <code>env0</code> with Hamiltonian <code>H</code>, using SimpleUpdate algorithm <code>alg</code>, time step <code>dt</code> for  <code>nstep</code> number of steps. </p><ul><li>Setting <code>tol &gt; 0</code> enables convergence check (for imaginary time evolution of InfinitePEPS only).   For other usages it should not be changed.</li><li>Use <code>t0</code> to specify the initial time of the evolution.</li><li><code>check_interval</code> sets the interval to output information. Output during the evolution can be turned off by setting <code>check_interval &lt;= 0</code>.</li><li><code>info</code> is a NamedTuple containing information of the evolution,    including the time <code>info.t</code> evolved since <code>psi0</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate.jl#L290-L307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MPSKit.timestep-Tuple{TimeEvolver{&lt;:SimpleUpdate}, Union{InfinitePEPO, InfinitePEPS}, SUWeight}"><a class="docstring-binding" href="#MPSKit.timestep-Tuple{TimeEvolver{&lt;:SimpleUpdate}, Union{InfinitePEPO, InfinitePEPS}, SUWeight}"><code>MPSKit.timestep</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">timestep(
    it::TimeEvolver{&lt;:SimpleUpdate}, psi::InfiniteState, env::SUWeight
) -&gt; (psi, env, info)</code></pre><p>Given the TimeEvolver iterator <code>it</code>, perform one step of time evolution on the input state <code>psi</code> and its environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate.jl#L210-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixAlgebraKit.eigh_trunc-Tuple{Any, EighAdjoint}"><a class="docstring-binding" href="#MatrixAlgebraKit.eigh_trunc-Tuple{Any, EighAdjoint}"><code>MatrixAlgebraKit.eigh_trunc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eigh_trunc(t, alg::EighAdjoint; trunc=notrunc())
eigh_trunc!(t, alg::EighAdjoint; trunc=notrunc())</code></pre><p>Wrapper around <code>eigh_trunc(!)</code> which dispatches on the <code>EighAdjoint</code> algorithm. This is needed since a custom adjoint may be defined, depending on the <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/eigh.jl#L126-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixAlgebraKit.left_orth-Tuple{Any, QRAdjoint}"><a class="docstring-binding" href="#MatrixAlgebraKit.left_orth-Tuple{Any, QRAdjoint}"><code>MatrixAlgebraKit.left_orth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">left_orth(t, alg::QRAdjoint)
left_orth!(t, alg::QRAdjoint)</code></pre><p>Wrapper around <code>left_orth(!)</code> which dispatches on the <code>QRAdjoint</code> algorithm. This is needed since a custom adjoint may be defined, depending on the <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/qr.jl#L80-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixAlgebraKit.svd_trunc-Tuple{Any, SVDAdjoint}"><a class="docstring-binding" href="#MatrixAlgebraKit.svd_trunc-Tuple{Any, SVDAdjoint}"><code>MatrixAlgebraKit.svd_trunc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">svd_trunc(t, alg::SVDAdjoint; trunc=notrunc())
svd_trunc!(t, alg::SVDAdjoint; trunc=notrunc())</code></pre><p>Wrapper around <code>svd_trunc(!)</code> which dispatches on the <code>SVDAdjoint</code> algorithm. This is needed since a custom adjoint may be defined, depending on the <code>alg</code>. E.g., for <code>IterSVD</code> the adjoint for a truncated SVD from <code>KrylovKit.svdsolve</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/svd.jl#L143-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._apply_gate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap{T, S, 2, 2}, MatrixAlgebraKit.TruncationStrategy}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._apply_gate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap{T, S, 2, 2}, MatrixAlgebraKit.TruncationStrategy}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._apply_gate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_apply_gate(a, b, gate, trunc)
</code></pre><p>Apply 2-site <code>gate</code> on the reduced matrices <code>a</code>, <code>b</code></p><pre><code class="language-julia hljs">    -1← a --- 3 --- b ← -4          -2         -3
        ↓           ↓               ↓           ↓
        1           2               |----gate---|
        ↓           ↓       or      ↓           ↓
        |----gate---|               1           2
        ↓           ↓               ↓           ↓
        -2         -3           -1← a --- 3 --- b ← -4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._apply_gatempo!-Union{Tuple{T2}, Tuple{T1}, Tuple{Vector{T1}, Vector{T2}}} where {T1&lt;:(TensorKit.AbstractTensorMap{T, var&quot;#s82&quot;, 4, 1} where {var&quot;#s82&quot;&lt;:TensorKit.ElementarySpace, T}), T2&lt;:TensorKit.AbstractTensorMap}"><a class="docstring-binding" href="#PEPSKit._apply_gatempo!-Union{Tuple{T2}, Tuple{T1}, Tuple{Vector{T1}, Vector{T2}}} where {T1&lt;:(TensorKit.AbstractTensorMap{T, var&quot;#s82&quot;, 4, 1} where {var&quot;#s82&quot;&lt;:TensorKit.ElementarySpace, T}), T2&lt;:TensorKit.AbstractTensorMap}"><code>PEPSKit._apply_gatempo!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Apply the gate MPO <code>gs</code> on the cluster <code>Ms</code>. When <code>gate_ax</code> is 1 or 2, the gate acts from the physical codomain or domain side.</p><p>e.g. Cluster in PEPS with <code>gate_ax = 1</code>:</p><pre><code class="language-julia hljs">         ╱       ╱       ╱
    --- M1 -←-- M2 -←-- M3 ---
      ╱ |     ╱ |     ╱ |
        ↓       ↓       ↓
        g1 -←-- g2 -←-- g3
        ↓       ↓       ↓</code></pre><p>In the cluster, the axes of each tensor use the MPS order</p><pre><code class="language-julia hljs">    PEPS:           PEPO:
           3             3  4
          ╱              | ╱
    1 -- M -- 5     1 -- M -- 6
       ╱ |             ╱ |
      4  2            5  2
    M[1 2 3 4; 5]  M[1 2 3 4 5; 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate3site.jl#L273-L297">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._bp_gauge_fix!-Tuple{CartesianIndex{3}, InfinitePEPS, BPEnv}"><a class="docstring-binding" href="#PEPSKit._bp_gauge_fix!-Tuple{CartesianIndex{3}, InfinitePEPS, BPEnv}"><code>PEPSKit._bp_gauge_fix!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_bp_gauge_fix!(I, psi::InfinitePEPS, env::BPEnv) -&gt; psi, X, X⁻¹</code></pre><p>For the bond at direction <code>I[1]</code> (which can be <code>NORTH</code> or <code>EAST</code>) from site <code>I[2], I[3]</code>, we identify the following gauge matrices, along the canonical direction of the PEPS arrows (<code>SOUTH ← NORTH</code> or <code>WEST ← EAST</code>):</p><p class="math-container">\[    I = √M₁₂⁻¹ √M₁₂ √M₂₁ √M₂₁⁻¹
      = √M₁₂⁻¹ (U Λ Vᴴ) √M₂₁⁻¹
      = (√M₁₂⁻¹ U √Λ) (√Λ Vᴴ √M₂₁⁻¹)
      = X X⁻¹\]</p><p>Which are then used to update the gauge of <code>psi</code>. Thus, by convention <code>X</code> is attached to the <code>SOUTH</code>/<code>WEST</code> directions and <code>X⁻¹</code> is attached to the <code>NORTH</code>/<code>EAST</code> directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/bp/gaugefix.jl#L72-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._check_algorithm_combination-Tuple{Any, Any}"><a class="docstring-binding" href="#PEPSKit._check_algorithm_combination-Tuple{Any, Any}"><code>PEPSKit._check_algorithm_combination</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_check_algorithm_combination(boundary_alg, gradient_alg)</code></pre><p>Check for allowed combinations of gradient algorithm and boundary algorithm to be used for computing the gradient of a <code>leading_boundary</code> call. Throws an error containing a recommended fix if the combination is not allowed or broken.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/fixed_point_differentiation.jl#L203-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._cluster_truncate!-Union{Tuple{E}, Tuple{T}, Tuple{Vector{T}, Vector{E}}} where {T&lt;:(TensorKit.AbstractTensorMap{T, var&quot;#s163&quot;, 4, 1} where {var&quot;#s163&quot;&lt;:TensorKit.ElementarySpace, T}), E&lt;:MatrixAlgebraKit.TruncationStrategy}"><a class="docstring-binding" href="#PEPSKit._cluster_truncate!-Union{Tuple{E}, Tuple{T}, Tuple{Vector{T}, Vector{E}}} where {T&lt;:(TensorKit.AbstractTensorMap{T, var&quot;#s163&quot;, 4, 1} where {var&quot;#s163&quot;&lt;:TensorKit.ElementarySpace, T}), E&lt;:MatrixAlgebraKit.TruncationStrategy}"><code>PEPSKit._cluster_truncate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Find projectors to truncate internal bonds of the cluster <code>Ms</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate3site.jl#L256-L258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._combine_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._combine_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._combine_ab</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_combine_ab(a, b)
</code></pre><p>Contract the axis between <code>a</code> and <code>b</code> tensors</p><pre><code class="language-julia hljs">    -- DX - a - D - b - DY --
            ↓       ↓
            da      db</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/als_solve.jl#L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._contract_corners-Tuple{Tuple{Int64, Int64}, CTMRGEnv}"><a class="docstring-binding" href="#PEPSKit._contract_corners-Tuple{Tuple{Int64, Int64}, CTMRGEnv}"><code>PEPSKit._contract_corners</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_contract_corners(ind::Tuple{Int,Int}, env::CTMRGEnv)</code></pre><p>Contract all corners around the south-east at position <code>ind</code> of the CTMRG environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L142-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._contract_horizontal_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}"><a class="docstring-binding" href="#PEPSKit._contract_horizontal_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}"><code>PEPSKit._contract_horizontal_edges</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_contract_horizontal_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)</code></pre><p>Contract the horizontal edges and corners around the south edge at position <code>ind</code> of the CTMRG environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L200-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._contract_site-Tuple{Tuple{Int64, Int64}, Any, CTMRGEnv}"><a class="docstring-binding" href="#PEPSKit._contract_site-Tuple{Tuple{Int64, Int64}, Any, CTMRGEnv}"><code>PEPSKit._contract_site</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_contract_site(ind::Tuple{Int,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv)</code></pre><p>Contract around a single site <code>ind</code> of a square network using a given CTMRG environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L91-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._contract_vertical_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}"><a class="docstring-binding" href="#PEPSKit._contract_vertical_edges-Tuple{Tuple{Int64, Int64}, CTMRGEnv}"><code>PEPSKit._contract_vertical_edges</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_contract_vertical_edges(ind::Tuple{Int,Int}, env::CTMRGEnv)</code></pre><p>Contract the vertical edges and corners around the east edge at position <code>ind</code> of the CTMRG environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L157-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._fixgauge_benvXY-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensor{T, S, 4}, TensorKit.AbstractTensor{T, S, 4}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._fixgauge_benvXY-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensor{T, S, 4}, TensorKit.AbstractTensor{T, S, 4}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._fixgauge_benvXY</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>When the (half) bond environment <code>Z</code> consists of two <code>PEPSOrth</code> tensors <code>X</code>, <code>Y</code> as</p><pre><code class="language-julia hljs">    ┌---------------┐   ┌-------------------┐
    |               | = |                   | ,
    └---Z--       --┘   └--Z0---X--    --Y--┘
        ↓                  ↓</code></pre><p>apply the gauge transformation <code>Linv</code>, <code>Rinv</code> for <code>Z</code> to <code>X</code>, <code>Y</code>:</p><pre><code class="language-julia hljs">        -1                                     -1
         |                                      |
    -4 - X - 1 - Rinv - -2      -4 - Linv - 1 - Y - -2
         |                                      |
        -3                                     -3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/gaugefix.jl#L94-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._flip_virtuals!-Union{Tuple{T}, Tuple{Vector{T}, Vector{Bool}}} where T&lt;:(TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T})"><a class="docstring-binding" href="#PEPSKit._flip_virtuals!-Union{Tuple{T}, Tuple{Vector{T}, Vector{Bool}}} where T&lt;:(TensorKit.AbstractTensorMap{T, S, N, 1} where {S, N, T})"><code>PEPSKit._flip_virtuals!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Flip the virtual arrows in the MPS <code>Ms</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate3site.jl#L240-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._fuse_ids-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, NTuple{N, S}}} where {T, S, N}"><a class="docstring-binding" href="#PEPSKit._fuse_ids-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, NTuple{N, S}}} where {T, S, N}"><code>PEPSKit._fuse_ids</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_fuse_ids(op::AbstractTensorMap{T, S, N, N}, [Ps::NTuple{N, S}]) where {T, S, N}</code></pre><p>Fuse identities on auxiliary physical spaces <code>Ps</code> into a given operator <code>op</code>. When <code>Ps</code> is not specified, it defaults to the domain spaces of <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/localoperator.jl#L222-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._get_allRLs-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{T, var&quot;#s682&quot;, 4, 1} where {var&quot;#s682&quot;&lt;:TensorKit.ElementarySpace, T})"><a class="docstring-binding" href="#PEPSKit._get_allRLs-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{T, var&quot;#s682&quot;, 4, 1} where {var&quot;#s682&quot;&lt;:TensorKit.ElementarySpace, T})"><code>PEPSKit._get_allRLs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a cluster <code>Ms</code>, find all <code>R</code>, <code>L</code> matrices on each internal bond</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate3site.jl#L171-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._get_allprojs-Union{Tuple{E}, Tuple{Any, Any, Any, Vector{E}}} where E&lt;:MatrixAlgebraKit.TruncationStrategy"><a class="docstring-binding" href="#PEPSKit._get_allprojs-Union{Tuple{E}, Tuple{Any, Any, Any, Vector{E}}} where E&lt;:MatrixAlgebraKit.TruncationStrategy"><code>PEPSKit._get_allprojs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a cluster <code>Ms</code> and the pre-calculated <code>R</code>, <code>L</code> bond matrices, find all projectors <code>Pa</code>, <code>Pb</code> and Schmidt weights <code>wts</code> on internal bonds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate3site.jl#L216-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._get_dt-Tuple{Union{InfinitePEPO, InfinitePEPS}, Number, Bool}"><a class="docstring-binding" href="#PEPSKit._get_dt-Tuple{Union{InfinitePEPO, InfinitePEPS}, Number, Bool}"><code>PEPSKit._get_dt</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Process the Trotter time step <code>dt</code> according to the intended usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._get_gatempo_se-Tuple{LocalOperator, Number, Int64, Int64}"><a class="docstring-binding" href="#PEPSKit._get_gatempo_se-Tuple{LocalOperator, Number, Int64, Int64}"><code>PEPSKit._get_gatempo_se</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Obtain the 3-site gate MPO on the southeast cluster at position <code>[row, col]</code></p><pre><code class="language-julia hljs">    r-1        g3
                |
                ↓
    r   g1 -←- g2
        c      c+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L258-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._get_gatempos_se-Tuple{LocalOperator, Number}"><a class="docstring-binding" href="#PEPSKit._get_gatempos_se-Tuple{LocalOperator, Number}"><code>PEPSKit._get_gatempos_se</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Construct the 3-site gate MPOs on the southeast cluster  for 3-site simple update on square lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L295-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._linearmap_twist!-Tuple{TensorKit.AbstractTensorMap}"><a class="docstring-binding" href="#PEPSKit._linearmap_twist!-Tuple{TensorKit.AbstractTensorMap}"><code>PEPSKit._linearmap_twist!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_linearmap_twist!(t)
</code></pre><p>Apply a twist to domain or codomain indices that correspond to dual spaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/truncation/fullenv_truncation.jl#L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._message_tensor-Union{Tuple{P}, Tuple{T}, Tuple{Any, Type{T}, P}} where {T, P&lt;:TensorKit.ProductSpace}"><a class="docstring-binding" href="#PEPSKit._message_tensor-Union{Tuple{P}, Tuple{T}, Tuple{Any, Type{T}, P}} where {T, P&lt;:TensorKit.ProductSpace}"><code>PEPSKit._message_tensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Construct a message tensor on a certain bond of a network, with bond space specified by <code>pspaces</code>.  In the 2-layer case, the message tensor will be</p><pre><code class="language-julia hljs">    ┌--- pspaces[1] (ket layer)
    m
    └--- pspaces[2] (bra layer)</code></pre><p>Returning axis order is <code>bra ← ket</code>.</p><p>When <code>posdef</code> is true, the message will be made semi-posdef definite (when interpreted as a <code>bra ← ket</code> TensorMap).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/bp_environments.jl#L31-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._proj_from_RL-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}}"><a class="docstring-binding" href="#PEPSKit._proj_from_RL-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}}"><code>PEPSKit._proj_from_RL</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given the tensors <code>R</code>, <code>L</code> on a bond, construct  the projectors <code>Pa</code>, <code>Pb</code> and the new bond weight <code>s</code> such that the contraction of <code>Pa</code>, <code>s</code>, <code>Pb</code> is identity when <code>trunc = notrunc</code>,</p><p>The arrows between <code>Pa</code>, <code>s</code>, <code>Pb</code> are</p><pre><code class="language-julia hljs">    - Pa --←-- Pb -
       1 ← s ← 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate3site.jl#L192-L202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._qr_bond-Union{Tuple{PT}, Tuple{PT, PT}} where PT&lt;:Union{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._qr_bond-Union{Tuple{PT}, Tuple{PT, PT}} where PT&lt;:Union{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._qr_bond</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_qr_bond(A, B; gate_ax)
</code></pre><p>Use QR decomposition on two tensors <code>A</code>, <code>B</code> connected by a bond to get the reduced tensors. When <code>A</code>, <code>B</code> are PEPSTensors,</p><pre><code class="language-julia hljs">        2                   1                                   1
        |                   |                                   |
    5 -A/B- 3   ====&gt;   4 - X ← 2   1 ← a - 3   1 - b → 3   4 → Y - 2
        | ↘                 |            ↘           ↘          |
        4   1               3             2           2         3</code></pre><p>When <code>A</code>, <code>B</code> are PEPOTensors, </p><ul><li>If <code>gate_ax = 1</code></li></ul><pre><code class="language-julia hljs">    2   3                1  2                                1  2
      ↘ |                 ↘ |                                 ↘ |
    6 -A/B- 4   ====&gt;   5 - X ← 3   1 ← a - 3   1 - b → 3   5 → Y - 3
        | ↘                 |            ↘           ↘          |
        5   1               4             2           2         4</code></pre><ul><li>If <code>gate_ax = 2</code></li></ul><pre><code class="language-julia hljs">    2   3                   2         2           2             2
      ↘ |                   |          ↘           ↘            |
    6 -A/B- 4   ====&gt;   5 - X ← 3   1 ← a - 3   1 - b → 3   5 → Y - 3
        | ↘                 | ↘                                 | ↘
        5   1               4  1                                4  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._qr_bond_undo-Tuple{TensorKit.AbstractTensor{T, S, 4} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensor{T, S, 4} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}}"><a class="docstring-binding" href="#PEPSKit._qr_bond_undo-Tuple{TensorKit.AbstractTensor{T, S, 4} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensor{T, S, 4} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}}"><code>PEPSKit._qr_bond_undo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_qr_bond_undo(X, a, b, Y)
</code></pre><p>Reconstruct the tensors connected by a bond from their <code>_qr_bond</code> results. For PEPSTensors,</p><pre><code class="language-julia hljs">        -2                             -2
        |                               |
    -5- X - 1 - a - -3     -5 - b - 1 - Y - -3
        |        ↘               ↘      |
        -4        -1              -1   -4</code></pre><p>For PEPOTensors</p><pre><code class="language-julia hljs">    -2  -3                          -2  -3
      ↘ |                             ↘ |
    -6- X - 1 - a - -4     -6 - b - 1 - Y - -4
        |        ↘               ↘      |
        -5        -1              -1   -5

        -3   -2              -2        -3
        |      ↘               ↘        |
    -6- X - 1 - a - -4     -6 - b - 1 - Y - -4
        | ↘                             | ↘
        -5 -1                          -5  -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}"><a class="docstring-binding" href="#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}"><code>PEPSKit._rrule</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_rrule(alg_rrule, config, f, args...; kwargs...) -&gt; ∂f, ∂args...</code></pre><p>Customize the pullback of a function <code>f</code>. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default <code>alg_rrule=nothing</code> results in the default AD pullback.</p><div class="admonition is-warning" id="Warning-3d774d8a78a8fb42"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-3d774d8a78a8fb42" title="Permalink"></a></header><div class="admonition-body"><p>No tangent is expected for the <code>alg_rrule</code> argument</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/hook_pullback.jl#L37-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._set_truncation-Tuple{PEPSKit.ProjectorAlgorithm, MatrixAlgebraKit.TruncationStrategy}"><a class="docstring-binding" href="#PEPSKit._set_truncation-Tuple{PEPSKit.ProjectorAlgorithm, MatrixAlgebraKit.TruncationStrategy}"><code>PEPSKit._set_truncation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_set_truncation(alg::ProjectorAlgorithm, trunc::TruncationStrategy)</code></pre><p>Update the truncation strategy of a given projector algorithm, keeping all other settings the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/projectors.jl#L93-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._singular_value_distance-Union{Tuple{SV}, Tuple{SV, SV}} where SV&lt;:TensorKit.SectorVector"><a class="docstring-binding" href="#PEPSKit._singular_value_distance-Union{Tuple{SV}, Tuple{SV, SV}} where SV&lt;:TensorKit.SectorVector"><code>PEPSKit._singular_value_distance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_singular_value_distance(S₁, S₂)</code></pre><p>Compute the singular value distance as an error measure, e.g. for CTMRG iterations. To that end, the singular values of the current iteration <code>S₁</code> are compared with the previous one <code>S₂</code>. When the virtual spaces change, this comparison is not directly possible such that both tensors are projected into the smaller space and then subtracted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/ctmrg.jl#L161-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._solve_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._solve_ab-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._solve_ab</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_solve_ab(Rx, Sx, x0)
</code></pre><p>Solve the equations <code>Rx x = Sx</code> (x = a, b) with initial guess <code>x0</code></p><pre><code class="language-julia hljs">    ┌---------------------------┐
    |   ┌----┐                  |
    └---|    |--- 1 -- x -- 2 --┘
        |    |         ↓
        | Rx |        -3
        |    |
    ┌---|    |--- -1       -2 --┐
    |   └----┘                  |
    └---------------------------┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/als_solve.jl#L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._su_xbond!-Union{Tuple{S}, Tuple{T}, Tuple{Union{InfinitePEPO, InfinitePEPS}, TensorKit.AbstractTensorMap{T, S, 2, 2}, SUWeight, Int64, Int64, MatrixAlgebraKit.TruncationStrategy}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._su_xbond!-Union{Tuple{S}, Tuple{T}, Tuple{Union{InfinitePEPO, InfinitePEPS}, TensorKit.AbstractTensorMap{T, S, 2, 2}, SUWeight, Int64, Int64, MatrixAlgebraKit.TruncationStrategy}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._su_xbond!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Simple update of the x-bond between <code>[r,c]</code> and <code>[r,c+1]</code>.</p><pre><code class="language-julia hljs">        |           |
    -- T[r,c] -- T[r,c+1] --
        |           |</code></pre><p>When <code>gate_ax = 1</code> (or <code>2</code>), the gate will be applied to  the codomain (or domain) physicsl legs of <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate.jl#L79-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._su_ybond!-Union{Tuple{S}, Tuple{T}, Tuple{Union{InfinitePEPO, InfinitePEPS}, TensorKit.AbstractTensorMap{T, S, 2, 2}, SUWeight, Int64, Int64, MatrixAlgebraKit.TruncationStrategy}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._su_ybond!-Union{Tuple{S}, Tuple{T}, Tuple{Union{InfinitePEPO, InfinitePEPS}, TensorKit.AbstractTensorMap{T, S, 2, 2}, SUWeight, Int64, Int64, MatrixAlgebraKit.TruncationStrategy}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._su_ybond!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Simple update of the y-bond between <code>[r,c]</code> and <code>[r-1,c]</code>.</p><pre><code class="language-julia hljs">        |
    --T[r-1,c] --
        |
    -- T[r,c] ---
        |</code></pre><p>When <code>gate_ax = 1</code> (or <code>2</code>), the gate will be applied to  the codomain (or domain) physicsl legs of <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate.jl#L117-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._tensor_Ra-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._tensor_Ra-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._tensor_Ra</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_tensor_Ra(benv, b)
</code></pre><p>Construct the tensor</p><pre><code class="language-julia hljs">    ┌-----------------------------------┐
    |   ┌----┐                          |
    └---|    |- DX0     Db0 - b -- DY0 -┘
        |    |                ↓
        |benv|                db
        |    |                ↓
    ┌---|    |- DX1     Db1 - b† - DY1 -┐
    |   └----┘                          |
    └-----------------------------------┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/als_solve.jl#L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._tensor_Rb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._tensor_Rb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._tensor_Rb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_tensor_Rb(benv, a)
</code></pre><p>Construct the tensor</p><pre><code class="language-julia hljs">    ┌-----------------------------------┐
    |   ┌----┐                          |
    └---|    |- DX0 - a -- Da0     DY0 -┘
        |    |        ↓
        |benv|        da
        |    |        ↓
    ┌---|    |- DX1 - a† - Da1     DY1 -┐
    |   └----┘                          |
    └-----------------------------------┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/als_solve.jl#L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._tensor_Sa-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._tensor_Sa-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._tensor_Sa</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_tensor_Sa(benv, b, a2b2)
</code></pre><p>Construct the tensor</p><pre><code class="language-julia hljs">    ┌-----------------------------------┐
    |   ┌----┐                          |
    └---|    |- DX0 -- (a2 b2) -- DY0 --┘
        |    |         ↓     ↓
        |benv|         da    db
        |    |               ↓
    ┌---|    |- DX1   Db1 -- b† - DY1 --┐
    |   └----┘                          |
    └-----------------------------------┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/als_solve.jl#L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._tensor_Sb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit._tensor_Sb-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit._tensor_Sb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_tensor_Sb(benv, a, a2b2)
</code></pre><p>Construct the tensor</p><pre><code class="language-julia hljs">    ┌-----------------------------------┐
    |   ┌----┐                          |
    └---|    |- DX0 -- (a2 b2) -- DY0 --┘
        |    |         ↓     ↓
        |benv|         da    db
        |    |         ↓
    ┌---|    |- DX1 -- a† - Da1   DY1 --┐
    |   └----┘                          |
    └-----------------------------------┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/als_solve.jl#L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit._trivial_gates-Union{Tuple{S}, Tuple{Type{&lt;:Number}, Matrix{S}}} where S&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#PEPSKit._trivial_gates-Union{Tuple{S}, Tuple{Type{&lt;:Number}, Matrix{S}}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit._trivial_gates</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>A LocalOperator consisting of identity gates on all nearest neighbor bonds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/gaugefix_su.jl#L20-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.absorb_s-Tuple{TensorKit.AbstractTensorMap, TensorKit.DiagonalTensorMap, TensorKit.AbstractTensorMap}"><a class="docstring-binding" href="#PEPSKit.absorb_s-Tuple{TensorKit.AbstractTensorMap, TensorKit.DiagonalTensorMap, TensorKit.AbstractTensorMap}"><code>PEPSKit.absorb_s</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">absorb_s(U::AbstractTensorMap, S::DiagonalTensorMap, V::AbstractTensorMap)</code></pre><p>Given SVD result <code>U</code>, <code>S</code> and <code>V</code>, absorb singular values <code>S</code> into <code>U</code> and <code>V</code> by:</p><pre><code class="language-julia hljs">    U -&gt; U * sqrt(S), V -&gt; sqrt(S) * V</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/util.jl#L89-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.absorb_weight-Tuple{Union{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace}, SUWeight, Int64, Int64, Int64}"><a class="docstring-binding" href="#PEPSKit.absorb_weight-Tuple{Union{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace, TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace}, SUWeight, Int64, Int64, Int64}"><code>PEPSKit.absorb_weight</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">absorb_weight(t::Union{PEPSTensor, PEPOTensor}, weights::SUWeight, row::Int, col::Int, ax::Int; inv::Bool = false)
absorb_weight(t::Union{PEPSTensor, PEPOTensor}, weights::SUWeight, row::Int, col::Int, ax::NTuple{N, Int}; inv::Bool = false)</code></pre><p>Absorb or remove (in a twist-free way) the square root of environment weight  on an axis of the PEPS/PEPO tensor <code>t</code> known to be at position (<code>row</code>, <code>col</code>) in the unit cell of an InfinitePEPS/InfinitePEPO. The involved weights are</p><pre><code class="language-julia hljs">                    |
                [2,r,c]
                    |
    - [1,r,c-1] - T[r,c] - [1,r,c] -
                    |
                [1,r+1,c]
                    |</code></pre><p><strong>Arguments</strong></p><ul><li><code>t::Union{PEPSTensor, PEPOTensor}</code> : PEPSTensor or PEPOTensor to which the weight will be absorbed.</li><li><code>weights::SUWeight</code> : All simple update weights.</li><li><code>row::Int</code> : The row index specifying the position in the tensor network.</li><li><code>col::Int</code> : The column index specifying the position in the tensor network.</li><li><code>ax::Int</code> : The axis into which the weight is absorbed, taking values from 1 to 4, standing for north, east, south, west respectively.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>inv::Bool=false</code> : If <code>true</code>, the inverse square root of the weight is absorbed.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Absorb the weight into the north axis of tensor at position (2, 3)
absorb_weight(t, weights, 2, 3, 1)

# Absorb the inverse of (i.e. remove) the weight into the east axis
absorb_weight(t, weights, 2, 3, 2; inv=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/environments/suweight.jl#L169-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.bond_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, ALSTruncation}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.bond_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 1}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, ALSTruncation}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.bond_truncate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bond_truncate(a::AbstractTensorMap{T,S,2,1}, b::AbstractTensorMap{T,S,1,2}, benv::BondEnv{T,S}, alg) -&gt; U, S, V, info</code></pre><p>After time-evolving the reduced tensors <code>a</code> and <code>b</code> connected by a bond,  truncate the bond dimension using the bond environment tensor <code>benv</code>.</p><pre><code class="language-julia hljs">    ┌-----------------------┐
    |   ┌----┐              |
    └---|    |-- a === b ---┘
        |benv|   ↓     ↓
    ┌---|    |-- a† == b† --┐
    |   └----┘              |
    └-----------------------┘</code></pre><p>The truncation algorithm <code>alg</code> can be either <code>FullEnvTruncation</code> or <code>ALSTruncation</code>.  The index order of <code>a</code> or <code>b</code> is</p><pre><code class="language-julia hljs">    1 -a/b- 3
        ↓       a[1 2; 3]
        2       b[1; 2 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/truncation/bond_truncation.jl#L37-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.bondenv_fu-Tuple{Int64, Int64, TensorKit.AbstractTensor{T, S, 4} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}, TensorKit.AbstractTensor{T, S, 4} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}, CTMRGEnv}"><a class="docstring-binding" href="#PEPSKit.bondenv_fu-Tuple{Int64, Int64, TensorKit.AbstractTensor{T, S, 4} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}, TensorKit.AbstractTensor{T, S, 4} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}, CTMRGEnv}"><code>PEPSKit.bondenv_fu</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Construct the environment (norm) tensor</p><pre><code class="language-julia hljs">    C1---T1---------T1---C2   r-1
    |    ‖          ‖    |
    T4===XX==     ==YY===T2    r
    |    ‖          ‖    |
    C4---T3---------T3---C3   r+1
    c-1  c         c+1  c+2</code></pre><p>where <code>XX = X&#39; X</code> and <code>YY = Y&#39; Y</code> (stacked together).</p><p>Axis order: <code>[DX1 DY1; DX0 DY0]</code>, as in</p><pre><code class="language-julia hljs">    ┌---------------------┐
    | ┌----┐              |
    └-|    |---DX0  DY0---┘
      |benv|
    ┌-|    |---DX1  DY1---┐
    | └----┘              |
    └---------------------┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/benv_ctm.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.bp_iteration-Tuple{InfiniteSquareNetwork, BPEnv, BeliefPropagation}"><a class="docstring-binding" href="#PEPSKit.bp_iteration-Tuple{InfiniteSquareNetwork, BPEnv, BeliefPropagation}"><code>PEPSKit.bp_iteration</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>One iteration to update the BP environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/bp/beliefpropagation.jl#L67-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.c4v_enlarge-Tuple{Any, Any, C4vEighProjector}"><a class="docstring-binding" href="#PEPSKit.c4v_enlarge-Tuple{Any, Any, C4vEighProjector}"><code>PEPSKit.c4v_enlarge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">c4v_enlarge(network, env, ::C4vEighProjector)</code></pre><p>Compute the normalized and Hermitian-symmetrized C₄ᵥ enlarged corner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/c4v.jl#L165-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.c4v_enlarge-Tuple{Any, C4vQRProjector}"><a class="docstring-binding" href="#PEPSKit.c4v_enlarge-Tuple{Any, C4vQRProjector}"><code>PEPSKit.c4v_enlarge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">c4v_enlarge(env, ::C4vQRProjector)</code></pre><p>Compute the normalized column-enlarged northeast corner for C₄ᵥ QR-CTMRG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/c4v.jl#L176-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.c4v_projector!-Tuple{Any, C4vEighProjector}"><a class="docstring-binding" href="#PEPSKit.c4v_projector!-Tuple{Any, C4vEighProjector}"><code>PEPSKit.c4v_projector!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">c4v_projector!(enlarged_corner, alg::C4vEighProjector)</code></pre><p>Compute the C₄ᵥ projector from <code>eigh</code> decomposing the Hermitian <code>enlarged_corner</code>. Also return the normalized eigenvalues as the new corner tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/c4v.jl#L185-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.c4v_projector!-Tuple{Any, C4vQRProjector}"><a class="docstring-binding" href="#PEPSKit.c4v_projector!-Tuple{Any, C4vQRProjector}"><code>PEPSKit.c4v_projector!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">c4v_projector!(enlarged_corner, alg::C4vQRProjector)</code></pre><p>Compute the C₄ᵥ projector by decomposing the column-enlarged corner with <code>left_orth</code>.</p><pre><code class="language-julia hljs">                   R--←--
                   ↓
    C-←-E-←-  =  [~Q~]    
    ↓   |        ↓   |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/c4v.jl#L205-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.calc_convergence-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.calc_convergence-Tuple{Any, Any, Any}"><code>PEPSKit.calc_convergence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calc_convergence(env, CS_old, TS_old)
calc_convergence(env_new, env_old)</code></pre><p>Given a new environment <code>env</code>, compute the maximal singular value distance. This determined either from the previous corner and edge singular values <code>CS_old</code> and <code>TS_old</code>, or alternatively, directly from the old environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/ctmrg.jl#L187-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.calc_elementwise_convergence-Union{Tuple{C′}, Tuple{C}, Tuple{CTMRGEnv{C}, CTMRGEnv{C′}}} where {C, C′}"><a class="docstring-binding" href="#PEPSKit.calc_elementwise_convergence-Union{Tuple{C′}, Tuple{C}, Tuple{CTMRGEnv{C}, CTMRGEnv{C′}}} where {C, C′}"><code>PEPSKit.calc_elementwise_convergence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calc_elementwise_convergence(envfinal, envfix; atol=1e-6)</code></pre><p>Check if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below <code>atol</code> and return the maximal difference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/gaugefix.jl#L244-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.check_input-Tuple{typeof(fixedpoint), Any, Any, PEPSOptimize}"><a class="docstring-binding" href="#PEPSKit.check_input-Tuple{typeof(fixedpoint), Any, Any, PEPSOptimize}"><code>PEPSKit.check_input</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_input(::typeof(fixedpoint), peps₀, env₀, alg::PEPSOptimize{&lt;:SimultaneousCTMRG})</code></pre><p>Check compatibility of an initial PEPS and environment with a specified PEPS optimization algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/peps_optimization.jl#L237-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.check_input-Tuple{typeof(leading_boundary), Any, Any, PEPSKit.CTMRGAlgorithm}"><a class="docstring-binding" href="#PEPSKit.check_input-Tuple{typeof(leading_boundary), Any, Any, PEPSKit.CTMRGAlgorithm}"><code>PEPSKit.check_input</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_input(::typeof(leading_boundary), network, env, alg::CTMRGAlgorithm)</code></pre><p>Check compatibility of a given network and environment with a specified CTMRG algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/ctmrg.jl#L134-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.checklattice-Tuple"><a class="docstring-binding" href="#PEPSKit.checklattice-Tuple"><code>PEPSKit.checklattice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checklattice(Bool, args...)
checklattice(args...)</code></pre><p>Helper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/localoperator.jl#L67-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.column_enlarge_northwest_corner-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, N, 1}}} where {T, S, N}"><a class="docstring-binding" href="#PEPSKit.column_enlarge_northwest_corner-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, N, 1}}} where {T, S, N}"><code>PEPSKit.column_enlarge_northwest_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">column_enlarge_northwest_corner(C_northwest, edge)
</code></pre><p>Contract the half-enlarged northwest corner of the CTMRG environment.</p><pre><code class="language-julia hljs">    C₁-←-E₁-←-
    ↓    |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/enlarge_corner_column.jl#L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.compute_projector-Tuple{Any, Any, HalfInfiniteProjector}"><a class="docstring-binding" href="#PEPSKit.compute_projector-Tuple{Any, Any, HalfInfiniteProjector}"><code>PEPSKit.compute_projector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_projector(enlarged_corners, coordinate, alg::ProjectorAlgorithm)</code></pre><p>Determine left and right projectors at the bond given determined by the enlarged corners and the given coordinate using the specified <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/projectors.jl#L180-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.contract_local_norm-Union{Tuple{N}, Tuple{NTuple{N, CartesianIndex{2}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N"><a class="docstring-binding" href="#PEPSKit.contract_local_norm-Union{Tuple{N}, Tuple{NTuple{N, CartesianIndex{2}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N"><code>PEPSKit.contract_local_norm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contract_local_norm(inds, ket, bra, env)
</code></pre><p>Contract a local norm of the PEPS <code>peps</code> around indices <code>inds</code>.</p><p>This works analogously to <a href="#PEPSKit.contract_local_operator-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{T, S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {T, S, N}"><code>contract_local_operator</code></a> by generating the contraction on a rectangular patch based on <code>inds</code> but replacing the operator with an identity such that the PEPS norm is computed. (Note that this is not the physical norm of the state.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/localoperator.jl#L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.contract_local_operator-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{T, S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {T, S, N}"><a class="docstring-binding" href="#PEPSKit.contract_local_operator-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{T, S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {T, S, N}"><code>PEPSKit.contract_local_operator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contract_local_operator(inds, O, ket, bra, env)
</code></pre><p>Contract a local operator <code>O</code> on the PEPS <code>peps</code> at the indices <code>inds</code> using the environment <code>env</code>.</p><p>This works by generating the appropriate contraction on a rectangular patch with its corners specified by <code>inds</code>. The <code>peps</code> is contracted with <code>O</code> from above and below, and the PEPS-operator sandwich is surrounded with the appropriate environment tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/localoperator.jl#L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.contract_local_tensor-Tuple{Tuple{Int64, Int64, Int64}, TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace, InfiniteSquareNetwork{&lt;:Tuple{T, T, Vararg{P, N}} where {N, T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), P&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)}}, CTMRGEnv}"><a class="docstring-binding" href="#PEPSKit.contract_local_tensor-Tuple{Tuple{Int64, Int64, Int64}, TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace, InfiniteSquareNetwork{&lt;:Tuple{T, T, Vararg{P, N}} where {N, T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), P&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)}}, CTMRGEnv}"><code>PEPSKit.contract_local_tensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contract_local_tensor(inds, O::PEPOTensor, network, env)</code></pre><p>Contract a local tensor <code>O</code> inserted into the PEPO of a given <code>network</code> at position <code>inds</code>, using the environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L393-L398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.contract_local_tensor-Union{Tuple{C}, Tuple{Tuple{Int64, Int64}, TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace, CTMRGEnv{C, &lt;:TensorKit.AbstractTensorMap{T, S, 2, 1} where {T, S}}}} where C"><a class="docstring-binding" href="#PEPSKit.contract_local_tensor-Union{Tuple{C}, Tuple{Tuple{Int64, Int64}, TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 2} where S&lt;:TensorKit.ElementarySpace, CTMRGEnv{C, &lt;:TensorKit.AbstractTensorMap{T, S, 2, 1} where {T, S}}}} where C"><code>PEPSKit.contract_local_tensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contract_local_tensor(inds, O::PFTensor, env)</code></pre><p>Contract a local tensor <code>O</code> inserted into a partition function <code>pf</code> at position <code>inds</code>, using the environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L372-L377">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.contract_projectors-NTuple{5, Any}"><a class="docstring-binding" href="#PEPSKit.contract_projectors-NTuple{5, Any}"><code>PEPSKit.contract_projectors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contract_projectors(U, S, V, Q, Q_next)
</code></pre><p>Compute projectors based on a SVD of <code>Q * Q_next</code>, where the inverse square root <code>isqS</code> of the singular values is computed.</p><p>Left projector:</p><pre><code class="language-julia hljs">    -- |~~~~~~| -- |~~|
       |Q_next|    |V&#39;| -- isqS --
    == |~~~~~~| == |~~|</code></pre><p>Right projector:</p><pre><code class="language-julia hljs">               |~~| -- |~~~| --
    -- isqS -- |U&#39;|    | Q |
               |~~| == |~~~| ==</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/projector.jl#L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.cost_function-Tuple{InfinitePEPS, CTMRGEnv, LocalOperator}"><a class="docstring-binding" href="#PEPSKit.cost_function-Tuple{InfinitePEPS, CTMRGEnv, LocalOperator}"><code>PEPSKit.cost_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cost_function(peps::InfinitePEPS, env::CTMRGEnv, O::LocalOperator)</code></pre><p>Real part of expectation value of <code>O</code>. Prints a warning if the expectation value yields a finite imaginary part (up to a tolerance).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L58-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.cost_function_als-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.cost_function_als-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.cost_function_als</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cost_function_als(benv, a1b1, a2b2)
</code></pre><p>Calculate the cost function</p><pre><code class="language-julia hljs">    f(a,b)  = ‖ |a1,b1⟩ - |a2,b2⟩ ‖^2
    = ⟨a1,b1|a1,b1⟩ - 2 Re⟨a1,b1|a2,b2⟩ + ⟨a2,b2|a2,b2⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/als_solve.jl#L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ctmrg_iteration-Tuple{Any, Any, PEPSKit.CTMRGAlgorithm}"><a class="docstring-binding" href="#PEPSKit.ctmrg_iteration-Tuple{Any, Any, PEPSKit.CTMRGAlgorithm}"><code>PEPSKit.ctmrg_iteration</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ctmrg_iteration(network, env, alg::CTMRGAlgorithm) -&gt; env′, info</code></pre><p>Perform a single CTMRG iteration in which all directions are being grown and renormalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/ctmrg.jl#L40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.ctmrg_leftmove-Tuple{Int64, Any, CTMRGEnv, SequentialCTMRG}"><a class="docstring-binding" href="#PEPSKit.ctmrg_leftmove-Tuple{Int64, Any, CTMRGEnv, SequentialCTMRG}"><code>PEPSKit.ctmrg_leftmove</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ctmrg_leftmove(col::Int, network, env::CTMRGEnv, alg::SequentialCTMRG)</code></pre><p>Perform sequential CTMRG left move on the <code>col</code>-th column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sequential.jl#L40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.decomposition_algorithm-Tuple{PEPSKit.ProjectorAlgorithm}"><a class="docstring-binding" href="#PEPSKit.decomposition_algorithm-Tuple{PEPSKit.ProjectorAlgorithm}"><code>PEPSKit.decomposition_algorithm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">decomposition_algorithm(alg::ProjectorAlgorithm)
decomposition_algorithm(alg::ProjectorAlgorithm, (dir, r, c))</code></pre><p>Return the tensor decomposition algorithm of the <code>alg</code> projector algorithm. Additionally, the multi-index <code>(dir, r, c)</code> can be supplied which will return the decomposition performed at that index, e.g. when using <a href="#PEPSKit.FixedEig"><code>FixedEig</code></a> or <a href="#PEPSKit.FixedSVD"><code>FixedSVD</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/projectors.jl#L53-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.dtmap-Tuple"><a class="docstring-binding" href="#PEPSKit.dtmap-Tuple"><code>PEPSKit.dtmap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dtmap(args...; kwargs...)</code></pre><p>Differentiable wrapper around [OhMyThreads.tmap].</p><p>All calls of <code>dtmap</code> inside of PEPSKit use the threading scheduler stored inside <code>Defaults.scheduler</code> which can be modified using <code>set_scheduler!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/diffable_threads.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.eachcoordinate"><a class="docstring-binding" href="#PEPSKit.eachcoordinate"><code>PEPSKit.eachcoordinate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eachcoordinate(x, [dirs=1:4])</code></pre><p>Enumerate all (dir, row, col) pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/util.jl#L30-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.edge_transfer_left-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{&lt;:Any, S, N₂, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, N₂, 1}}} where {S, N₁, N₂}"><a class="docstring-binding" href="#PEPSKit.edge_transfer_left-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{&lt;:Any, S, N₂, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, N₂, 1}}} where {S, N₁, N₂}"><code>PEPSKit.edge_transfer_left</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">edge_transfer_left(v, Et, Eb)</code></pre><p>Apply an edge transfer matrix to the left.</p><pre><code class="language-julia hljs"> ┌─Et─
-v │
 └─qƎ─</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/transfer.jl#L8-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.edge_transfer_left-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}}} where S"><a class="docstring-binding" href="#PEPSKit.edge_transfer_left-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}}} where S"><code>PEPSKit.edge_transfer_left</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">edge_transfer_left(v, O, Et, Eb)</code></pre><p>Apply an edge transfer matrix to the left.</p><pre><code class="language-julia hljs"> ┌──Et─
 │  │
 v──O──
 │  │
 └──qƎ─</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/transfer.jl#L59-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.edge_transfer_left-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 4, 1}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}}} where S"><a class="docstring-binding" href="#PEPSKit.edge_transfer_left-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 4, 1}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}}} where S"><code>PEPSKit.edge_transfer_left</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">edge_transfer_left(v, O, Et, Eb)</code></pre><p>Apply an edge transfer matrix to the left on an excited vector.</p><pre><code class="language-julia hljs"> ┌──Et─
 │  │
-v──O──
 │  │
 └──qƎ─</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/transfer.jl#L145-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.edge_transfer_right-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{&lt;:Any, S, N₂, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, N₂, 1}}} where {S, N₁, N₂}"><a class="docstring-binding" href="#PEPSKit.edge_transfer_right-Union{Tuple{N₂}, Tuple{N₁}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N₁}, TensorKit.AbstractTensorMap{&lt;:Any, S, N₂, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, N₂, 1}}} where {S, N₁, N₂}"><code>PEPSKit.edge_transfer_right</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">edge_transfer_right(v, Et, Eb)</code></pre><p>Apply an edge transfer matrix to the right.</p><pre><code class="language-julia hljs">─Et─┐
 │  v-
─qƎ─┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/transfer.jl#L34-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.edge_transfer_right-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}}} where S"><a class="docstring-binding" href="#PEPSKit.edge_transfer_right-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, 3, 1}}} where S"><code>PEPSKit.edge_transfer_right</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transfer_right(v, Et, Eb)</code></pre><p>Apply an edge transfer matrix to the right.</p><pre><code class="language-julia hljs">──Et─┐
  │  │
──O──v
  │  │
──qƎ─┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/transfer.jl#L102-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.edge_transfer_spectrum-Union{Tuple{E}, Tuple{Vector{E}, Vector{E}}} where E&lt;:(TensorKit.AbstractTensorMap{T, S, N, 1} where {T, S, N})"><a class="docstring-binding" href="#PEPSKit.edge_transfer_spectrum-Union{Tuple{E}, Tuple{Vector{E}, Vector{E}}} where E&lt;:(TensorKit.AbstractTensorMap{T, S, N, 1} where {T, S, N})"><code>PEPSKit.edge_transfer_spectrum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">edge_transfer_spectrum(top::Vector{E}, bot::Vector{E}; tol=Defaults.tol, num_vals=20,
                       sector=one(sectortype(E))) where {E&lt;:CTMRGEdgeTensor}</code></pre><p>Calculate the partial spectrum of the left edge transfer matrix corresponding to the given <code>top</code> vector of edges and a <code>bot</code> vector of edge. The <code>sector</code> keyword argument can be used to specify a non-trivial total charge for the transfer matrix eigenvectors. Specifically, an auxiliary space <code>ℂ[typeof(sector)](sector =&gt; 1)&#39;</code> will be added to the domain of each eigenvector. The <code>tol</code> and <code>num_vals</code> keyword arguments are passed to <code>KrylovKit.eigolve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L242-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.enlarge_northeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><a class="docstring-binding" href="#PEPSKit.enlarge_northeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><code>PEPSKit.enlarge_northeast_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enlarge_northeast_corner(E_north, C_northeast, E_east, A)
</code></pre><p>Contract the enlarged northeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.</p><pre><code class="language-julia hljs">    out-- E_north -- C_northeast
             |             |
       --    A    --    E_east
             |             |
                           in</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/enlarge_corner.jl#L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.enlarge_northwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><a class="docstring-binding" href="#PEPSKit.enlarge_northwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><code>PEPSKit.enlarge_northwest_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enlarge_northwest_corner(E_west, C_northwest, E_north, A)
</code></pre><p>Contract the enlarged northwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.</p><pre><code class="language-julia hljs">    C_northwest -- E_north --in
         |            |
      E_west    --    A    --
         |            |
        out</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/enlarge_corner.jl#L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.enlarge_southeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><a class="docstring-binding" href="#PEPSKit.enlarge_southeast_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><code>PEPSKit.enlarge_southeast_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enlarge_southeast_corner(E_east, C_southeast, E_south, A)
</code></pre><p>Contract the enlarged southeast corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.</p><pre><code class="language-julia hljs">                         out
            |             |
      --    A    --    E_east
            |             |
    in-- E_south -- C_southeast</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/enlarge_corner.jl#L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.enlarge_southwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><a class="docstring-binding" href="#PEPSKit.enlarge_southwest_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 3, 1} where {T, S}, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><code>PEPSKit.enlarge_southwest_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">enlarge_southwest_corner(E_south, C_southwest, E_west, A)
</code></pre><p>Contract the enlarged southwest corner of the CTMRG environment, either by specifying the coordinates, environments and network, or by directly providing the tensors.</p><pre><code class="language-julia hljs">         in
          |           |
       E_west   --    A    --
          |           |
    C_southwest -- E_south --out</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/enlarge_corner.jl#L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.fidelity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(benv, b1, b2)
</code></pre><p>Given the bond environment <code>benv</code>, calculate the fidelity between two states specified by the bond matrices <code>b1</code>, <code>b2</code></p><pre><code class="language-julia hljs">    F(b1, b2) = (⟨b1|b2⟩ ⟨b2|b1⟩) / (⟨b1|b1⟩ ⟨b2|b2⟩)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/truncation/fullenv_truncation.jl#L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.fidelity-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.fidelity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fidelity(benv, a1b1, a2b2)
</code></pre><p>Calculate the fidelity between two evolution steps</p><pre><code class="language-julia hljs">        |⟨a1,b1|a2,b2⟩|^2
    --------------------------
    ⟨a1,b1|a1,b1⟩⟨a2,b2|a2,b2⟩</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/als_solve.jl#L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}"><code>PEPSKit.fix_gauge_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_corner(corner, σ_out, σ_in)
</code></pre><p>Multiply corner tensor with incoming and outgoing gauge signs.</p><pre><code class="language-julia hljs">    corner -- σ_in --in
      |
     σ_out
      |
     out</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_east_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_east_edge(, env, signs)
</code></pre><p>Apply <code>fix_gauge_edge</code> to the east edge with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_east_left_vecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_east_left_vecs(, U, signs)
</code></pre><p>Multiply east left singular vectors with gauge signs from the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_east_right_vecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_east_right_vecs(, V, signs)
</code></pre><p>Multiply east right singular vectors with gauge signs from the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_edge-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}} where {T, S, N}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_edge-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}, TensorKit.AbstractTensorMap{T, S, 1, 1} where {T, S}}} where {T, S, N}"><code>PEPSKit.fix_gauge_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_edge(edge, σ_out, σ_in)
</code></pre><p>Multiply edge tensor with incoming and outgoing gauge signs.</p><pre><code class="language-julia hljs">    out-- σ_out -- edge -- σ_in --in
                    |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_north_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_north_edge(, env, signs)
</code></pre><p>Apply <code>fix_gauge_edge</code> to the north edge with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_north_left_vecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_north_left_vecs(, U, signs)
</code></pre><p>Multiply north left singular vectors with gauge signs from the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_north_right_vecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_north_right_vecs(, V, signs)
</code></pre><p>Multiply north right singular vectors with gauge signs from the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_northeast_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_northeast_corner(, env, signs)
</code></pre><p>Apply <code>fix_gauge_corner</code> to the northeast corner with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_northwest_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_northwest_corner(, env, signs)
</code></pre><p>Apply <code>fix_gauge_corner</code> to the northwest corner with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_south_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_south_edge(, env, signs)
</code></pre><p>Apply <code>fix_gauge_edge</code> to the south edge with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_south_left_vecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_south_left_vecs(, U, signs)
</code></pre><p>Multiply south left singular vectors with gauge signs from the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_south_right_vecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_south_right_vecs(, V, signs)
</code></pre><p>Multiply south right singular vectors with gauge signs from the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_southeast_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_southeast_corner(, env, signs)
</code></pre><p>Apply <code>fix_gauge_corner</code> to the southeast corner with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_southwest_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_southwest_corner(, env, signs)
</code></pre><p>Apply <code>fix_gauge_corner</code> to the southwest corner with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.fix_gauge_west_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_west_edge(, env, signs)
</code></pre><p>Apply <code>fix_gauge_edge</code> to the west edge with appropriate row and column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_west_left_vecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_west_left_vecs(, U, signs)
</code></pre><p>Multiply west left singular vectors with gauge signs from the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}"><code>PEPSKit.fix_gauge_west_right_vecs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_gauge_west_right_vecs(, V, signs)
</code></pre><p>Multiply west right singular vectors with gauge signs from the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/gaugefix.jl#L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fix_global_phases-Tuple{CTMRGEnv, CTMRGEnv}"><a class="docstring-binding" href="#PEPSKit.fix_global_phases-Tuple{CTMRGEnv, CTMRGEnv}"><code>PEPSKit.fix_global_phases</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fix_global_phases(envfix, envprev)
</code></pre><p>Fix global multiplicative phase of the environment tensors. To that end, the dot products between all corners and all edges are computed to obtain the global phase which is then divided out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/gaugefix.jl#L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fixedpoint-Tuple{Any, InfinitePEPS, Any}"><a class="docstring-binding" href="#PEPSKit.fixedpoint-Tuple{Any, InfinitePEPS, Any}"><code>PEPSKit.fixedpoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fixedpoint(operator, peps₀::InfinitePEPS, env₀; kwargs...) -&gt; peps_final, env_final, cost_final, info
# expert version:
fixedpoint(operator, peps₀::InfinitePEPS, env₀, alg::PEPSOptimize; finalize!=OptimKit._finalize!)</code></pre><p>Find the fixed point of <code>operator</code> (i.e. the ground state) starting from <code>peps₀</code> according to the supplied optimization parameters. The initial environment <code>env₀</code> serves as an initial guess for the first boundary contraction run. By default, a random initial environment is used.</p><p>The optimization parameters can be supplied via the keyword arguments or directly as a <code>PEPSOptimize</code> struct. The following keyword arguments are supported:</p><p><strong>Keyword arguments</strong></p><p><strong>General settings</strong></p><ul><li><code>tol::Real=0.0001</code> : Overall tolerance for gradient norm convergence of the optimizer. Sets related tolerance such as the boundary and boundary-gradient tolerances to sensible defaults unless they are explictly specified.</li><li><code>verbosity::Int=1</code> : Overall output information verbosity level, should be one of the following:<ol><li>Suppress all output</li><li>Only print warnings</li><li>Initialization and convergence info</li><li>Iteration info</li><li>Debug info including AD outputs</li></ol></li><li><code>reuse_env::Bool=true</code> : If <code>true</code>, the current optimization step is initialized on the previous environment, otherwise a random environment is used.</li><li><code>symmetrization::Union{Nothing,SymmetrizationStyle}=nothing</code> : Accepts <code>nothing</code> or a <code>SymmetrizationStyle</code>, in which case the PEPS and PEPS gradient are symmetrized after each optimization iteration.</li><li><code>(finalize!)=OptimKit._finalize!</code> : Inserts a <code>finalize!</code> function call after each optimization step by utilizing the <code>finalize!</code> kwarg of <code>OptimKit.optimize</code>. The function maps <code>(peps, env), f, g = finalize!((peps, env), f, g, numiter)</code>.</li></ul><p><strong>Boundary algorithm</strong></p><p>Supply boundary algorithm parameters via <code>boundary_alg</code> using either a <code>NamedTuple</code> of keyword arguments or a boundary algorithm instance directly. See <a href="#MPSKit.leading_boundary-Tuple{Any, Any, Any}"><code>leading_boundary</code></a> for a description of all possible keyword arguments. By default, a CTMRG tolerance of <code>tol=1e-4tol</code> and is used.</p><p><strong>Gradient algorithm</strong></p><p>Supply gradient algorithm parameters via <code>gradient_alg::Union{NamedTuple,Nothing,&lt;:GradMode}</code> using either a <code>NamedTuple</code> of keyword arguments, <code>nothing</code>, or a <code>GradMode</code> struct directly. Pass <code>nothing</code> to fully differentiate the CTMRG run, meaning that all iterations will be taken into account, instead of differentiating the fixed point. The supported <code>NamedTuple</code> keyword arguments are:</p><ul><li><code>tol::Real=1e-2tol</code> : Convergence tolerance for the fixed-point gradient iteration.</li><li><code>maxiter::Int=30</code> : Maximal number of gradient problem iterations.</li><li><code>alg::Symbol=:eigsolver</code> : Gradient algorithm variant, can be one of the following:<ul><li><code>:geomsum</code> : Compute gradient directly from the geometric sum, see <a href="#PEPSKit.GeomSum"><code>GeomSum</code></a></li><li><code>:manualiter</code> : Iterate gradient geometric sum manually, see <a href="#PEPSKit.ManualIter"><code>ManualIter</code></a></li><li><code>:linsolver</code> : Solve fixed-point gradient linear problem using iterative solver, see <a href="#PEPSKit.LinSolver"><code>LinSolver</code></a></li><li><code>:eigsolver</code> : Determine gradient via eigenvalue formulation of its Sylvester equation, see <a href="#PEPSKit.EigSolver"><code>EigSolver</code></a></li></ul></li><li><code>verbosity::Int</code> : Gradient output verbosity, ≤0 by default to disable too verbose printing. Should only be &gt;0 for debug purposes.</li><li><code>iterscheme::Symbol=:fixed</code> : CTMRG iteration scheme determining mode of differentiation. This can be:<ul><li><code>:fixed</code> : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges</li><li><code>:diffgauge</code> : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well</li></ul></li></ul><p><strong>Optimizer settings</strong></p><p>Supply the optimizer algorithm via <code>optimizer_alg::Union{NamedTuple,&lt;:OptimKit.OptimizationAlgorithm}</code> using either a <code>NamedTuple</code> of keyword arguments or a <code>OptimKit.OptimizationAlgorithm</code> directly. By default, <code>OptimKit.LBFGS</code> is used in combination with a <code>HagerZhangLineSearch</code>. The supported keyword arguments are:</p><ul><li><code>alg::Symbol=:lbfgs</code> : Optimizer algorithm, can be one of the following:<ul><li><code>:gradientdescent</code> : Gradient descent algorithm, see the <a href="https://github.com/Jutho/OptimKit.jl">OptimKit README</a></li><li><code>:conjugategradient</code> : Conjugate gradient algorithm, see the <a href="https://github.com/Jutho/OptimKit.jl">OptimKit README</a></li><li><code>:lbfgs</code> : L-BFGS algorithm, see the <a href="https://github.com/Jutho/OptimKit.jl">OptimKit README</a></li></ul></li><li><code>tol::Real=tol</code> : Gradient norm tolerance of the optimizer.</li><li><code>maxiter::Int=100</code> : Maximal number of optimization steps.</li><li><code>verbosity::Int=3</code> : Optimizer output verbosity.</li><li><code>ls_maxiter::Int=10</code> : Maximal number of linesearch iterations.</li><li><code>ls_maxfg::Int=20</code> : Maximal number of function-gradient evaluations during linesearch.</li><li><code>lbfgs_memory::Int=20</code> : Size of limited memory representation of BFGS Hessian matrix.</li></ul><p><strong>Return values</strong></p><p>The function returns the final PEPS, CTMRG environment and cost value, as well as an information <code>NamedTuple</code> which contains the following entries:</p><ul><li><code>last_gradient</code> : Last gradient of the cost function.</li><li><code>fg_evaluations</code> : Number of evaluations of the cost and gradient function.</li><li><code>costs</code> : History of cost values.</li><li><code>gradnorms</code> : History of gradient norms.</li><li><code>contraction_metrics</code> : History of boundary-algorithm-specific contraction information, e.g. truncation errors and condition numbers.</li><li><code>gradnorms_unitcell</code> : History of gradient norms for each respective unit cell entry.</li><li><code>times</code> : History of optimization step execution times.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/peps_optimization.jl#L87-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fixgauge_benv-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.fixgauge_benv-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 1, 2}, TensorKit.AbstractTensorMap{T, S, 2, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.fixgauge_benv</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Use QR decomposition to fix gauge of the half bond environment <code>Z</code>. The reduced bond tensors <code>a</code>, <code>b</code> and <code>Z</code> are arranged as</p><pre><code class="language-julia hljs">    ┌---------------┐
    |               |
    └---Z---a---b---┘
        |   ↓   ↓
        ↓</code></pre><p>Reference: </p><ul><li>Physical Review B 90, 064425 (2014)</li><li>Physical Review B 92, 035142 (2015)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/gaugefix.jl#L32-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fpgrad"><a class="docstring-binding" href="#PEPSKit.fpgrad"><code>PEPSKit.fpgrad</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)</code></pre><p>Compute the gradient of the CTMRG fixed point by solving the following equation:</p><p>dx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA</p><p>where <code>∂F∂x</code> is the gradient of the cost function with respect to the PEPS tensors, <code>∂f∂x</code> is the partial gradient of the CTMRG iteration with respect to the environment tensors, <code>∂f∂A</code> is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and <code>y0</code> is the initial guess for the fixed-point iteration. The function returns the gradient <code>dx</code> of the fixed-point iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/fixed_point_differentiation.jl#L399-L411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.full_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, NTuple{4, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}"><a class="docstring-binding" href="#PEPSKit.full_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, NTuple{4, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}"><code>PEPSKit.full_infinite_environment</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">full_infinite_environment(quadrant1, quadrant2, quadrant3, quadrant4)
full_infinite_environment(half1, half2)
full_infinite_environment(C_1, C_2, C_3, C_4, E_1, E_2, E_3, E_4, E_5, E_6, E_7, E_8, A_1, A_2, A_3, A_4)
full_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x, A_1, A_2, A_3, A_4)
full_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2, A_3, A_4)</code></pre><p>Contract four quadrants (enlarged corners) to form a full-infinite environment.</p><pre><code class="language-julia hljs">    |~~~~~~~~~| -- |~~~~~~~~~|
    |quadrant1|    |quadrant2|
    |~~~~~~~~~| -- |~~~~~~~~~|
      |     |        |     |
     out             |     |
                     |     |
     in              |     |
      |     |        |     |
    |~~~~~~~~~| -- |~~~~~~~~~|
    |quadrant4|    |quadrant3|
    |~~~~~~~~~| -- |~~~~~~~~~|</code></pre><p>In the same manner two halfs can be used to contract the full-infinite environment.</p><pre><code class="language-julia hljs">    |~~~~~~~~~~~~~~~~~~~~~~~~|
    |         half1          |
    |~~~~~~~~~~~~~~~~~~~~~~~~|
      |     |        |     |
     out             |     |
                     |     |
     in              |     |
      |     |        |     |
    |~~~~~~~~~~~~~~~~~~~~~~~~|
    |         half2          |
    |~~~~~~~~~~~~~~~~~~~~~~~~|</code></pre><p>The environment can also be contracted directly from all its constituent tensors.</p><pre><code class="language-julia hljs">    C_1 -- E_2 -- E_3 -- C_2
     |      |      |      |
    E_1 -- A_1 -- A_2 -- E_4
     |      |      |      |
    out            |      |
                   |      |
    in      |      |      |
     |      |      |      |
    E_8 -- A_4 -- A_3 -- E_5
     |      |      |      |
    C_4 -- E_7 -- E_6 -- C_3</code></pre><p>Alternatively, contract the environment with a vector <code>x</code> acting on it</p><pre><code class="language-julia hljs">    C_1 -- E_2 -- E_3 -- C_2
     |      |      |      |
    E_1 -- A_1 -- A_2 -- E_4
     |      |      |      |
    out            |      |
                   |      |
    [~~~~x~~~]     |      |
     |      |      |      |
    E_8 -- A_4 -- A_3 -- E_5
     |      |      |      |
    C_4 -- E_7 -- E_6 -- C_3
</code></pre><p>or contract the adjoint environment with <code>x</code>, e.g. as needed for iterative solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/fullinf_env.jl#L1-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fullenv_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}, FullEnvTruncation}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.fullenv_truncate-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 2, 2}, FullEnvTruncation}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.fullenv_truncate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fullenv_truncate(benv::BondEnv{T,S}, b0::AbstractTensorMap{T,S,1,1}, alg::FullEnvTruncation) -&gt; U, S, V, info</code></pre><p>Perform full environment truncation algorithm from <a href="../../references/#evenbly_gauge_2018">Phys. Rev. B 98, 085155 (2018)</a> on <code>benv</code>.</p><p>Given a fixed state <code>|b0⟩</code> with bond matrix <code>b0</code> and the corresponding positive-definite bond environment <code>benv</code>,  find the state <code>|b⟩</code> with truncated bond matrix <code>b = u s v†</code> that maximizes the fidelity (not normalized by <code>⟨b0|b0⟩</code>)</p><pre><code class="language-julia hljs">    F(b) = ⟨b|b0⟩⟨b0|b⟩ / ⟨b|b⟩

            ┌----------------------┐  ┌-----------------------┐
            |   ┌----┐             |  |   ┌----┐              |
            └---|    |---- b0 -----┘  └---|    |- u ← s ← v† -┘
                |benv|                    |benv|
            ┌---|    |-u† → s → v -┐  ┌---|    |----- b0† ----┐
            |   └----┘             |  |   └----┘              |
            └----------------------┘  └-----------------------┘
        = ───────────────────────────────────────────────────────
                        ┌-----------------------┐
                        |   ┌----┐              |
                        └---|    |- u ← s ← v† -┘
                            |benv|
                        ┌---|    |- u† → s → v -┐
                        |   └----┘              |
                        └-----------------------┘</code></pre><p>The singular value spectrum <code>s</code> is truncated to desired dimension,  and normalized such that the maximum is 1. Note that <code>benv</code> is contracted to <code>b0</code> using <code>@tensor</code>,  instead of acting on <code>b0</code> as a linear map.</p><p>The algorithm iteratively optimizes the vectors <code>l</code>, <code>r</code></p><pre><code class="language-julia hljs">    --- l -←-  =  --- u ← s -←-  ,  -←- r ---  =  -←- s ← v† ---</code></pre><p><strong>Optimization of <code>r</code></strong></p><p>Define the vector <code>p</code> and the positive map <code>B</code> as</p><pre><code class="language-julia hljs">        ┌---------------┐   ┌-----------------------┐
        |   ┌---┐       |   |   ┌----┐              |
        └---|   |-←   --┘   └---|    |- u ←      ---┘
            | p†|         =     |benv|
        ┌---|   |-------┐   ┌---|    |----- b0† ----┐
        |   └---┘       |   |   └----┘              |
        └---------------┘   └-----------------------┘

        ┌---------------┐   ┌-----------------------┐
        |   ┌---┐       |   |   ┌----┐              |
        └---|   |-←   --┘   └---|    |- u ←      ---┘
            | B |         =     |benv|
        ┌---|   |-→   --┐   ┌---|    |- u†→      ---┐
        |   └---┘       |   |   └----┘              |
        └---------------┘   └-----------------------┘</code></pre><p>Then (each index corresponds to a pair of fused indices)</p><pre><code class="language-julia hljs">    F(r,r†) = |p† r|² / (r† B r)
            = (r† p) (p† r) / (r† B r)</code></pre><p>which is maximized when</p><pre><code class="language-julia hljs">    ∂F/∂r̄ * (r† B r)²
    = p (p† r) (r† B r) - |p† r|² (B r) = 0</code></pre><p>Note that <code>B</code> is positive (consequently <code>B† = B</code>).  Then the solution for the vector <code>r</code> is</p><pre><code class="language-julia hljs">    r = B⁻¹ p</code></pre><p>We can verify that (using <code>B† = B</code>)</p><pre><code class="language-julia hljs">    ∂F/∂r̄ * (r† B r)²
    = p (p† B⁻¹ p) (p† B⁻¹ B B⁻¹ p) - |p† B⁻¹ p|² (B B⁻¹ p) 
    = 0</code></pre><p>Then the bond matrix <code>u s v†</code> is updated by truncated SVD:</p><pre><code class="language-julia hljs">    - u ← r -    ==&gt;    - u ← s ← v† -</code></pre><p><strong>Optimization of <code>l</code></strong></p><p>The process is entirely similar.  Define the vector <code>p</code> and the positive map <code>B</code> as</p><pre><code class="language-julia hljs">        ┌---------------┐   ┌-----------------------┐
        |   ┌---┐       |   |   ┌----┐              |
        └---|   |-  ←-o-┘   └---|    |--   ←-o- v† -┘
            | p†|         =     |benv|
        ┌---|   |-------┐   ┌---|    |----- b0† ----┐
        |   └---┘       |   |   └----┘              |
        └---------------┘   └-----------------------┘

        ┌---------------┐   ┌-----------------------┐
        |   ┌---┐       |   |   ┌----┐              |
        └---|   |-  ←-o-┘   └---|    |--    ←-o- v†-┘
            | B |         =     |benv|
        ┌---|   |-  →-o-┐   ┌---|    |--    →-o- v -┐
        |   └---┘       |   |   └----┘              |
        └---------------┘   └-----------------------┘</code></pre><p>Here <code>o</code> is the parity tensor (twist) necessary for fermions.  Then (each index corresponds to a pair of fused indices)</p><pre><code class="language-julia hljs">    F(l,l†) = |p† l|² / (l† B l)</code></pre><p>which is maximized when</p><pre><code class="language-julia hljs">    l = B⁻¹ p</code></pre><p>Then the bond matrix <code>u s v†</code> is updated by SVD:</p><pre><code class="language-julia hljs">    - l ← v† -   ==&gt;    - u ← s ← v† -</code></pre><p><strong>Return values</strong></p><p>Returns the SVD result of the new bond matrix <code>U</code>, <code>S</code>, <code>V</code>, as well as an information <code>NamedTuple</code> containing the following fields:</p><ul><li><code>fid</code> : Last fidelity.</li><li><code>Δfid</code> : Last fidelity difference.</li><li><code>Δs</code> : Last singular value difference.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/truncation/fullenv_truncation.jl#L94-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.fuse_physicalspaces-Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.fuse_physicalspaces-Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.fuse_physicalspaces</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fuse_physicalspaces(O)
</code></pre><p>Fuse the physical indices of a PEPO tensor, obtaining a PEPS tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/networks/tensors.jl#L152-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.gate_to_mpo3-Union{Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, Any}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.gate_to_mpo3-Union{Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 3, 3}, Any}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.gate_to_mpo3</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Convert a 3-site gate to MPO form by SVD,  in which the axes are ordered as</p><pre><code class="language-julia hljs">    2               3               3
    ↓               ↓               ↓
    g1 ←- 3    1 ←- g2 ←- 4    1 ←- g3
    ↓               ↓               ↓
    1               2               2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L237-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.gauge_fix-Tuple{InfinitePEPS, BPGauge, BPEnv}"><a class="docstring-binding" href="#PEPSKit.gauge_fix-Tuple{InfinitePEPS, BPGauge, BPEnv}"><code>PEPSKit.gauge_fix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gauge_fix(psi::Union{InfinitePEPS, InfinitePEPO}, alg::BPGauge, env::BPEnv)</code></pre><p>Fix the gauge of <code>psi</code> (which can be an <a href="#PEPSKit.InfinitePEPS"><code>InfinitePEPS</code></a>, or an <a href="#PEPSKit.InfinitePEPO"><code>InfinitePEPO</code></a> interpreted as purified state with two physical legs)  using fixed point environment <code>env</code> of belief propagation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/bp/gaugefix.jl#L20-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.gauge_fix-Tuple{PEPSKit.CTMRGAlgorithm, Any, Any}"><a class="docstring-binding" href="#PEPSKit.gauge_fix-Tuple{PEPSKit.CTMRGAlgorithm, Any, Any}"><code>PEPSKit.gauge_fix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gauge_fix(alg::CTMRGAlgorithm, signs, info)
gauge_fix(alg::ProjectorAlgorithm, signs, info)</code></pre><p>Fix the free gauges of the tensor decompositions associated with <code>alg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/gaugefix.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.gauge_fix-Tuple{Union{InfinitePEPO, InfinitePEPS}, SUGauge}"><a class="docstring-binding" href="#PEPSKit.gauge_fix-Tuple{Union{InfinitePEPO, InfinitePEPS}, SUGauge}"><code>PEPSKit.gauge_fix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gauge_fix(psi::Union{InfinitePEPS, InfinitePEPO}, alg::SUGauge)</code></pre><p>Fix the gauge of <code>psi</code> using trivial simple update.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/gaugefix_su.jl#L38-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}, PEPSKit.ScramblingEnvGauge}} where {C, T}"><a class="docstring-binding" href="#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}, PEPSKit.ScramblingEnvGauge}} where {C, T}"><code>PEPSKit.gauge_fix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gauge_fix(envfinal, envprev, _)
</code></pre><p>Fix the gauge of <code>envfinal</code> based on the previous environment <code>envprev</code>. This assumes that the <code>envfinal</code> is the result of one CTMRG iteration on <code>envprev</code>. Given that the CTMRG run is converged, the returned environment will be element-wise converged to <code>envprev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/gaugefix.jl#L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.get_3site_se-Tuple{Union{InfinitePEPO, InfinitePEPS}, SUWeight, Int64, Int64}"><a class="docstring-binding" href="#PEPSKit.get_3site_se-Tuple{Union{InfinitePEPO, InfinitePEPS}, SUWeight, Int64, Int64}"><code>PEPSKit.get_3site_se</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Obtain the 3-site cluster in the &quot;southeast corner&quot; of a square plaquette.</p><pre><code class="language-julia hljs">    r-1         M3
                |
                ↓
    r   M1 -←- M2
        c      c+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate3site.jl#L423-L432">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.get_expham-Tuple{LocalOperator, Number}"><a class="docstring-binding" href="#PEPSKit.get_expham-Tuple{LocalOperator, Number}"><code>PEPSKit.get_expham</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_expham(H::LocalOperator, dt::Number)</code></pre><p>Compute <code>exp(-dt * op)</code> for each term <code>op</code> in <code>H</code>, and combine them into a new LocalOperator. Each <code>op</code> in <code>H</code> must be a single <code>TensorMap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L32-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.get_gateterm-Tuple{LocalOperator, Tuple{CartesianIndex{2}, CartesianIndex{2}}}"><a class="docstring-binding" href="#PEPSKit.get_gateterm-Tuple{LocalOperator, Tuple{CartesianIndex{2}, CartesianIndex{2}}}"><code>PEPSKit.get_gateterm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_gateterm(gate::LocalOperator, bond::NTuple{2,CartesianIndex{2}})</code></pre><p>Get the term of a 2-site gate acting on a certain bond. Input <code>gate</code> should only include one term for each nearest neighbor bond.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L72-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.half_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}"><a class="docstring-binding" href="#PEPSKit.half_infinite_environment-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, N, N}, TensorKit.AbstractTensorMap{T, S, N, N}}} where {T, S, N}"><code>PEPSKit.half_infinite_environment</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">half_infinite_environment(quadrant1, quadrant2)
half_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2)
half_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x, A_1, A_2)
half_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4, A_1, A_2)</code></pre><p>Contract two quadrants (enlarged corners) to form a half-infinite environment.</p><pre><code class="language-julia hljs">    |~~~~~~~~~| -- |~~~~~~~~~|
    |quadrant1|    |quadrant2|
    |~~~~~~~~~| -- |~~~~~~~~~|
      |     |        |     |
     out                   in</code></pre><p>The environment can also be contracted directly from all its constituent tensors.</p><pre><code class="language-julia hljs">    C_1 -- E_2 -- E_3 -- C_2
     |      |      |      |
    E_1 -- A_1 -- A_2 -- E_4
     |      |      |      |
    out                   in</code></pre><p>Alternatively, contract the environment with a vector <code>x</code> acting on it</p><pre><code class="language-julia hljs">    C_1 -- E_2 -- E_3 -- C_2
     |      |      |      |
    E_1 -- A_1 -- A_2 -- E_4
     |      |      |      |
    out           [~~~x~~~~]</code></pre><p>or contract the adjoint environment with <code>x</code>, e.g. as needed for iterative solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/halfinf_env.jl#L1-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}"><code>PEPSKit.hook_pullback</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hook_pullback(f, args...; alg_rrule=nothing, kwargs...)</code></pre><p>Wrapper function to customize the pullback of a function <code>f</code>. This function is equivalent to <code>f(args...; kwargs...)</code>, but the pullback can be customized by implementing the following function:</p><pre><code class="language-julia hljs">_rrule(alg_rrule, config, f, args...; kwargs...) -&gt; NoTangent(), ∂f, ∂args...</code></pre><p>This function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default <code>alg_rrule=nothing</code> results in the default AD pullback.</p><p>See also <a href="#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}"><code>_rrule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/hook_pullback.jl#L10-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.initialize_mps-Tuple{Union{MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), O&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)}, MPSKit.MultilineMPO{&lt;:MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), O&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)}}}, Any}"><a class="docstring-binding" href="#PEPSKit.initialize_mps-Tuple{Union{MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), O&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)}, MPSKit.MultilineMPO{&lt;:MPSKit.MPO{Tuple{T, T, Vararg{O, H}}, MPSKit.PeriodicArray{Tuple{T, T, Vararg{O, H}}, 1}} where {H, T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace), O&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace)}}}, Any}"><code>PEPSKit.initialize_mps</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_mps(
    f=randn,
    T=scalartype(O),
    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},
    virtualspaces::AbstractArray{&lt;:ElementarySpace,1}
)
initialize_mps(
    f=randn,
    T=scalartype(O),
    O::Union{MultilineTransferPEPS,MultilineTransferPEPO},
    virtualspaces::AbstractArray{&lt;:ElementarySpace,2}
)</code></pre><p>Inialize a boundary MPS for the transfer operator <code>O</code> by specifying an array of virtual spaces consistent with the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/transfermatrix.jl#L127-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.initialize_random_c4v_env-Tuple{Any, TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.initialize_random_c4v_env-Tuple{Any, TensorKit.ElementarySpace}"><code>PEPSKit.initialize_random_c4v_env</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_random_c4v_env([f=randn, T=scalartype(state)], state, Venv::ElementarySpace)</code></pre><p>Initialize a C₄ᵥ-symmetric <code>CTMRGEnv</code> on virtual spaces <code>Venv</code> with random entries created by <code>f</code> and scalartype <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/c4v.jl#L331-L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.initialize_singlet_c4v_env-Tuple{InfinitePEPS, TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.initialize_singlet_c4v_env-Tuple{InfinitePEPS, TensorKit.ElementarySpace}"><code>PEPSKit.initialize_singlet_c4v_env</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_singlet_c4v_env([T=scalartype(state)], state::InfinitePEPS, Venv::ElementarySpace)</code></pre><p>Initialize a C₄ᵥ-symmetric <code>CTMRGEnv</code> with a singlet corner of dimension <code>dim(Venv)</code> and an identity edge from <code>id(T, Venv ⊗ Vpeps)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/c4v.jl#L355-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 1, 1}, TensorKit.AbstractTensorMap{T, S, 1, 1}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.inner_prod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inner_prod(benv, b1, b2)
</code></pre><p>Given the bond environment <code>benv</code>, calculate the inner product between two states specified by the bond matrices <code>b1</code>, <code>b2</code></p><pre><code class="language-julia hljs">            ┌--------------------┐
            |   ┌----┐           |
            └---|    |---- b2 ---┘
    ⟨b1|b2⟩ =   |benv|
            ┌---|    |---- b1†---┐
            |   └----┘           |
            └--------------------┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/truncation/fullenv_truncation.jl#L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.inner_prod-Union{Tuple{S}, Tuple{T}, Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.inner_prod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inner_prod(benv, a1b1, a2b2)
</code></pre><p>Calculate the inner product &lt;a1,b1|a2,b2&gt;</p><pre><code class="language-julia hljs">    ┌--------------------------------┐
    |   ┌----┐                       |
    └---|    |- DX0 - (a2 b2) - DY0 -┘
        |    |        ↓    ↓
        |benv|        da   db
        |    |        ↓    ↓
    ┌---|    |- DX1 - (a1 b1)†- DY1 -┐
    |   └----┘                       |
    └--------------------------------┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/als_solve.jl#L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.is_equivalent_bond-Tuple{Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{Int64, Int64}}"><a class="docstring-binding" href="#PEPSKit.is_equivalent_bond-Tuple{Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{Int64, Int64}}"><code>PEPSKit.is_equivalent_bond</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_equivalent_bond(bond1::NTuple{2,CartesianIndex{2}}, bond2::NTuple{2,CartesianIndex{2}}, (Nrow, Ncol)::NTuple{2,Int})</code></pre><p>Check if two 2-site bonds are related by a (periodic) lattice translation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L56-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.is_nearest_neighbour-Tuple{LocalOperator}"><a class="docstring-binding" href="#PEPSKit.is_nearest_neighbour-Tuple{LocalOperator}"><code>PEPSKit.is_nearest_neighbour</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_nearest_neighbour(H::LocalOperator)</code></pre><p>Check if an operator <code>H</code> contains only nearest neighbor terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/evoltools.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.j1_j2_model-Tuple{InfiniteSquare}"><a class="docstring-binding" href="#PEPSKit.j1_j2_model-Tuple{InfiniteSquare}"><code>PEPSKit.j1_j2_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">j1_j2_model([elt::Type{T}, symm::Type{S},] lattice::InfiniteSquare;
            J1=1.0, J2=1.0, spin=1//2, sublattice=true)</code></pre><p>Square lattice <span>$J_1\text{-}J_2$</span> model, defined by the Hamiltonian</p><p class="math-container">\[H = J_1 \sum_{\langle i,j \rangle} \vec{S}_i \cdot \vec{S}_j
+ J_2 \sum_{\langle\langle i,j \rangle\rangle} \vec{S}_i \cdot \vec{S}_j,\]</p><p>where <span>$\vec{S}_i = (S_i^x, S_i^y, S_i^z)$</span>. We denote the nearest and next-nearest neighbor terms using <span>$\langle i,j \rangle$</span> and <span>$\langle\langle i,j \rangle\rangle$</span>, respectively. The <code>sublattice</code> kwarg enables a single-site unit cell ground state via a unitary sublattice rotation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/models.jl#L148-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.left_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><a class="docstring-binding" href="#PEPSKit.left_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><code>PEPSKit.left_projector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">left_projector(E_1, C, E_2, V, isqS, A)
</code></pre><p>Contract the CTMRG left projector with the higher-dimensional subspace facing to the left.</p><pre><code class="language-julia hljs">     C  --  E_2    -- |~~|
     |       |        |V&#39;| -- isqS --in
    E_1 --   A     -- |~~|
     |       |
    out</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/projector.jl#L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.lq_through-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{T, S, 4, 1} where T, TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}}} where S&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#PEPSKit.lq_through-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{T, S, 4, 1} where T, TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit.lq_through</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Perform LQ decomposition through a tensor</p><pre><code class="language-julia hljs">             ╱            ╱
    -←-L0-←-Q-←-  &lt;=  -←-M-←-L1-←-
          ╱ |          ╱ |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate3site.jl#L142-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.nearest_neighbour_hamiltonian-Union{Tuple{T}, Tuple{S}, Tuple{Matrix{S}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {S, T}"><a class="docstring-binding" href="#PEPSKit.nearest_neighbour_hamiltonian-Union{Tuple{T}, Tuple{S}, Tuple{Matrix{S}, TensorKit.AbstractTensorMap{T, S, 2, 2}}} where {S, T}"><code>PEPSKit.nearest_neighbour_hamiltonian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nearest_neighbour_hamiltonian(lattice::Matrix{S}, h::AbstractTensorMap{T,S,2,2}) where {S,T}</code></pre><p>Create a nearest neighbor <code>LocalOperator</code> by specifying the 2-site interaction term <code>h</code> which acts both in horizontal and vertical direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/models.jl#L5-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.network_value-Tuple{InfiniteSquareNetwork, CTMRGEnv}"><a class="docstring-binding" href="#PEPSKit.network_value-Tuple{InfiniteSquareNetwork, CTMRGEnv}"><code>PEPSKit.network_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">network_value(network::InfiniteSquareNetwork, env::CTMRGEnv)</code></pre><p>Return the value (per unit cell) of a given contractible network contracted using a given CTMRG environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L77-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.norm_preserving_retract-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.norm_preserving_retract-Tuple{Any, Any, Any}"><code>PEPSKit.norm_preserving_retract</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm_preserving_retract(A, η, α)
</code></pre><p>Performs a norm-preserving retraction of vector <code>A</code> along the direction <code>η</code> with step size <code>α</code>, giving a new vector <code>A´</code>,</p><p class="math-container">\[A&#39; ← \cos ( α ‖η‖ / ‖A‖ ) A + \sin ( α ‖η‖ / ‖A‖ ) ‖A‖ η / ‖η‖,\]</p><p>and corresponding directional derivative <code>ξ</code>,</p><p class="math-container">\[ξ = \cos ( α ‖η‖ / ‖A‖ ) η - \sin ( α ‖η‖ / ‖A‖ ) ‖η‖ A / ‖A‖,\]</p><p>such that <span>$⟨ A&#39;, ξ ⟩ = 0$</span> and <span>$‖A&#39;‖ = ‖A‖$</span>.</p><div class="admonition is-info" id="Note-cac2b841efbbcc2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-cac2b841efbbcc2" title="Permalink"></a></header><div class="admonition-body"><p>The vectors <code>A</code> and <code>η</code> should satisfy the interface specified by <a href="https://github.com/Jutho/VectorInterface.jl">VectorInterface.jl</a></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/retractions.jl#L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.norm_preserving_transport!-NTuple{5, Any}"><a class="docstring-binding" href="#PEPSKit.norm_preserving_transport!-NTuple{5, Any}"><code>PEPSKit.norm_preserving_transport!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm_preserving_transport!(ξ, A, η, α, A´)
</code></pre><p>Transports a direction <code>ξ</code> at <code>A</code> to a valid direction at <code>A´</code> corresponding to the norm-preserving retraction of <code>A</code> along <code>η</code> with step size <code>α</code>. In particular, starting from a direction <code>η</code> of the form</p><p class="math-container">\[ξ = ⟨ η / ‖η‖, ξ ⟩ η / ‖η‖ + Δξ\]</p><p>where <span>$⟨ Δξ, A ⟩ = ⟨ Δξ, η ⟩ = 0$</span>, it returns</p><p class="math-container">\[ξ(α) = ⟨ η / ‖η‖, ξ ⟩ ( \cos ( α ‖η‖ / ‖A‖ ) η / ‖η‖ - \sin ( α ‖η‖ / ‖A‖ ) A / ‖A‖ ) + Δξ\]</p><p>such that <span>$‖ξ(α)‖ = ‖ξ‖, ⟨ A&#39;, ξ(α) ⟩ = 0$</span>.</p><div class="admonition is-info" id="Note-cac2b841efbbcc2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-cac2b841efbbcc2" title="Permalink"></a></header><div class="admonition-body"><p>The vectors <code>A</code> and <code>η</code> should satisfy the interface specified by <a href="https://github.com/Jutho/VectorInterface.jl">VectorInterface.jl</a></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/retractions.jl#L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.peps_normalize-Tuple{InfinitePEPS}"><a class="docstring-binding" href="#PEPSKit.peps_normalize-Tuple{InfinitePEPS}"><code>PEPSKit.peps_normalize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">peps_normalize(A::InfinitePEPS)</code></pre><p>Normalize the individual tensors in the unit cell of an <code>InfinitePEPS</code> such that they each have unit Euclidean norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/peps_optimization.jl#L254-L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.peps_retract-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.peps_retract-Tuple{Any, Any, Any}"><code>PEPSKit.peps_retract</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">peps_retract(x, η, α)
</code></pre><p>Performs a norm-preserving retraction of an infinite PEPS <code>A = x[1]</code> along <code>η</code> with step size <code>α</code>, giving a new PEPS <code>A´</code>,</p><p class="math-container">\[A&#39; ← \cos ( α ‖η‖ / ‖A‖ ) A + \sin ( α ‖η‖ / ‖A‖ ) ‖A‖ η / ‖η‖,\]</p><p>and corresponding directional derivative <code>ξ</code>,</p><p class="math-container">\[ξ = \cos ( α ‖η‖ / ‖A‖ ) η - \sin ( α ‖η‖ / ‖A‖ ) ‖η‖ A / ‖A‖,\]</p><p>such that <span>$⟨ A&#39;, ξ ⟩ = 0$</span> and <span>$‖A&#39;‖ = ‖A‖$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/peps_optimization.jl#L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.peps_transport!-NTuple{5, Any}"><a class="docstring-binding" href="#PEPSKit.peps_transport!-NTuple{5, Any}"><code>PEPSKit.peps_transport!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">peps_transport!(ξ, x, η, α, x´)
</code></pre><p>Transports a direction at <code>A = x[1]</code> to a valid direction at <code>A´ = x´[1]</code> corresponding to the norm-preserving retraction of <code>A</code> along <code>η</code> with step size <code>α</code>. In particular, starting from a direction <code>η</code> of the form</p><p class="math-container">\[ξ = ⟨ η / ‖η‖, ξ ⟩ η / ‖η‖ + Δξ\]</p><p>where <span>$⟨ Δξ, A ⟩ = ⟨ Δξ, η ⟩ = 0$</span>, it returns</p><p class="math-container">\[ξ(α) = ⟨ η / ‖η‖, ξ ⟩ ( \cos ( α ‖η‖ / ‖A‖ ) η / ‖η‖ - \sin( α ‖η‖ / ‖A‖ ) A / ‖A‖ ) + Δξ\]</p><p>such that <span>$‖ξ(α)‖ = ‖ξ‖, ⟨ A&#39;, ξ(α) ⟩ = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/peps_optimization.jl#L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.positive_approx-Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}}"><a class="docstring-binding" href="#PEPSKit.positive_approx-Tuple{TensorKit.AbstractTensorMap{T, S, 2, 2} where {T&lt;:Number, S&lt;:TensorKit.ElementarySpace}}"><code>PEPSKit.positive_approx</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Replace bond environment <code>benv</code> by its positive approximant <code>Z† Z</code> (returns the &quot;half environment&quot; <code>Z</code>)</p><pre><code class="language-julia hljs">    ┌-----------------┐     ┌---------------┐
    | ┌----┐          |     |               |
    └-|    |-- 3  4 --┘     └-- Z -- 3  4 --┘
      |benv|            =       ↓
    ┌-|    |-- 1  2 --┐     ┌-- Z†-- 1  2 --┐
    | └----┘          |     |               |
    └-----------------┘     └---------------┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/bondenv/gaugefix.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.product_peps-Tuple"><a class="docstring-binding" href="#PEPSKit.product_peps-Tuple"><code>PEPSKit.product_peps</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">product_peps(peps_args...; unitcell=(1, 1), noise_amp=1e-2, state_vector=nothing)</code></pre><p>Initialize a normalized random product PEPS with noise. The given arguments are passed on to the <code>InfinitePEPS</code> constructor.</p><p>The noise intensity can be tuned with <code>noise_amp</code>. The product state coefficients can be specified using the <code>state_vector</code> kwarg in the form of a matrix of size <code>unitcell</code> containing vectors that match the PEPS physical dimensions. If <code>nothing</code> is provided, random Gaussian coefficients are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/toolbox.jl#L337-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.pwave_superconductor-Tuple{InfiniteSquare}"><a class="docstring-binding" href="#PEPSKit.pwave_superconductor-Tuple{InfiniteSquare}"><code>PEPSKit.pwave_superconductor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pwave_superconductor([T=ComplexF64,] lattice::InfiniteSquare; t=1, μ=2, Δ=1)</code></pre><p>Square lattice <span>$p$</span>-wave superconductor model, defined by the Hamiltonian</p><p class="math-container">\[    H = -\sum_{\langle i,j \rangle} \left( t c_i^\dagger c_j +
    \Delta c_i c_j + \text{h.c.} \right) - \mu \sum_i n_i,\]</p><p>where <span>$t$</span> is the hopping amplitude, <span>$\Delta$</span> specifies the superconducting gap, <span>$\mu$</span> is the chemical potential, and <span>$n_i = c_i^\dagger c_i$</span> is the fermionic number operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/operators/models.jl#L185-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.qr_through-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}, TensorKit.AbstractTensorMap{T, S, 4, 1} where T}} where S&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#PEPSKit.qr_through-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{T, S, 1, 1} where {S, T}, TensorKit.AbstractTensorMap{T, S, 4, 1} where T}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit.qr_through</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Perform QR decomposition through a PEPS tensor</p><pre><code class="language-julia hljs">             ╱            ╱
    -←-R0-←-M-←-  =&gt;  ---Q-←-R1-←-
          ╱ |          ╱ |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate3site.jl#L114-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.random_dual!-Union{Tuple{AbstractMatrix{E}}, Tuple{E}} where E&lt;:TensorKit.ElementarySpace"><a class="docstring-binding" href="#PEPSKit.random_dual!-Union{Tuple{AbstractMatrix{E}}, Tuple{E}} where E&lt;:TensorKit.ElementarySpace"><code>PEPSKit.random_dual!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Randomly take the dual of <code>ElementarySpace</code>s in <code>Vs</code> with propability <code>p</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/util.jl#L209-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.reduced_densitymatrix"><a class="docstring-binding" href="#PEPSKit.reduced_densitymatrix"><code>PEPSKit.reduced_densitymatrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Construct the reduced density matrix <code>ρ</code> of PEPS or PEPO (representing PEPS with ancilla legs) <code>ket</code>, <code>bra</code> with open indices <code>inds</code> using the environment <code>env</code>. Alternatively, construct the reduced density matrix <code>ρ</code> of a mixed state specified by the density matrix PEPO <code>state</code> with open indices <code>inds</code> using the environment <code>env</code>.</p><p>This works by generating the appropriate contraction on a rectangular patch with its corners specified by <code>inds</code>. The result is normalized such that <code>tr(ρ) = 1</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/localoperator.jl#L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_corner-Union{Tuple{N}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, N, N}, TensorKit.AbstractTensorMap{&lt;:Any, S, N, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N}}} where {S, N}"><a class="docstring-binding" href="#PEPSKit.renormalize_corner-Union{Tuple{N}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, N, N}, TensorKit.AbstractTensorMap{&lt;:Any, S, N, 1}, TensorKit.AbstractTensorMap{&lt;:Any, S, 1, N}}} where {S, N}"><code>PEPSKit.renormalize_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_corner(quadrant, P_left, P_right)
</code></pre><p>Apply projectors to each side of a quadrant.</p><pre><code class="language-julia hljs">    |~~~~~~~~| -- |~~~~~~|
    |quadrant|    |P_left| --in
    |~~~~~~~~| -- |~~~~~~|
     |     |
    [P_right]
        |
       out</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_corner.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_east_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}"><a class="docstring-binding" href="#PEPSKit.renormalize_east_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}"><code>PEPSKit.renormalize_east_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_east_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})
renormalize_east_edge(E_east, P_left, P_right, A::P)</code></pre><p>Absorb a local effective tensor into the east edge using the given projectors and environment tensors.</p><pre><code class="language-julia hljs">          out
           |
      [~P_right~]
       |       |
    -- A -- E_east
       |       |
      [~~P_left~]
           |
           in</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_edge.jl#L70-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_north_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}"><a class="docstring-binding" href="#PEPSKit.renormalize_north_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}"><code>PEPSKit.renormalize_north_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_north_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})
renormalize_north_edge(E_north, P_left, P_right, A::P)</code></pre><p>Absorb a local effective tensor <code>A</code> into the north edge using the given projectors and environment tensors.</p><pre><code class="language-julia hljs">          |~~~~~~~| -- E_north -- |~~~~~~|
    out-- |P_right|       |       |P_left| --in
          |~~~~~~~| --    A    -- |~~~~~~|
                          |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_edge.jl#L4-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_northeast_corner-NTuple{4, Any}"><a class="docstring-binding" href="#PEPSKit.renormalize_northeast_corner-NTuple{4, Any}"><code>PEPSKit.renormalize_northeast_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_northeast_corner((row, col), enlarged_env, P_left, P_right)
renormalize_northeast_corner(quadrant, P_left, P_right)
renormalize_northeast_corner(E_north, C_northeast, E_east, P_left, P_right, A)</code></pre><p>Apply <code>renormalize_corner</code> to the enlarged northeast corner.</p><pre><code class="language-julia hljs">          |~~~~~~~| -- |~~~~~~~~|
    out-- |P_right|    |quadrant|
          |~~~~~~~| -- |~~~~~~~~|
                         |    |
                        [P_left]
                            |
                            in</code></pre><p>Alternatively, provide the constituent tensors and perform the complete contraction.</p><pre><code class="language-julia hljs">          |~~~~~~~| -- E_north -- C_northeast
    out-- |P_right|       |            |
          |~~~~~~~| --    A    --    E_east
                          |            |
                        [~~~~~P_left~~~~~]
                                 |
                                 in</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_corner.jl#L133-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_northwest_corner-NTuple{4, Any}"><a class="docstring-binding" href="#PEPSKit.renormalize_northwest_corner-NTuple{4, Any}"><code>PEPSKit.renormalize_northwest_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_northwest_corner((row, col), enlarged_env, P_left, P_right)
renormalize_northwest_corner(quadrant, P_left, P_right)
renormalize_northwest_corner(E_west, C_northwest, E_north, P_left, P_right, A)</code></pre><p>Apply <code>renormalize_corner</code> to the enlarged northwest corner.</p><pre><code class="language-julia hljs">    |~~~~~~~~| -- |~~~~~~|
    |quadrant|    |P_left| --in
    |~~~~~~~~| -- |~~~~~~|
     |     |
    [P_right]
        |
       out</code></pre><p>Alternatively, provide the constituent tensors and perform the complete contraction.</p><pre><code class="language-julia hljs">    C_northwest -- E_north -- |~~~~~~|
         |           |        |P_left| --in
      E_west    --   A     -- |~~~~~~|
         |           |
      [~~~~~P_right~~~~]
               |
              out</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_corner.jl#L46-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_northwest_corner-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.renormalize_northwest_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.renormalize_northwest_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_northwest_corner((row, col), env, projectors)
renormalize_northwest_corner(C_northwest, E_north, P_right)</code></pre><p>Apply right projector to northwest corner and north edge.</p><pre><code class="language-julia hljs">     C --- E --in
     |     |
    [P_right]
        |
       out</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_corner.jl#L438-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_sequentially-Tuple{Int64, Any, Any, Any}"><a class="docstring-binding" href="#PEPSKit.renormalize_sequentially-Tuple{Int64, Any, Any, Any}"><code>PEPSKit.renormalize_sequentially</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_sequentially(col::Int, projectors, network, env)</code></pre><p>Renormalize one column of the CTMRG environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sequential.jl#L123-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_simultaneously-NTuple{4, Any}"><a class="docstring-binding" href="#PEPSKit.renormalize_simultaneously-NTuple{4, Any}"><code>PEPSKit.renormalize_simultaneously</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_simultaneously(
    enlarged_corners,
    projectors,
    network,
    env
)
</code></pre><p>Renormalize all enlarged corners and edges simultaneously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/simultaneous.jl#L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_south_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}"><a class="docstring-binding" href="#PEPSKit.renormalize_south_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}"><code>PEPSKit.renormalize_south_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_south_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})
renormalize_south_edge(E_south, P_left, P_right, A::P)</code></pre><p>Absorb a local effective tensor into the south edge using the given projectors and environment tensors.</p><pre><code class="language-julia hljs">                        |
         |~~~~~~| --    A    -- |~~~~~~~|
    in-- |P_left|       |       |P_right| --out
         |~~~~~~| -- E_south -- |~~~~~~~|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_edge.jl#L140-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_southeast_corner-NTuple{4, Any}"><a class="docstring-binding" href="#PEPSKit.renormalize_southeast_corner-NTuple{4, Any}"><code>PEPSKit.renormalize_southeast_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_southeast_corner((row, col), enlarged_env, P_left, P_right)
renormalize_southeast_corner(quadrant, P_left, P_right)
renormalize_southeast_corner(E_east, C_southeast, E_south, P_left, P_right, A)</code></pre><p>Apply <code>renormalize_corner</code> to the enlarged southeast corner.</p><pre><code class="language-julia hljs">                         out
                          |
                      [P_right]
                        |   |
         |~~~~~~| -- |~~~~~~~~|
    in-- |P_left|    |quadrant|
         |~~~~~~| -- |~~~~~~~~|</code></pre><p>Alternatively, provide the constituent tensors and perform the complete contraction.</p><pre><code class="language-julia hljs">                             out
                              |
                      [~~~~P_right~~~~]
                        |           |
         |~~~~~~| --    A    --   E_east
    in-- |P_left|       |           |
         |~~~~~~| -- E_south -- C_southeast</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_corner.jl#L222-L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_southwest_corner-NTuple{4, Any}"><a class="docstring-binding" href="#PEPSKit.renormalize_southwest_corner-NTuple{4, Any}"><code>PEPSKit.renormalize_southwest_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_southwest_corner((row, col), enlarged_env, P_left, P_right)
renormalize_southwest_corner(quadrant, P_left, P_right)
renormalize_southwest_corner(E_south, C_southwest, E_west, P_left, P_right, A)</code></pre><p>Apply <code>renormalize_corner</code> to the enlarged southwest corner.</p><pre><code class="language-julia hljs">         in
         |
     [P_left]
      |    |
    |~~~~~~~~| -- |~~~~~~~|
    |quadrant|    |P_right| --out
    |~~~~~~~~| -- |~~~~~~~|</code></pre><p>Alternatively, provide the constituent tensors and perform the complete contraction.</p><pre><code class="language-julia hljs">               in
               |
       [~~~~~P_left~~~~~]
         |            |
       E_west   --    A    -- |~~~~~~~|
         |            |       |P_right| --out
    C_southwest -- E_south -- |~~~~~~~|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_corner.jl#L309-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_southwest_corner-Tuple{Any, CTMRGEnv, Any}"><a class="docstring-binding" href="#PEPSKit.renormalize_southwest_corner-Tuple{Any, CTMRGEnv, Any}"><code>PEPSKit.renormalize_southwest_corner</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_southwest_corner((r, c), env, projectors)
renormalize_southwest_corner(C_southwest, E_south, P_left)</code></pre><p>Apply left projector to southwest corner and south edge.</p><pre><code class="language-julia hljs">        in
        |
    [P_left]
     |    |
     C -- E --out</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_corner.jl#L396-L408">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.renormalize_west_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}"><a class="docstring-binding" href="#PEPSKit.renormalize_west_edge-Tuple{Any, CTMRGEnv, Any, Any, InfiniteSquareNetwork}"><code>PEPSKit.renormalize_west_edge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">renormalize_west_edge((row, col), env, P_left, P_right, network::InfiniteSquareNetwork{P})
renormalize_west_edge(E_west, P_left, P_right, A::P)</code></pre><p>Absorb a local effective tensor into the west edge using the given projectors and environment tensors.</p><pre><code class="language-julia hljs">          in
          |
     [~~P_left~]
      |       |
    E_west -- A --
      |       |
     [~P_right~]
          |
         out</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/renormalize_edge.jl#L205-L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.right_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><a class="docstring-binding" href="#PEPSKit.right_projector-Tuple{Any, Any, Any, Any, Any, Tuple{T, T} where T&lt;:(TensorKit.AbstractTensorMap{&lt;:Any, S, 1, 4} where S&lt;:TensorKit.ElementarySpace)}"><code>PEPSKit.right_projector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">right_projector(E_1, C, E_2, U, isqS, A)
</code></pre><p>Contract the CTMRG right projector with the higher-dimensional subspace facing to the right.</p><pre><code class="language-julia hljs">                  |~~| --   E_2   --  C
    out-- isqS -- |U&#39;|      |         |
                  |~~| --   A     -- E_1
                            |         |
                                      in</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/contractions/ctmrg/projector.jl#L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.rotate_north-Tuple{Any, Any}"><a class="docstring-binding" href="#PEPSKit.rotate_north-Tuple{Any, Any}"><code>PEPSKit.rotate_north</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rotate_north(t, dir)
</code></pre><p>Rotate the <code>dir</code> direction of <code>t</code> to face north by successive applications of <code>rotl90</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/rotations.jl#L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.sdiag_pow-Tuple{TensorKit.DiagonalTensorMap, Real}"><a class="docstring-binding" href="#PEPSKit.sdiag_pow-Tuple{TensorKit.DiagonalTensorMap, Real}"><code>PEPSKit.sdiag_pow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sdiag_pow(s, pow::Real; tol::Real=eps(real(scalartype(s)))^(3 / 4))</code></pre><p>Compute <code>s^pow</code> for a diagonal matrix <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/util.jl#L50-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.select_algorithm"><a class="docstring-binding" href="#PEPSKit.select_algorithm"><code>PEPSKit.select_algorithm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">select_algorithm(func_or_alg, args...; kwargs...) -&gt; Algorithm</code></pre><p>Parse arguments and keyword arguments to the algorithm struct corresponding to <code>func_or_alg</code> and return an algorithm instance. To that end, we use a general interface where all keyword arguments that can be algorithm themselves can be specified using</p><ul><li><code>alg::Algorithm</code> : an instance of the algorithm struct or</li><li><code>(; alg::Symbol, alg_kwargs...)</code> : a <code>NamedTuple</code> where the algorithm is specified by a <code>Symbol</code> and the algorithm keyword arguments </li></ul><p>A full description of the keyword argument can be found in the respective function or algorithm struct docstrings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/select_algorithm.jl#L5-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.sequential_projectors-Tuple{Int64, Any, CTMRGEnv, PEPSKit.ProjectorAlgorithm}"><a class="docstring-binding" href="#PEPSKit.sequential_projectors-Tuple{Int64, Any, CTMRGEnv, PEPSKit.ProjectorAlgorithm}"><code>PEPSKit.sequential_projectors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sequential_projectors(col::Int, network, env::CTMRGEnv, alg::ProjectorAlgorithm)
sequential_projectors(coordinate::NTuple{3,Int}, network::InfiniteSquareNetwork, env::CTMRGEnv, alg::ProjectorAlgorithm)</code></pre><p>Compute CTMRG projectors in the <code>:sequential</code> scheme either for an entire column <code>col</code> or for a specific <code>coordinate</code> (where <code>dir=WEST</code> is already implied in the <code>:sequential</code> scheme).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/sequential.jl#L75-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.simultaneous_projectors-Union{Tuple{E}, Tuple{Array{E, 3}, CTMRGEnv, PEPSKit.ProjectorAlgorithm}} where E"><a class="docstring-binding" href="#PEPSKit.simultaneous_projectors-Union{Tuple{E}, Tuple{Array{E, 3}, CTMRGEnv, PEPSKit.ProjectorAlgorithm}} where E"><code>PEPSKit.simultaneous_projectors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simultaneous_projectors(enlarged_corners::Array{E,3}, env::CTMRGEnv, alg::ProjectorAlgorithm)
simultaneous_projectors(coordinate, enlarged_corners::Array{E,3}, alg::ProjectorAlgorithm)</code></pre><p>Compute CTMRG projectors in the <code>:simultaneous</code> scheme either for all provided enlarged corners or on a specific <code>coordinate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/ctmrg/simultaneous.jl#L76-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.str-Tuple{TensorKit.AbstractTensorMap}"><a class="docstring-binding" href="#PEPSKit.str-Tuple{TensorKit.AbstractTensorMap}"><code>PEPSKit.str</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">str(t)</code></pre><p>Fermionic supertrace by using <code>@tensor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/util.jl#L121-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.su_iter-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, SimpleUpdate, SUWeight}"><a class="docstring-binding" href="#PEPSKit.su_iter-Tuple{Union{InfinitePEPO, InfinitePEPS}, LocalOperator, SimpleUpdate, SUWeight}"><code>PEPSKit.su_iter</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>One iteration of simple update</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/time_evolution/simpleupdate.jl#L157-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}"><a class="docstring-binding" href="#PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}"><code>PEPSKit.symmetrize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">symmetrize!(peps::InfinitePEPS, ::SymmetrizationStyle)</code></pre><p>Symmetrize a PEPS using the given <code>SymmetrizationStyle</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/symmetrization.jl#L91-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.symmetrize_retract_and_finalize!"><a class="docstring-binding" href="#PEPSKit.symmetrize_retract_and_finalize!"><code>PEPSKit.symmetrize_retract_and_finalize!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symmetrize_retract_and_finalize!(symm::SymmetrizationStyle, [retract, finalize!])</code></pre><p>Return the <code>retract</code> and <code>finalize!</code> function for symmetrizing the <code>peps</code> and <code>grad</code> tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/optimization/peps_optimization.jl#L319-L323">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.trace_physicalspaces-Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace}"><a class="docstring-binding" href="#PEPSKit.trace_physicalspaces-Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, 2, 4} where S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.trace_physicalspaces</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trace_physicalspaces(O)
</code></pre><p>Trace out the physical indices of a PEPO tensor, obtaining a partition function tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/networks/tensors.jl#L162-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.trmul-Union{Tuple{N}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, N, N}, TensorKit.AbstractTensorMap{&lt;:Any, S, N, N}}} where {S, N}"><a class="docstring-binding" href="#PEPSKit.trmul-Union{Tuple{N}, Tuple{S}, Tuple{TensorKit.AbstractTensorMap{&lt;:Any, S, N, N}, TensorKit.AbstractTensorMap{&lt;:Any, S, N, N}}} where {S, N}"><code>PEPSKit.trmul</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trmul(H, ρ)</code></pre><p>Compute <code>tr(H * ρ)</code> without forming <code>H * ρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/util.jl#L133-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.twistdual!-Tuple{TensorKit.AbstractTensorMap, Int64}"><a class="docstring-binding" href="#PEPSKit.twistdual!-Tuple{TensorKit.AbstractTensorMap, Int64}"><code>PEPSKit.twistdual!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">twistdual(t::AbstractTensorMap, i)
twistdual!(t::AbstractTensorMap, i)</code></pre><p>Twist the i-th leg of a tensor <code>t</code> if it represents a dual space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/util.jl#L105-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.update_message-Tuple{CartesianIndex{3}, InfiniteSquareNetwork, BPEnv}"><a class="docstring-binding" href="#PEPSKit.update_message-Tuple{CartesianIndex{3}, InfiniteSquareNetwork, BPEnv}"><code>PEPSKit.update_message</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update the BP message in <code>env.messages[I]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/algorithms/bp/beliefpropagation.jl#L99-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.@autoopt-Tuple{Any}"><a class="docstring-binding" href="#PEPSKit.@autoopt-Tuple{Any}"><code>PEPSKit.@autoopt</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">autoopt(ex)</code></pre><p>Preprocessor macro for <code>@tensor</code> which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with <code>d</code>, <code>D</code>, or <code>χ</code> are automatically inserted with the corresponding costs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/autoopt.jl#L6-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.@fwdthreads-Tuple{Any}"><a class="docstring-binding" href="#PEPSKit.@fwdthreads-Tuple{Any}"><code>PEPSKit.@fwdthreads</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@fwdthreads(ex)</code></pre><p>Apply <code>Threads.@threads</code> only in the forward pass of the program.</p><p>It works by wrapping the for-loop expression in an if statement where in the forward pass the loop in computed in parallel using <code>Threads.@threads</code>, whereas in the backwards pass the <code>Threads.@threads</code> is omitted in order to make the expression differentiable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/diffable_threads.jl#L52-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.@showtypeofgrad-Tuple{Any}"><a class="docstring-binding" href="#PEPSKit.@showtypeofgrad-Tuple{Any}"><code>PEPSKit.@showtypeofgrad</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@showtypeofgrad(x)</code></pre><p>Macro utility to show to type of the gradient that is about to accumulate for <code>x</code>.</p><p>See also <code>Zygote.@showgrad</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/utility/util.jl#L193-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.Defaults"><a class="docstring-binding" href="#PEPSKit.Defaults"><code>PEPSKit.Defaults</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">module Defaults</code></pre><p>Module containing default algorithm parameter values and arguments.</p><p><strong>CTMRG</strong></p><ul><li><code>ctmrg_tol=1.0e-8</code> : Tolerance checking singular value and norm convergence.</li><li><code>ctmrg_maxiter=100</code> : Maximal number of CTMRG iterations per run.</li><li><code>ctmrg_miniter=4</code> : Minimal number of CTMRG carried out.</li><li><code>ctmrg_alg=:simultaneous</code> : Default CTMRG algorithm variant.<ul><li><code>:simultaneous</code> : Simultaneous expansion and renormalization of all sides.</li><li><code>:sequential</code> : Sequential application of left moves and rotations.</li></ul></li><li><code>ctmrg_verbosity=2</code> : CTMRG output information verbosity</li></ul><p><strong>SVD forward &amp; reverse</strong></p><ul><li><code>trunc=:fixedspace</code> : Truncation scheme for SVDs and other decompositions.<ul><li><code>:fixedspace</code> : Keep virtual spaces fixed during projection</li><li><code>:notrunc</code> : No singular values are truncated and the performed SVDs are exact</li><li><code>:truncerror</code> : Additionally supply error threshold <code>η</code>; truncate to the maximal virtual dimension of <code>η</code></li><li><code>:truncrank</code> : Additionally supply truncation dimension <code>η</code>; truncate such that the 2-norm of the truncated values is smaller than <code>η</code></li><li><code>:truncspace</code> : Additionally supply truncation space <code>η</code>; truncate according to the supplied vector space </li><li><code>:trunctol</code> : Additionally supply singular value cutoff <code>η</code>; truncate such that every retained singular value is larger than <code>η</code></li></ul></li><li><code>rrule_degeneracy_atol=1.0e-13</code> : Broadening amplitude which smoothens the divergent term in the retained contributions of an SVD or eigh pullback, in case of (pseudo) degenerate singular values</li><li><code>svd_fwd_alg=:sdd</code> : SVD algorithm that is used in the forward pass.<ul><li><code>:sdd</code> : MatrixAlgebraKit&#39;s <code>LAPACK_DivideAndConquer</code></li><li><code>:svd</code> : MatrixAlgebraKit&#39;s <code>LAPACK_QRIteration</code></li><li><code>:iterative</code> : Iterative SVD only computing the specifed number of singular values and vectors, see <a href="#PEPSKit.IterSVD"><code>IterSVD</code></a></li></ul></li><li><code>svd_rrule_tol=1.0e-8</code> : Accuracy of SVD reverse-rule.</li><li><code>svd_rrule_min_krylovdim=48</code> : Minimal Krylov dimension of the reverse-rule algorithm (if it is a Krylov algorithm).</li><li><code>svd_rrule_verbosity=-1</code> : SVD gradient output verbosity.</li><li><code>svd_rrule_alg=:full</code> : Reverse-rule algorithm for the SVD gradient.<ul><li><code>:full</code> : Uses a modified version of MatrixAlgebraKit&#39;s reverse-rule for <code>svd_compact</code> which doesn&#39;t solve any linear problem and instead requires access to the full SVD, see <a href="#PEPSKit.FullSVDPullback"><code>PEPSKit.FullSVDPullback</code></a>.</li><li><code>:trunc</code> : MatrixAlgebraKit&#39;s <code>svd_trunc_pullback!</code> solving a Sylvester equation on the truncated subspace and therefore only requires access to the truncated SVD.</li><li><code>:gmres</code> : GMRES iterative linear solver, see the <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.GMRES">KrylovKit docs</a> for details</li><li><code>:bicgstab</code> : BiCGStab iterative linear solver, see the <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.BiCGStab">KrylovKit docs</a> for details</li><li><code>:arnoldi</code> : Arnoldi Krylov algorithm, see the <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.Arnoldi">KrylovKit docs</a> for details</li></ul></li></ul><p><strong><code>eigh</code> forward &amp; reverse</strong></p><ul><li><code>eigh_fwd_alg=:qriteration</code> : <code>eigh</code> algorithm that is used in the forward pass.<ul><li><code>:qriteration</code> : MatrixAlgebraKit&#39;s <code>LAPACK_QRIteration</code>.</li><li><code>:bisection</code> : MatrixAlgebraKit&#39;s <code>LAPACK_Bisection</code>.</li><li><code>:divideandconquer</code> : MatrixAlgebraKit&#39;s <code>LAPACK_DivideAndConquer</code>.</li><li><code>:multiple</code> : MatrixAlgebraKit&#39;s <code>LAPACK_MultipleRelativelyRobustRepresentations</code>. </li><li><code>:lanczos</code> : Lanczos algorithm, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.Lanczos"><code>KrylovKit.Lanczos</code></a> for details.</li><li><code>:blocklanczos</code> : Block Lanczos algorithm, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.BlockLanczos"><code>KrylovKit.BlockLanczos</code></a> for details.</li></ul></li><li><code>eigh_rrule_alg=:full</code> : Reverse-rule algorithm for the <code>eigh</code> gradient.<ul><li><code>:full</code> : Full pullback algorithm for eigendecompositions, see <a href="#PEPSKit.FullEighPullback"><code>PEPSKit.FullEighPullback</code></a>.</li><li><code>:trunc</code> : Truncated reverse-mode algorithm for eigendecompositions, see <a href="#PEPSKit.TruncEighPullback"><code>PEPSKit.TruncEighPullback</code></a>.</li></ul></li><li><code>eigh_rrule_verbosity=0</code> : eigh gradient output verbosity.</li></ul><p><strong>Projectors</strong></p><ul><li><code>projector_alg=:halfinfinite</code> : Default variant of the CTMRG projector algorithm.<ul><li><code>:halfinfinite</code> : Projection via SVDs of half-infinite (two enlarged corners) CTMRG environments.</li><li><code>:fullinfinite</code> : Projection via SVDs of full-infinite (all four enlarged corners) CTMRG environments.</li></ul></li><li><code>projector_verbosity=0</code> : Projector output information verbosity.</li></ul><p><strong>Fixed-point gradient</strong></p><ul><li><code>gradient_tol=1.0e-6</code> : Convergence tolerance for the fixed-point gradient iteration.</li><li><code>gradient_maxiter=30</code> : Maximal number of iterations for computing the CTMRG fixed-point gradient.</li><li><code>gradient_verbosity=-1</code> : Gradient output information verbosity.</li><li><code>gradient_linsolver=:bicgstab</code> : Default linear solver for the <code>LinSolver</code> gradient algorithm.<ul><li><code>:gmres</code> : GMRES iterative linear solver, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.GMRES"><code>KrylovKit.GMRES</code></a> for details</li><li><code>:bicgstab</code> : BiCGStab iterative linear solver, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.BiCGStab"><code>KrylovKit.BiCGStab</code></a> for details</li></ul></li><li><code>gradient_eigsolver=:arnoldi</code> : Default eigensolver for the <code>EigSolver</code> gradient algorithm.<ul><li><code>:arnoldi</code> : Arnoldi Krylov algorithm, see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/algorithms/#KrylovKit.Arnoldi"><code>KrylovKit.Arnoldi</code></a> for details</li></ul></li><li><code>gradient_eigsolver_eager=true</code> : Enables <code>EigSolver</code> algorithm to finish before the full Krylov dimension is reached.</li><li><code>gradient_iterscheme=:fixed</code> : Scheme for differentiating one CTMRG iteration.<ul><li><code>:fixed</code> : the differentiated CTMRG iteration uses a pre-computed SVD with a fixed set of gauges</li><li><code>:diffgauge</code> : the differentiated iteration consists of a CTMRG iteration and a subsequent gauge-fixing step such that the gauge-fixing procedure is differentiated as well</li></ul></li><li><code>gradient_alg=:eigsolver</code> : Algorithm variant for computing the gradient fixed-point.</li></ul><p><strong>Optimization</strong></p><ul><li><code>reuse_env=true</code> : If <code>true</code>, the current optimization step is initialized on the previous environment, otherwise a random environment is used.</li><li><code>optimizer_tol=0.0001</code> : Gradient norm tolerance of the optimizer.</li><li><code>optimizer_maxiter=100</code> : Maximal number of optimization steps.</li><li><code>optimizer_verbosity=3</code> : Optimizer output information verbosity.</li><li><code>optimizer_alg=:lbfgs</code> : Default <code>OptimKit.OptimizerAlgorithm</code> for PEPS optimization.<ul><li><code>:gradientdescent</code> : Gradient descent algorithm, see the <a href="https://github.com/Jutho/OptimKit.jl">OptimKit README</a></li><li><code>:conjugategradient</code> : Conjugate gradient algorithm, see the <a href="https://github.com/Jutho/OptimKit.jl">OptimKit README</a></li><li><code>:lbfgs</code> : L-BFGS algorithm, see the <a href="https://github.com/Jutho/OptimKit.jl">OptimKit README</a></li></ul></li><li><code>ls_maxiter=10</code> : Maximum number of iterations for the line search in each step of the optimization.</li><li><code>ls_maxfg=20</code> : Maximum number of function evaluations for the line search in each step of the optimization.</li><li><code>lbfgs_memory=20</code> : Size of limited memory representation of BFGS Hessian matrix.</li></ul><p><strong>OhMyThreads scheduler</strong></p><ul><li><code>scheduler=Ref{Scheduler}(...)</code> : Multithreading scheduler which can be accessed via <code>set_scheduler!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/Defaults.jl#L1-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PEPSKit.Defaults.set_scheduler!"><a class="docstring-binding" href="#PEPSKit.Defaults.set_scheduler!"><code>PEPSKit.Defaults.set_scheduler!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_scheduler!([scheduler]; kwargs...)</code></pre><p>Set <code>OhMyThreads</code> multithreading scheduler parameters.</p><p>The function either accepts a <code>scheduler</code> as an <code>OhMyThreads.Scheduler</code> or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via</p><pre><code class="language-julia hljs">set_scheduler!(StaticScheduler(; ntasks=4, chunking=true))</code></pre><p>or equivalently with </p><pre><code class="language-julia hljs">set_scheduler!(:static; ntasks=4, chunking=true)</code></pre><p>For a detailed description of all schedulers and their keyword arguments consult the <a href="https://juliafolds2.github.io/OhMyThreads.jl/stable/refs/api/#OhMyThreads.Schedulers.Scheduler">OhMyThreads</a> documentation.</p><p>If no <code>scheduler</code> is passed and only kwargs are provided, the <code>DynamicScheduler</code> constructor is used with the provided kwargs.</p><p>To reset the scheduler to its default value, one calls <code>set_scheduler!</code> without passing arguments which then uses the default <code>DynamicScheduler()</code>. If the number of used threads is just one it falls back to <code>SerialScheduler()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/61fab8bbf9f28824a033445df5f342f29480e1b3/src/Defaults.jl#L158-L183">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/boundary_mps/">« Boundary MPS contractions of 2D networks</a><a class="docs-footer-nextpage" href="../../changelog/">Changelog »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 11:15">Wednesday 25 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
