<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>C₄ᵥ CTMRG and QR-CTMRG · PEPSKit.jl</title><meta name="title" content="C₄ᵥ CTMRG and QR-CTMRG · PEPSKit.jl"/><meta property="og:title" content="C₄ᵥ CTMRG and QR-CTMRG · PEPSKit.jl"/><meta property="twitter:title" content="C₄ᵥ CTMRG and QR-CTMRG · PEPSKit.jl"/><meta name="description" content="Documentation for PEPSKit.jl."/><meta property="og:description" content="Documentation for PEPSKit.jl."/><meta property="twitter:description" content="Documentation for PEPSKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PEPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PEPSKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/models/">Models</a></li><li><a class="tocitem" href="../../man/multithreading/">Multithreading</a></li><li><a class="tocitem" href="../../man/precompilation/">Precompilation using PrecompileTools.jl</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">Overview</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Optimization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../heisenberg/">Optimizing the 2D Heisenberg model</a></li><li><a class="tocitem" href="../bose_hubbard/">Optimizing the <span>$U(1)$</span>-symmetric Bose-Hubbard model</a></li><li><a class="tocitem" href="../xxz/">Néel order in the <span>$U(1)$</span>-symmetric XXZ model</a></li><li><a class="tocitem" href="../fermi_hubbard/">Fermi-Hubbard model with <span>$f\mathbb{Z}_2 \boxtimes U(1)$</span> symmetry, at large <span>$U$</span> and half-filling</a></li><li class="is-active"><a class="tocitem" href>C₄ᵥ CTMRG and QR-CTMRG</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-specialized-Hamiltonian-for-Cᵥ-symmetric-PEPS"><span>Defining a specialized Hamiltonian for C₄ᵥ-symmetric PEPS</span></a></li><li><a class="tocitem" href="#Initializing-Cᵥ-invariant-PEPSs-and-environments"><span>Initializing C₄ᵥ-invariant PEPSs and environments</span></a></li><li><a class="tocitem" href="#Cᵥ-symmetric-optimization"><span>C₄ᵥ-symmetric optimization</span></a></li><li><a class="tocitem" href="#QR-CTMRG"><span>QR-CTMRG</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Time Evolution</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../heisenberg_su/">Simple update for the Heisenberg model</a></li><li><a class="tocitem" href="../hubbard_su/">Simple update for the Fermi-Hubbard model at half-filling</a></li><li><a class="tocitem" href="../j1j2_su/">Three-site simple update for the <span>$J_1$</span>-<span>$J_2$</span> model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Partition Functions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../2d_ising_partition_function/">The 2D classical Ising model using CTMRG</a></li><li><a class="tocitem" href="../3d_ising_partition_function/">The 3D classical Ising model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Boundary MPS</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../boundary_mps/">Boundary MPS contractions of 2D networks</a></li></ul></li></ul></li><li><a class="tocitem" href="../../lib/lib/">Library</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Optimization</a></li><li class="is-active"><a href>C₄ᵥ CTMRG and QR-CTMRG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>C₄ᵥ CTMRG and QR-CTMRG</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/PEPSKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/master/examples/c4v_ctmrg/main.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p><a href="https://mybinder.org/v2/gh/QuantumKitHub/PEPSKit.jl/gh-pages?filepath=dev/examples/c4v_ctmrg/main.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/QuantumKitHub/PEPSKit.jl/blob/gh-pages/dev/examples/c4v_ctmrg/main.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a> <a href="https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/QuantumKitHub/PEPSKit.jl/examples/tree/gh-pages/dev/examples/c4v_ctmrg"><img src="https://img.shields.io/badge/download-project-orange" alt/></a></p><h1 id="Cᵥ-CTMRG-and-QR-CTMRG"><a class="docs-heading-anchor" href="#Cᵥ-CTMRG-and-QR-CTMRG">C₄ᵥ CTMRG and QR-CTMRG</a><a id="Cᵥ-CTMRG-and-QR-CTMRG-1"></a><a class="docs-heading-anchor-permalink" href="#Cᵥ-CTMRG-and-QR-CTMRG" title="Permalink"></a></h1><p>In this example we demonstrate specialized CTMRG variants that exploit the <span>$C_{4v}$</span> point group symmetry of the physical model and PEPS at hand. This allows us to significantly reduce the computational cost of contraction and optimization. To that end, we will consider the Heisenberg Hamiltonian on the square lattice</p><p class="math-container">\[H = \sum_{\langle i,j \rangle} \left ( J_x S^{x}_i S^{x}_j + J_y S^{y}_i S^{y}_j + J_z S^{z}_i S^{z}_j \right )\]</p><p>We want to treat the model in the antiferromagnetic regime where the ground state exhibits bipartite sublattice structure. To be able to represent this ground state in a <span>$C_{4v}$</span>-invariant manner on a single-site unit cell, we perform a unitary sublattice rotation by setting <span>$(J_x, J_y, J_z)=(-1, 1, -1)$</span>.</p><p>Let&#39;s get started by seeding the RNG and doing the imports:</p><pre><code class="language-julia hljs">using Random
using TensorKit, PEPSKit
Random.seed!(123456789);</code></pre><h2 id="Defining-a-specialized-Hamiltonian-for-Cᵥ-symmetric-PEPS"><a class="docs-heading-anchor" href="#Defining-a-specialized-Hamiltonian-for-Cᵥ-symmetric-PEPS">Defining a specialized Hamiltonian for C₄ᵥ-symmetric PEPS</a><a id="Defining-a-specialized-Hamiltonian-for-Cᵥ-symmetric-PEPS-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-specialized-Hamiltonian-for-Cᵥ-symmetric-PEPS" title="Permalink"></a></h2><p>Since the model under consideration and its ground state are invariant under 90° rotation and Hermitian reflection, evaluating the expectation values of the horizontal and vertical energy contributions are exactly equivalent. This allows us to effectively halve the computational cost by evaluating only half of the terms and multiplying by 2. In practice, we implement this using a specialized <a href="../../lib/lib/#PEPSKit.LocalOperator"><code>LocalOperator</code></a> that contains only the relevant terms:</p><pre><code class="language-julia hljs">using MPSKitModels: S_xx, S_yy, S_zz

# Heisenberg model assuming C4v symmetric PEPS and environment, which only evaluates necessary term
function heisenberg_XYZ_c4v(lattice::InfiniteSquare; kwargs...)
    return heisenberg_XYZ_c4v(ComplexF64, Trivial, lattice; kwargs...)
end
function heisenberg_XYZ_c4v(
        T::Type{&lt;:Number}, S::Type{&lt;:Sector}, lattice::InfiniteSquare;
        Jx = -1.0, Jy = 1.0, Jz = -1.0, spin = 1 // 2,
    )
    @assert size(lattice) == (1, 1) &quot;only trivial unit cells supported by C4v-symmetric Hamiltonians&quot;
    term =
        rmul!(S_xx(T, S; spin = spin), Jx) +
        rmul!(S_yy(T, S; spin = spin), Jy) +
        rmul!(S_zz(T, S; spin = spin), Jz)
    spaces = fill(domain(term)[1], (1, 1))
    return LocalOperator( # horizontal and vertical contributions are identical
        spaces, (CartesianIndex(1, 1), CartesianIndex(1, 2)) =&gt; 2 * term
    )
end;</code></pre><h2 id="Initializing-Cᵥ-invariant-PEPSs-and-environments"><a class="docs-heading-anchor" href="#Initializing-Cᵥ-invariant-PEPSs-and-environments">Initializing C₄ᵥ-invariant PEPSs and environments</a><a id="Initializing-Cᵥ-invariant-PEPSs-and-environments-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-Cᵥ-invariant-PEPSs-and-environments" title="Permalink"></a></h2><p>In order to use <span>$C_{4v}$</span>-symmetric algorithms, it is of course crucial to use initial guesses with <span>$C_{4v}$</span> symmetry. First, we create a real-valued random PEPS that we explicitly symmetrize using <a href="../../lib/lib/#PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}"><code>symmetrize!</code></a> and the <span>$C_{4v}$</span> symmetry <a href="../../lib/lib/#PEPSKit.RotateReflect"><code>RotateReflect</code></a>:</p><pre><code class="language-julia hljs">symm = RotateReflect()
D = 2
T = Float64
peps_random = InfinitePEPS(randn, T, ComplexSpace(2), ComplexSpace(D))
peps₀ = symmetrize!(peps_random, symm);</code></pre><p>Initializing an <span>$C_{4v}$</span>-invariant environment is a bit more subtle and there is no one-size-fits-all solution. As a good starting point one can use the initialization function <a href="../../lib/lib/#PEPSKit.initialize_random_c4v_env-Tuple{Any, TensorKit.ElementarySpace}"><code>initialize_random_c4v_env</code></a> (or also <a href="../../lib/lib/#PEPSKit.initialize_singlet_c4v_env-Tuple{InfinitePEPS, TensorKit.ElementarySpace}"><code>initialize_singlet_c4v_env</code></a>) where we construct a diagonal corner with random real entries and a random Hermitian edge tensor.</p><pre><code class="language-julia hljs">χ = 16
env_random_c4v = initialize_random_c4v_env(peps₀, ComplexSpace(χ));</code></pre><p>Then contracting the PEPS using <span>$C_{4v}$</span> CTMRG is as easy as just calling <a href="../../lib/lib/#MPSKit.leading_boundary-Tuple{Any, Any, Any}"><code>leading_boundary</code></a> but passing the initial PEPS and environment as well as the <code>alg = :c4v</code> keyword argument:</p><pre><code class="language-julia hljs">env₀, = leading_boundary(env_random_c4v, peps₀; alg = :c4v, tol = 1.0e-10);</code></pre><pre><code class="nohighlight hljs">[ Info: CTMRG init:	obj = -1.430301957018e-02	err = 1.0000e+00
[ Info: CTMRG conv 36:	obj = +8.685181513863e+00	err = 6.8827026254e-11	time = 2.84 sec
</code></pre><h2 id="Cᵥ-symmetric-optimization"><a class="docs-heading-anchor" href="#Cᵥ-symmetric-optimization">C₄ᵥ-symmetric optimization</a><a id="Cᵥ-symmetric-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Cᵥ-symmetric-optimization" title="Permalink"></a></h2><p>We now take <code>peps₀</code> and <code>env₀</code> as a starting point for a gradient-based energy minimization where we contract using <span>$C_{4v}$</span> CTMRG such that the energy gradient will also exhibit <span>$C_{4v}$</span> symmetry. For that, we call <code>fixedpoint</code> and specify <code>alg = :c4v</code> as the boundary contraction algorithm:</p><pre><code class="language-julia hljs">H = real(heisenberg_XYZ_c4v(InfiniteSquare())) # make Hamiltonian real-valued
peps, env, E, = fixedpoint(
    H, peps₀, env₀; optimizer_alg = (; tol = 1.0e-4), boundary_alg = (; alg = :c4v),
);</code></pre><pre><code class="nohighlight hljs">[ Info: LBFGS: initializing with f = -5.047653728981e-01, ‖∇f‖ = 1.9060e-01
[ Info: LBFGS: iter    1, Δt  3.82 s: f = -5.056459154685e-01, ‖∇f‖ = 1.3798e-01, α = 1.00e+00, m = 0, nfg = 1
[ Info: LBFGS: iter    2, Δt  2.28 s: f = -6.375540411515e-01, ‖∇f‖ = 1.7202e-01, α = 2.79e+01, m = 1, nfg = 5
[ Info: LBFGS: iter    3, Δt  66.0 ms: f = -6.486432921799e-01, ‖∇f‖ = 1.3180e-01, α = 1.00e+00, m = 2, nfg = 1
[ Info: LBFGS: iter    4, Δt  53.3 ms: f = -6.520905366511e-01, ‖∇f‖ = 1.2693e-01, α = 1.00e+00, m = 3, nfg = 1
[ Info: LBFGS: iter    5, Δt  54.1 ms: f = -6.543779478465e-01, ‖∇f‖ = 8.4374e-02, α = 1.00e+00, m = 4, nfg = 1
[ Info: LBFGS: iter    6, Δt  50.9 ms: f = -6.574474243297e-01, ‖∇f‖ = 9.2229e-02, α = 1.00e+00, m = 5, nfg = 1
[ Info: LBFGS: iter    7, Δt  50.8 ms: f = -6.589601436763e-01, ‖∇f‖ = 4.1340e-02, α = 1.00e+00, m = 6, nfg = 1
[ Info: LBFGS: iter    8, Δt  50.2 ms: f = -6.593161746273e-01, ‖∇f‖ = 1.6522e-02, α = 1.00e+00, m = 7, nfg = 1
[ Info: LBFGS: iter    9, Δt  54.4 ms: f = -6.594944356002e-01, ‖∇f‖ = 1.3207e-02, α = 1.00e+00, m = 8, nfg = 1
[ Info: LBFGS: iter   10, Δt  54.4 ms: f = -6.598273620822e-01, ‖∇f‖ = 1.2344e-02, α = 1.00e+00, m = 9, nfg = 1
[ Info: LBFGS: iter   11, Δt  54.5 ms: f = -6.600090370393e-01, ‖∇f‖ = 8.5852e-03, α = 1.00e+00, m = 10, nfg = 1
[ Info: LBFGS: iter   12, Δt  50.0 ms: f = -6.601648157099e-01, ‖∇f‖ = 3.1453e-03, α = 1.00e+00, m = 11, nfg = 1
[ Info: LBFGS: iter   13, Δt  47.5 ms: f = -6.601883494925e-01, ‖∇f‖ = 2.2795e-03, α = 1.00e+00, m = 12, nfg = 1
[ Info: LBFGS: iter   14, Δt  47.4 ms: f = -6.602037369191e-01, ‖∇f‖ = 2.8426e-03, α = 1.00e+00, m = 13, nfg = 1
[ Info: LBFGS: iter   15, Δt  48.3 ms: f = -6.602113170029e-01, ‖∇f‖ = 2.0017e-03, α = 1.00e+00, m = 14, nfg = 1
[ Info: LBFGS: iter   16, Δt  35.4 ms: f = -6.602199370383e-01, ‖∇f‖ = 1.2403e-03, α = 1.00e+00, m = 15, nfg = 1
[ Info: LBFGS: iter   17, Δt  44.1 ms: f = -6.602252410543e-01, ‖∇f‖ = 7.3832e-04, α = 1.00e+00, m = 16, nfg = 1
[ Info: LBFGS: iter   18, Δt  53.2 ms: f = -6.602292169497e-01, ‖∇f‖ = 6.4978e-04, α = 1.00e+00, m = 17, nfg = 1
[ Info: LBFGS: iter   19, Δt  50.3 ms: f = -6.602308383659e-01, ‖∇f‖ = 3.7433e-04, α = 1.00e+00, m = 18, nfg = 1
[ Info: LBFGS: iter   20, Δt  42.1 ms: f = -6.602310776646e-01, ‖∇f‖ = 2.4482e-04, α = 1.00e+00, m = 19, nfg = 1
[ Info: LBFGS: converged after 21 iterations and time  2.99 m: f = -6.602310927637e-01, ‖∇f‖ = 2.4546e-05
</code></pre><p>We note that this energy is slightly higher than the one obtained from an <a href="../heisenberg/#examples_heisenberg">optimization using asymmetric CTMRG</a> with equivalent settings. Indeed, this is what one would expect since the <span>$C_{4v}$</span> symmetry restricts the PEPS ansatz leading to fewer free parameters, i.e. an ansatz with reduced expressivity. Comparing against Juraj Hasik&#39;s data from <span>$J_1\text{-}J_2$</span> <a href="https://github.com/jurajHasik/j1j2_ipeps_states/blob/main/single-site_pg-C4v-A1/j20.0/state_1s_A1_j20.0_D2_chi_opt48.dat">PEPS simulations</a>, we find very good agreement:</p><pre><code class="language-julia hljs">E_ref = -0.6602310934799577 # Juraj&#39;s energy at D=2, χ=16 with C4v symmetry
@show (E - E_ref) / E_ref;</code></pre><pre><code class="nohighlight hljs">(E - E_ref) / E_ref = -1.084830528406467e-9
</code></pre><p>As a consistency check, we can compute the vertical and horizontal correlation lengths, and should find that they are equal (up to the sparse eigensolver tolerance):</p><pre><code class="language-julia hljs">ξ_h, ξ_v, = correlation_length(peps, env)
@show ξ_h ξ_v;</code></pre><pre><code class="nohighlight hljs">ξ_h = [0.6625894995018514]
ξ_v = [0.6625894995018511]
</code></pre><h2 id="QR-CTMRG"><a class="docs-heading-anchor" href="#QR-CTMRG">QR-CTMRG</a><a id="QR-CTMRG-1"></a><a class="docs-heading-anchor-permalink" href="#QR-CTMRG" title="Permalink"></a></h2><p>The conventional <span>$C_{4v}$</span> CTMRG algorithm works by performing an eigendecomposition of the enlarged corner <span>$A = V D V^\dagger$</span>, taking the diagonal eigenvalue tensor as the new corner <span>$C&#39; = D$</span> and then renormalizing the edge using the isometry <span>$V$</span>. There exist modifications to this standard algorithm, most notably <em>QR-CTMRG</em> as presented in a recent publication by <a href="../../references/#zhang_accelerating_2025">Zhang, Yang and Corboz</a>. There the idea is to replace the eigendecomposition by a QR decomposition of a lower-rank approximation of the enlarged corner. While less accurate in some ways, the QR-CTMRG approach substantially accelerates contraction and optimization times, and also has vastly improved GPU performance. Notably, it is found that QR-CTMRG converges to the same fixed point as regular <span>$C_{4v}$</span> CTMRG.</p><p>In PEPSKit terms, using QR-CTMRG just amounts to switching out the projector algorithm that is used by the <a href="../../lib/lib/#PEPSKit.C4vCTMRG"><code>C4vCTMRG</code></a> algorithm to <code>projector_alg = :c4v_qr</code> (as opposed to <code>:c4v_eigh</code>). QR-CTMRG tends to need significantly more iterations to converge while still being much faster, hence we need to increase <code>maxiter</code>:</p><pre><code class="language-julia hljs">env_qr₀, = leading_boundary(
    env_random_c4v, peps; alg = :c4v, projector_alg = :c4v_qr, maxiter = 500,
);</code></pre><pre><code class="nohighlight hljs">[ Info: CTMRG init:	obj = +5.600073842622e-03	err = 1.0000e+00
┌ Warning: CTMRG cancel 500:	obj = +5.924396753059e-01	err = 4.2047306494e-05	time = 0.47 sec
└ @ PEPSKit ~/repos/PEPSKit.jl/src/algorithms/ctmrg/ctmrg.jl:168
</code></pre><p>To optimize using QR-CTMRG we proceed analogously by specifiying <code>projector_alg = :c4v_qr</code> and increasing the <code>maxiter</code> when setting the boundary algorithm parameters. We make sure to supply the <code>env_qr₀</code> initial environment because it does not use <code>DiagonalTensorMap</code>s as its corner type (only regular <code>eigh</code>-based <span>$C_{4v}$</span> CTMRG produces diagonal corners):</p><pre><code class="language-julia hljs">peps_qr, env_qr, E_qr, = fixedpoint(
    H, peps₀, env_qr₀;
    optimizer_alg = (; tol = 1.0e-4),
    boundary_alg = (; alg = :c4v, projector_alg = :c4v_qr, maxiter = 500),
    gradient_alg = (; alg = :linsolver)
);
@show (E_qr - E_ref) / E_ref;</code></pre><pre><code class="nohighlight hljs">[ Info: LBFGS: initializing with f = -5.047653728981e-01, ‖∇f‖ = 1.9060e-01
[ Info: LBFGS: iter    1, Δt  1.50 s: f = -5.056459386479e-01, ‖∇f‖ = 1.3798e-01, α = 1.00e+00, m = 0, nfg = 1
[ Info: LBFGS: iter    2, Δt  1.57 s: f = -6.375600504499e-01, ‖∇f‖ = 1.6744e-01, α = 2.79e+01, m = 1, nfg = 5
[ Info: LBFGS: iter    3, Δt  62.0 ms: f = -6.477941757691e-01, ‖∇f‖ = 1.2710e-01, α = 1.00e+00, m = 2, nfg = 1
[ Info: LBFGS: iter    4, Δt 409.6 ms: f = -6.489264548265e-01, ‖∇f‖ = 1.2728e-01, α = 1.00e+00, m = 3, nfg = 1
[ Info: LBFGS: iter    5, Δt  97.3 ms: f = -6.520948679742e-01, ‖∇f‖ = 1.9001e-01, α = 1.00e+00, m = 4, nfg = 1
[ Info: LBFGS: iter    6, Δt  96.6 ms: f = -6.556853372287e-01, ‖∇f‖ = 7.4701e-02, α = 3.20e-01, m = 5, nfg = 2
[ Info: LBFGS: iter    7, Δt  48.9 ms: f = -6.577585366615e-01, ‖∇f‖ = 4.6457e-02, α = 1.00e+00, m = 6, nfg = 1
[ Info: LBFGS: iter    8, Δt  54.4 ms: f = -6.589067591492e-01, ‖∇f‖ = 5.6776e-02, α = 1.00e+00, m = 7, nfg = 1
[ Info: LBFGS: iter    9, Δt  58.1 ms: f = -6.594497314275e-01, ‖∇f‖ = 2.5279e-02, α = 1.00e+00, m = 8, nfg = 1
[ Info: LBFGS: iter   10, Δt  73.3 ms: f = -6.596013508512e-01, ‖∇f‖ = 1.2057e-02, α = 1.00e+00, m = 9, nfg = 1
[ Info: LBFGS: iter   11, Δt  61.2 ms: f = -6.597238062798e-01, ‖∇f‖ = 1.1855e-02, α = 1.00e+00, m = 10, nfg = 1
[ Info: LBFGS: iter   12, Δt  38.5 ms: f = -6.598902039179e-01, ‖∇f‖ = 1.2159e-02, α = 1.00e+00, m = 11, nfg = 1
[ Info: LBFGS: iter   13, Δt  50.9 ms: f = -6.600647711574e-01, ‖∇f‖ = 9.2790e-03, α = 1.00e+00, m = 12, nfg = 1
[ Info: LBFGS: iter   14, Δt  53.2 ms: f = -6.601721648894e-01, ‖∇f‖ = 3.6997e-03, α = 1.00e+00, m = 13, nfg = 1
[ Info: LBFGS: iter   15, Δt  52.3 ms: f = -6.601905466298e-01, ‖∇f‖ = 2.6113e-03, α = 1.00e+00, m = 14, nfg = 1
[ Info: LBFGS: iter   16, Δt  40.4 ms: f = -6.602004506851e-01, ‖∇f‖ = 3.2492e-03, α = 1.00e+00, m = 15, nfg = 1
[ Info: LBFGS: iter   17, Δt  52.5 ms: f = -6.602066238957e-01, ‖∇f‖ = 2.9721e-03, α = 1.00e+00, m = 16, nfg = 1
[ Info: LBFGS: iter   18, Δt  54.9 ms: f = -6.602207074042e-01, ‖∇f‖ = 1.5783e-03, α = 1.00e+00, m = 17, nfg = 1
[ Info: LBFGS: iter   19, Δt  70.7 ms: f = -6.602252432623e-01, ‖∇f‖ = 7.4701e-04, α = 1.00e+00, m = 18, nfg = 1
[ Info: LBFGS: iter   20, Δt 431.1 ms: f = -6.602282359103e-01, ‖∇f‖ = 1.2155e-03, α = 1.00e+00, m = 19, nfg = 1
[ Info: LBFGS: iter   21, Δt 213.5 ms: f = -6.602299515427e-01, ‖∇f‖ = 1.0743e-03, α = 1.00e+00, m = 20, nfg = 1
[ Info: LBFGS: iter   22, Δt 425.4 ms: f = -6.602310402232e-01, ‖∇f‖ = 4.7766e-04, α = 1.00e+00, m = 20, nfg = 1
[ Info: LBFGS: converged after 23 iterations and time 37.91 s: f = -6.602310919804e-01, ‖∇f‖ = 5.4688e-05
(E_qr - E_ref) / E_ref = -2.2712457151788596e-9
</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fermi_hubbard/">« Fermi-Hubbard model with <span>$f\mathbb{Z}_2 \boxtimes U(1)$</span> symmetry, at large <span>$U$</span> and half-filling</a><a class="docs-footer-nextpage" href="../heisenberg_su/">Simple update for the Heisenberg model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Tuesday 24 February 2026 10:20">Tuesday 24 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
